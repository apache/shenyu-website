"use strict";(self.webpackChunkshenyu_website=self.webpackChunkshenyu_website||[]).push([[80126],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>g});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(n),u=i,g=d["".concat(s,".").concat(u)]||d[u]||h[u]||o;return n?a.createElement(g,r(r({ref:t},c),{},{components:n})):a.createElement(g,r({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},81915:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(87462),i=(n(67294),n(3905));const o={title:"Http Long Polling Data Synchronization Source Code Analysis",author:"midnight2104",author_title:"Apache ShenYu Committer",author_url:"https://github.com/midnight2104",tags:["http","data sync","Apache ShenYu"]},r=void 0,l={permalink:"/blog/DataSync-SourceCode-Analysis-Http-Data-Sync",editUrl:"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Http-Data-Sync.md",source:"@site/blog/DataSync-SourceCode-Analysis-Http-Data-Sync.md",title:"Http Long Polling Data Synchronization Source Code Analysis",description:"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.",date:"2023-01-13T07:46:33.845Z",formattedDate:"January 13, 2023",tags:[{label:"http",permalink:"/blog/tags/http"},{label:"data sync",permalink:"/blog/tags/data-sync"},{label:"Apache ShenYu",permalink:"/blog/tags/apache-shen-yu"}],readingTime:30.365,truncated:!1,prevItem:{title:"Etcd Data Synchronization Source Code Analysis",permalink:"/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync"},nextItem:{title:"Nacos Data Synchronization Source Code Analysis",permalink:"/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync"}},s=[{value:"1. Http Long Polling",id:"1-http-long-polling",children:[]},{value:"2. Gateway Data Sync",id:"2-gateway-data-sync",children:[]},{value:"3. Admin Data Sync",id:"3-admin-data-sync",children:[]},{value:"4. Summary",id:"4-summary",children:[]}],p={toc:s};function c(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/index"},"Apache ShenYu")," is an asynchronous, high-performance, cross-language, responsive API gateway.")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for ",(0,i.kt)("inlineCode",{parentName:"p"},"ZooKeeper"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"WebSocket"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"http long poll"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Nacos"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Consul"),". The main content of this article is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"http long poll")," data synchronization source code analysis."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This paper based on ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu-2.5.0")," version of the source code analysis, the official website of the introduction of please refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/design/data-sync/"},"Data Synchronization Design")," .")),(0,i.kt)("h3",{id:"1-http-long-polling"},"1. Http Long Polling"),(0,i.kt)("p",null,"Here is a direct quote from the official website with the relevant description."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The mechanism of ",(0,i.kt)("inlineCode",{parentName:"p"},"Zookeeper")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"WebSocket")," data synchronization is relatively simple, while ",(0,i.kt)("inlineCode",{parentName:"p"},"Http long polling")," is more complex. ",(0,i.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," borrowed the design ideas of ",(0,i.kt)("inlineCode",{parentName:"p"},"Apollo")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Nacos"),", took their essence, and implemented ",(0,i.kt)("inlineCode",{parentName:"p"},"Http long polling")," data synchronization function by itself. Note that this is not the traditional ",(0,i.kt)("inlineCode",{parentName:"p"},"ajax")," long polling!")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(14064).Z})),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Http Long Polling")," mechanism as shown above, ",(0,i.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," gateway active request ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," configuration service, read timeout time is ",(0,i.kt)("inlineCode",{parentName:"p"},"90s"),", means that the gateway layer request configuration service will wait at most ",(0,i.kt)("inlineCode",{parentName:"p"},"90s"),", so as to facilitate ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," configuration service timely response to change data, so as to achieve quasi real-time push."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Http long polling")," mechanism is initiated by the gateway requesting ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),", so for this source code analysis, we start from the gateway side."),(0,i.kt)("h3",{id:"2-gateway-data-sync"},"2. Gateway Data Sync"),(0,i.kt)("h4",{id:"21-load-configuration"},"2.1 Load Configuration"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Http long polling")," data synchronization configuration is loaded through ",(0,i.kt)("inlineCode",{parentName:"p"},"spring boot starter")," mechanism when we introduce the relevant dependencies and have the following configuration in the configuration file."),(0,i.kt)("p",null,"Introduce dependencies in the ",(0,i.kt)("inlineCode",{parentName:"p"},"pom")," file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-xml"},"\x3c!--shenyu data sync start use http--\x3e\n<dependency>\n    <groupId>org.apache.shenyu</groupId>\n    <artifactId>shenyu-spring-boot-starter-sync-data-http</artifactId>\n    <version>${project.version}</version>\n</dependency>\n")),(0,i.kt)("p",null,"Add the following configuration to the ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml")," configuration file."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n    sync:\n       http:\n          url : http://localhost:9095\n")),(0,i.kt)("p",null,"When the gateway is started, the configuration class ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpSyncDataConfiguration")," is executed, loading the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"Bean"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * Http sync data configuration for spring boot.\n */\n@Configuration\n@ConditionalOnClass(HttpSyncDataService.class)\n@ConditionalOnProperty(prefix = "shenyu.sync.http", name = "url")\n@EnableConfigurationProperties(value = HttpConfig.class)\npublic class HttpSyncDataConfiguration {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpSyncDataConfiguration.class);\n\n    /**\n     * Rest template.\n     *\n     * @param httpConfig the http config\n     * @return the rest template\n     */\n    @Bean\n    public RestTemplate restTemplate(final HttpConfig httpConfig) {\n        OkHttp3ClientHttpRequestFactory factory = new OkHttp3ClientHttpRequestFactory();\n        factory.setConnectTimeout(Objects.isNull(httpConfig.getConnectionTimeout()) ? (int) HttpConstants.CLIENT_POLLING_CONNECT_TIMEOUT : httpConfig.getConnectionTimeout());\n        factory.setReadTimeout(Objects.isNull(httpConfig.getReadTimeout()) ? (int) HttpConstants.CLIENT_POLLING_READ_TIMEOUT : httpConfig.getReadTimeout());\n        factory.setWriteTimeout(Objects.isNull(httpConfig.getWriteTimeout()) ? (int) HttpConstants.CLIENT_POLLING_WRITE_TIMEOUT : httpConfig.getWriteTimeout());\n        return new RestTemplate(factory);\n    }\n\n    /**\n     * AccessTokenManager.\n     *\n     * @param httpConfig   the http config.\n     * @param restTemplate the rest template.\n     * @return the access token manager.\n     */\n    @Bean\n    public AccessTokenManager accessTokenManager(final HttpConfig httpConfig, final RestTemplate restTemplate) {\n        return new AccessTokenManager(restTemplate, httpConfig);\n    }\n\n    /**\n     * Http sync data service.\n     *\n     * @param httpConfig         the http config\n     * @param pluginSubscriber   the plugin subscriber\n     * @param restTemplate       the rest template\n     * @param metaSubscribers    the meta subscribers\n     * @param authSubscribers    the auth subscribers\n     * @param accessTokenManager the access token manager\n     * @return the sync data service\n     */\n    @Bean\n    public SyncDataService httpSyncDataService(final ObjectProvider<HttpConfig> httpConfig,\n                                               final ObjectProvider<PluginDataSubscriber> pluginSubscriber,\n                                               final ObjectProvider<RestTemplate> restTemplate,\n                                               final ObjectProvider<List<MetaDataSubscriber>> metaSubscribers,\n                                               final ObjectProvider<List<AuthDataSubscriber>> authSubscribers,\n                                               final ObjectProvider<AccessTokenManager> accessTokenManager) {\n        LOGGER.info("you use http long pull sync shenyu data");\n        return new HttpSyncDataService(\n                Objects.requireNonNull(httpConfig.getIfAvailable()),\n                Objects.requireNonNull(pluginSubscriber.getIfAvailable()),\n                Objects.requireNonNull(restTemplate.getIfAvailable()),\n                metaSubscribers.getIfAvailable(Collections::emptyList),\n                authSubscribers.getIfAvailable(Collections::emptyList),\n                Objects.requireNonNull(accessTokenManager.getIfAvailable())\n        );\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"HttpSyncDataConfiguration")," is the configuration class for ",(0,i.kt)("inlineCode",{parentName:"p"},"Http long polling")," data synchronization, responsible for creating ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpSyncDataService")," (responsible for the concrete implementation of ",(0,i.kt)("inlineCode",{parentName:"p"},"http")," data synchronization) \u3001 ",(0,i.kt)("inlineCode",{parentName:"p"},"RestTemplate")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"AccessTokenManager")," (responsible for the access token processing). It is annotated as follows."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@Configuration"),": indicates that this is a configuration class."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@ConditionalOnClass(HttpSyncDataService.class)"),": conditional annotation indicating that the class ",(0,i.kt)("inlineCode",{parentName:"li"},"HttpSyncDataService")," is to be present."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},'@ConditionalOnProperty(prefix = "shenyu.sync.http", name = "url")'),": conditional annotation to have the property ",(0,i.kt)("inlineCode",{parentName:"li"},"shenyu.sync.http.url")," configured."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"@EnableConfigurationProperties(value = HttpConfig.class)"),": indicates that the annotation ",(0,i.kt)("inlineCode",{parentName:"li"},'@ConfigurationProperties(prefix = "shenyu.sync.http")')," on ",(0,i.kt)("inlineCode",{parentName:"li"},"HttpConfig")," will take effect, and the configuration class ",(0,i.kt)("inlineCode",{parentName:"li"},"HttpConfig")," will be injected into the Ioc container.")),(0,i.kt)("h4",{id:"22-property-initialization"},"2.2 Property initialization"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService")),(0,i.kt)("p",null,"In the constructor of ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpSyncDataService"),", complete the property initialization."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // omitted attribute field ......\n\n    public HttpSyncDataService(final HttpConfig httpConfig,\n                               final PluginDataSubscriber pluginDataSubscriber,\n                               final RestTemplate restTemplate,\n                               final List<MetaDataSubscriber> metaDataSubscribers,\n                               final List<AuthDataSubscriber> authDataSubscribers,\n                               final AccessTokenManager accessTokenManager) {\n          // 1. accessTokenManager\n          this.accessTokenManager = accessTokenManager;\n          // 2. create data refresh factory\n          this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\n          // 3. shenyu-admin url\n          this.serverList = Lists.newArrayList(Splitter.on(",").split(httpConfig.getUrl()));\n          // 4. restTemplate\n          this.restTemplate = restTemplate;\n          // 5. start a long polling task\n          this.start();\n    }\n\n    //......\n}\n')),(0,i.kt)("p",null,"Other functions and related fields are omitted from the above code, and the initialization of the properties is done in the constructor, mainly."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"the role of ",(0,i.kt)("inlineCode",{parentName:"p"},"accessTokenManager")," is to request ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," and update the ",(0,i.kt)("inlineCode",{parentName:"p"},"access token")," regularly.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"creating data processors for subsequent caching of various types of data (plugins, selectors, rules, metadata and authentication data).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"obtaining the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," property configuration, mainly to obtain the ",(0,i.kt)("inlineCode",{parentName:"p"},"url")," of the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," with possible clusters, multiple split by a comma ",(0,i.kt)("inlineCode",{parentName:"p"},"(,)"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"using ",(0,i.kt)("inlineCode",{parentName:"p"},"RestTemplate"),", for launching requests to ",(0,i.kt)("inlineCode",{parentName:"p"},"admin"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Start the long polling task."))),(0,i.kt)("h4",{id:"23-start-the-long-polling-task"},"2.3 Start the long polling task."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService#start()")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"start()")," method, two things are done, one is to get the full amount of data, that is, to request the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side to get all the data that needs to be synchronized, and then cache the acquired data into the gateway memory. The other is to open a multi-threaded execution of a long polling task."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // ......\n\n    private void start() {\n        // It could be initialized multiple times, so you need to control that.\n        if (RUNNING.compareAndSet(false, true)) {\n            // fetch all group configs.\n            // Initial startup, get full data\n            this.fetchGroupConfig(ConfigGroupEnum.values());\n            // one backend service, one thread\n            int threadSize = serverList.size();\n            // ThreadPoolExecutor\n            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,\n                    new LinkedBlockingQueue<>(),\n                    ShenyuThreadFactory.create("http-long-polling", true));\n            // start long polling, each server creates a thread to listen for changes.\n            this.serverList.forEach(server -> this.executor.execute(new HttpLongPollingTask(server)));\n        } else {\n            LOG.info("shenyu http long polling was started, executor=[{}]", executor);\n        }\n    }\n\n    // ......\n}\n')),(0,i.kt)("h5",{id:"231-fetch-data"},"2.3.1 Fetch Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService#fetchGroupConfig()")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," groups all the data that needs to be synchronized, there are 5 data types, namely plugins, selectors, rules, metadata and authentication data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public enum ConfigGroupEnum {\n    APP_AUTH, // app auth data\n    PLUGIN, // plugin data\n    RULE, // rule data\n    SELECTOR, // selector data\n    META_DATA; // meta data\n}\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," may be a cluster, and here a request is made to each ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," in a round-robin fashion, and if one succeeds, then the operation to get the full amount of data from the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," and cache it to the gateway is executed successfully. If there is an exception, the request is launched to the next ",(0,i.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // ......\n\n    private void fetchGroupConfig(final ConfigGroupEnum... groups) throws ShenyuException {\n        // It is possible that admins are clustered, and here requests are made to each admin by means of a loop.\n        for (int index = 0; index < this.serverList.size(); index++) {\n            String server = serverList.get(index);\n            try {\n                // do execute\n                this.doFetchGroupConfig(server, groups);\n                // If you have a success, you are successful and can exit the loop\n                break;\n            } catch (ShenyuException e) {\n                // An exception occurs, try executing the next\n                // The last one also failed to execute, throwing an exception\n                // no available server, throw exception.\n                if (index >= serverList.size() - 1) {\n                    throw e;\n                }\n                LOG.warn("fetch config fail, try another one: {}", serverList.get(index + 1));\n            }\n        }\n    }\n\n    // ......\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService#doFetchGroupConfig()")),(0,i.kt)("p",null,"In this method, the request parameters are first assembled, then the request is launched through ",(0,i.kt)("inlineCode",{parentName:"p"},"httpClient")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," to get the data, and finally the obtained data is updated to the gateway memory."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // ......\n\n    // Launch a request to the admin backend management system to get all synchronized data\n    private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {\n        // 1. build request parameters, all grouped enumeration types\n        StringBuilder params = new StringBuilder();\n        for (ConfigGroupEnum groupKey : groups) {\n            params.append("groupKeys").append("=").append(groupKey.name()).append("&");\n        }\n        // admin url:  /configs/fetch\n        String url = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_FETCH + "?" + StringUtils.removeEnd(params.toString(), "&");\n        LOG.info("request configs: [{}]", url);\n        String json;\n        try {\n            HttpHeaders headers = new HttpHeaders();\n            // set accessToken\n            headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());\n            HttpEntity<String> httpEntity = new HttpEntity<>(headers);\n            // 2. get a request for change data\n            json = this.restTemplate.exchange(url, HttpMethod.GET, httpEntity, String.class).getBody();\n        } catch (RestClientException e) {\n            String message = String.format("fetch config fail from server[%s], %s", url, e.getMessage());\n            LOG.warn(message);\n            throw new ShenyuException(message, e);\n        }\n        // update local cache\n        // 3. Update data in gateway memory\n        boolean updated = this.updateCacheWithJson(json);\n        if (updated) {\n            LOG.debug("get latest configs: [{}]", json);\n            return;\n        }\n        // not updated. it is likely that the current config server has not been updated yet. wait a moment.\n        LOG.info("The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.", server);\n        // No data update on the server side, just wait 30s\n        ThreadUtils.sleep(TimeUnit.SECONDS, 30);\n    }\n\n    // ......\n}\n')),(0,i.kt)("p",null,"From the code, we can see that the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side provides the interface to get the full amount of data is ",(0,i.kt)("inlineCode",{parentName:"p"},"/configs/fetch"),", so we will not go further here and put it in the later analysis."),(0,i.kt)("p",null,"If you get the result data from ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," and update it successfully, then this method is finished. If there is no successful update, then it is possible that there is no data update on the server side, so wait ",(0,i.kt)("inlineCode",{parentName:"p"},"30s"),"."),(0,i.kt)("p",null,"Here you need to explain in advance, the gateway in determining whether the update is successful, there is a comparison of the data operation, immediately mentioned."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService#updateCacheWithJson()")),(0,i.kt)("p",null,"Update the data in the gateway memory. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"GSON")," for deserialization, take the real data from the property ",(0,i.kt)("inlineCode",{parentName:"p"},"data")," and give it to ",(0,i.kt)("inlineCode",{parentName:"p"},"DataRefreshFactory")," to do the update."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // ......\n\n    private boolean updateCacheWithJson(final String json) {\n        // Using GSON for deserialization\n        JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);\n        // if the config cache will be updated?\n        return factory.executor(jsonObject.getAsJsonObject("data"));\n    }\n\n    // ......\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DataRefreshFactory#executor()")),(0,i.kt)("p",null,"Update the data according to different data types and return the updated result. The specific update logic is given to the ",(0,i.kt)("inlineCode",{parentName:"p"},"dataRefresh.refresh()")," method. In the update result, one of the data types is updated, which means that the operation has been updated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public final class DataRefreshFactory {\n    \n    // ......\n    \n    public boolean executor(final JsonObject data) {\n        // update data\n        List<Boolean> result = ENUM_MAP.values().parallelStream()\n                .map(dataRefresh -> dataRefresh.refresh(data))\n                .collect(Collectors.toList());\n        // one of the data types is updated, which means that the operation has been updated.\n        return result.stream().anyMatch(Boolean.TRUE::equals);\n    }\n    \n    // ......\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"AbstractDataRefresh#refresh()")),(0,i.kt)("p",null,"The data update logic uses the template method design pattern, where the generic operation is done in the abstract method and the different implementation logic is done by subclasses. 5 data types have some differences in the specific update logic, but there is also a common update logic, and the class diagram relationship is as follows."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(18726).Z})),(0,i.kt)("p",null,"In the generic ",(0,i.kt)("inlineCode",{parentName:"p"},"refresh()")," method, it is responsible for data type conversion, determining whether an update is needed, and the actual data refresh operation."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class AbstractDataRefresh<T> implements DataRefresh {\n\n    // ......\n\n    @Override\n    public Boolean refresh(final JsonObject data) {\n        // convert data\n        JsonObject jsonObject = convert(data);\n        if (Objects.isNull(jsonObject)) {\n            return false;\n        }\n\n        boolean updated = false;\n        // get data\n        ConfigData<T> result = fromJson(jsonObject);\n        // does it need to be updated\n        if (this.updateCacheIfNeed(result)) {\n            updated = true;\n            // real update logic, data refresh operation\n            refresh(result.getData());\n        }\n\n        return updated;\n    }\n\n    // ......\n}\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"AbstractDataRefresh#updateCacheIfNeed()")),(0,i.kt)("p",null,"The process of data conversion, which is based on different data types, we will not trace further to see if the data needs to be updated logically. The method name is ",(0,i.kt)("inlineCode",{parentName:"p"},"updateCacheIfNeed()"),", which is implemented by method overloading."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public abstract class AbstractDataRefresh<T> implements DataRefresh {\n\n    // ......\n\n    // result is data\n    protected abstract boolean updateCacheIfNeed(ConfigData<T> result);\n\n    // newVal is the latest value obtained\n    // What kind of data type is groupEnum\n    protected boolean updateCacheIfNeed(final ConfigData<T> newVal, final ConfigGroupEnum groupEnum) {\n        // If it is the first time, then it is put directly into the cache and returns true, indicating that the update was made this time\n        if (GROUP_CACHE.putIfAbsent(groupEnum, newVal) == null) {\n            return true;\n        }\n        ResultHolder holder = new ResultHolder(false);\n        GROUP_CACHE.merge(groupEnum, newVal, (oldVal, value) -> {\n            // md5 value is the same, no need to update\n            if (StringUtils.equals(oldVal.getMd5(), newVal.getMd5())) {\n                LOG.info("Get the same config, the [{}] config cache will not be updated, md5:{}", groupEnum, oldVal.getMd5());\n                return oldVal;\n            }\n\n            // The current cached data has been modified for a longer period than the new data and does not need to be updated.\n            // must compare the last update time\n            if (oldVal.getLastModifyTime() >= newVal.getLastModifyTime()) {\n                LOG.info("Last update time earlier than the current configuration, the [{}] config cache will not be updated", groupEnum);\n                return oldVal;\n            }\n            LOG.info("update {} config: {}", groupEnum, newVal);\n            holder.result = true;\n            return newVal;\n        });\n        return holder.result;\n    }\n\n    // ......\n}\n')),(0,i.kt)("p",null,"As you can see from the source code above, there are two cases where updates are not required."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"md5")," values of both data are the same, so no update is needed;"),(0,i.kt)("li",{parentName:"ul"},"The current cached data has been modified longer than the new data, so no update is needed.")),(0,i.kt)("p",null,"In other cases, the data needs to be updated."),(0,i.kt)("p",null,"At this point, we have finished analyzing the logic of the ",(0,i.kt)("inlineCode",{parentName:"p"},"start()")," method to get the full amount of data for the first time, followed by the long polling operation. For convenience, I will paste the ",(0,i.kt)("inlineCode",{parentName:"p"},"start()")," method once more."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n\n    // ......\n\n    private void start() {\n        // It could be initialized multiple times, so you need to control that.\n        if (RUNNING.compareAndSet(false, true)) {\n            // fetch all group configs.\n            // Initial startup, get full data\n            this.fetchGroupConfig(ConfigGroupEnum.values());\n            // one backend service, one thread\n            int threadSize = serverList.size();\n            // ThreadPoolExecutor\n            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,\n                    new LinkedBlockingQueue<>(),\n                    ShenyuThreadFactory.create("http-long-polling", true));\n            // start long polling, each server creates a thread to listen for changes.\n            this.serverList.forEach(server -> this.executor.execute(new HttpLongPollingTask(server)));\n        } else {\n            LOG.info("shenyu http long polling was started, executor=[{}]", executor);\n        }\n    }\n\n    // ......\n}\n')),(0,i.kt)("h5",{id:"232-execute-long-polling-task"},"2.3.2 Execute Long Polling Task"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpLongPollingTask#run()")),(0,i.kt)("p",null,"The long polling task is ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpLongPollingTask"),", which implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"Runnable")," interface and the task logic is in the ",(0,i.kt)("inlineCode",{parentName:"p"},"run()")," method. The task is executed continuously through a ",(0,i.kt)("inlineCode",{parentName:"p"},"while()")," loop, i.e., long polling. There are three retries in each polling logic, one polling task fails, wait ",(0,i.kt)("inlineCode",{parentName:"p"},"5s")," and continue, ",(0,i.kt)("inlineCode",{parentName:"p"},"3")," times all fail, wait ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," minutes and try again."),(0,i.kt)("p",null,"Start long polling, an ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," service, and create a thread for data synchronization."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class HttpLongPollingTask implements Runnable {\n\n    private final String server;\n\n    HttpLongPollingTask(final String server) {\n        this.server = server;\n    }\n\n    @Override\n    public void run() {\n        // long polling\n        while (RUNNING.get()) {\n            // Default retry 3 times\n            int retryTimes = 3;\n            for (int time = 1; time <= retryTimes; time++) {\n                try {\n                    doLongPolling(server);\n                } catch (Exception e) {\n                    if (time < retryTimes) {\n                        LOG.warn("Long polling failed, tried {} times, {} times left, will be suspended for a while! {}",\n                                time, retryTimes - time, e.getMessage());\n                        // long polling failed, wait 5s and continue\n                        ThreadUtils.sleep(TimeUnit.SECONDS, 5);\n                        continue;\n                    }\n                    // print error, then suspended for a while.\n                    LOG.error("Long polling failed, try again after 5 minutes!", e);\n                    // 3 \u6b21\u90fd\u5931\u8d25\u4e86\uff0c\u7b49 5 \u5206\u949f\u518d\u8bd5\n                    ThreadUtils.sleep(TimeUnit.MINUTES, 5);\n                }\n            }\n        }\n        LOG.warn("Stop http long polling.");\n    }\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpSyncDataService#doLongPolling()")),(0,i.kt)("p",null,"Core logic for performing long polling tasks."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Assembling request parameters based on data types: ",(0,i.kt)("inlineCode",{parentName:"li"},"md5")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"lastModifyTime"),"."),(0,i.kt)("li",{parentName:"ul"},"Assembling the request header and request body."),(0,i.kt)("li",{parentName:"ul"},"Launching a request to ",(0,i.kt)("inlineCode",{parentName:"li"},"admin")," to determine if the group data has changed."),(0,i.kt)("li",{parentName:"ul"},"Based on the group that has changed, go back and get the data.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpSyncDataService implements SyncDataService {\n    private void doLongPolling(final String server) {\n        // build request params: md5 and lastModifyTime\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>(8);\n        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {\n            ConfigData<?> cacheConfig = factory.cacheConfigData(group);\n            if (cacheConfig != null) {\n                String value = String.join(",", cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));\n                params.put(group.name(), Lists.newArrayList(value));\n            }\n        }\n        // build request head and body\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        // set accessToken\n        headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());\n        HttpEntity<MultiValueMap<String, String>> httpEntity = new HttpEntity<>(params, headers);\n        String listenerUrl = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_LISTENER;\n\n        JsonArray groupJson;\n        //Initiate a request to admin to determine if the group data has changed\n        //Here it just determines whether a group has changed or not\n        try {\n            String json = this.restTemplate.postForEntity(listenerUrl, httpEntity, String.class).getBody();\n            LOG.info("listener result: [{}]", json);\n            JsonObject responseFromServer = GsonUtils.getGson().fromJson(json, JsonObject.class);\n            groupJson = responseFromServer.getAsJsonArray("data");\n        } catch (RestClientException e) {\n            String message = String.format("listener configs fail, server:[%s], %s", server, e.getMessage());\n            throw new ShenyuException(message, e);\n        }\n        // Depending on the group where the change occurred, go back and get the data\n        /**\n         * The official website explains here.\n         * After the gateway receives the response message, it only knows which Group has made the configuration change, and it still needs to request the configuration data of that Group again.\n         * There may be a question here: why not write out the changed data directly?\n         * We also discussed this issue in depth during development, because the http long polling mechanism can only guarantee quasi-real time, if the processing at the gateway layer is not timely, * or the administrator frequently updates the configuration, it is very difficult to get the information from the gateway layer.\n         * If it is not processed in time at the gateway level, or if the administrator updates the configuration frequently, it is very likely to miss the push of a configuration change, so for security reasons, we only inform a group that the information has changed.\n         *For security reasons, we only notify a group of changes.\n         * Personal understanding.\n         * If the change data is written out directly, when the administrator frequently updates the configuration, the first update will remove the client from the blocking queue and return the response information to the gateway.\n         * If a second update is made at this time, the current client is not in the blocking queue, so this time the change is missed.\n         * The same is true for untimely processing by the gateway layer.\n         * This is a long polling, one gateway one synchronization thread, there may be time consuming process.\n         * If the admin has data changes, the current gateway client is not in the blocking queue and will not get the data.\n         */\n        if (groupJson != null) {\n            // fetch group configuration async.\n            ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);\n            if (ArrayUtils.isNotEmpty(changedGroups)) {\n                log.info("Group config changed: {}", Arrays.toString(changedGroups));\n                // Proactively get the changed data from admin, depending on the grouping, and take the data in full\n                this.doFetchGroupConfig(server, changedGroups);\n            }\n        }\n        if (Objects.nonNull(groupJson) && groupJson.size() > 0) {\n            // fetch group configuration async.\n            ConfigGroupEnum[] changedGroups = GsonUtils.getGson().fromJson(groupJson, ConfigGroupEnum[].class);\n            LOG.info("Group config changed: {}", Arrays.toString(changedGroups));\n            // Proactively get the changed data from admin, depending on the grouping, and take the data in full\n            this.doFetchGroupConfig(server, changedGroups);\n        }\n    }\n}\n')),(0,i.kt)("p",null,"One special point needs to be explained here: In the long polling task, why don't you get the changed data directly? Instead, we determine which group data has been changed, and then request ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," again to get the changed data?"),(0,i.kt)("p",null,"The official explanation here is."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"After the gateway receives the response information, it only knows which Group has changed its configuration, and it needs to request the configuration data of that Group again.\nThere may be a question here: Why not write out the changed data directly?\nWe have discussed this issue in depth during development, because the ",(0,i.kt)("inlineCode",{parentName:"p"},"http")," long polling mechanism can only guarantee quasi-real time, and if it is not processed in time at the gateway layer, it will be very difficult to update the configuration data.\nIf the gateway layer is not processed in time, or the administrator updates the configuration frequently, it is likely to miss the push of a configuration change, so for security reasons, we only inform a group that the information has changed.")),(0,i.kt)("p",null,"My personal understanding is that."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If the change data is written out directly, when the administrator updates the configuration frequently, the first update will remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," from blocking queue and return the response information to the gateway. If a second update is made at this time, then the current ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," is not in the blocking queue, so this time the change is missed. The same is true for the gateway layer's untimely processing. This is a long polling, one gateway one synchronization thread, there may be a time-consuming process. If ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," has data changes, the current gateway client is not in the blocking queue and will not get the data.")),(0,i.kt)("p",null,"We have not yet analyzed the processing logic of the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side, so let's talk about it roughly. At the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," end, the gateway ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," will be put into the blocking queue, and when there is a data change, the gateway ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," will come out of the queue and send the change data. So, if the gateway ",(0,i.kt)("inlineCode",{parentName:"p"},"client")," is not in the blocking queue when there is a data change, then the current changed data is not available."),(0,i.kt)("p",null,"When we know which grouping data has changed, we actively get the changed data from ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," again, and get the data in full depending on the grouping. The call method is ",(0,i.kt)("inlineCode",{parentName:"p"},"doFetchGroupConfig()"),", which has been analyzed in the previous section."),(0,i.kt)("p",null,"At this point of analysis, the data synchronization operation on the gateway side is complete. The long polling task is to keep making requests to ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," to see if the data has changed, and if any group data has changed, then initiate another request to ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," to get the changed data, and then update the data in the gateway's memory."),(0,i.kt)("p",null,"Long polling task flow at the gateway side."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(60305).Z})),(0,i.kt)("h3",{id:"3-admin-data-sync"},"3. Admin Data Sync"),(0,i.kt)("p",null,"From the previous analysis, it can be seen that the gateway side mainly calls two interfaces of ",(0,i.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/listener"),": determine whether the group data has changed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/fetch"),": get the changed group data.")),(0,i.kt)("p",null,"If we analyze directly from these two interfaces, some parts may not be well understood, so let's start analyzing the data synchronization process from the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," startup process."),(0,i.kt)("h4",{id:"31-load-configuration"},"3.1 Load Configuration"),(0,i.kt)("p",null,"If the following configuration is done in the configuration file ",(0,i.kt)("inlineCode",{parentName:"p"},"application.yml"),", it means that the data synchronization is done by ",(0,i.kt)("inlineCode",{parentName:"p"},"http long polling"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n  sync:\n      http:\n        enabled: true\n")),(0,i.kt)("p",null,"When the program starts, the configuration of the data synchronization class is loaded through ",(0,i.kt)("inlineCode",{parentName:"p"},"springboot")," conditional assembly. In this process, ",(0,i.kt)("inlineCode",{parentName:"p"},"HttpLongPollingDataChangedListener")," is created to handle the implementation logic related to long polling."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * Data synchronization configuration class\n * Conditional assembly via springboot\n * The type Data sync configuration.\n */\n@Configuration\npublic class DataSyncConfiguration {\n\n    /**\n     * http long polling.\n     */\n    @Configuration\n    @ConditionalOnProperty(name = "shenyu.sync.http.enabled", havingValue = "true")\n    @EnableConfigurationProperties(HttpSyncProperties.class)\n    static class HttpLongPollingListener {\n\n        @Bean\n        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)\n        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {\n            return new HttpLongPollingDataChangedListener(httpSyncProperties);\n        }\n    }\n}\n')),(0,i.kt)("h4",{id:"32-data-change-listener-instantiation"},"3.2 Data change listener instantiation"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpLongPollingDataChangedListener")),(0,i.kt)("p",null,"The data change listener is instantiated and initialized by means of a constructor. In the constructor, a blocking queue is created to hold clients, a thread pool is created to execute deferred tasks and periodic tasks, and information about the properties of long polling is stored."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'    public HttpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {\n        // default client (here is the gateway) 1024\n        this.clients = new ArrayBlockingQueue<>(1024);\n        // create thread pool\n        // ScheduledThreadPoolExecutor can perform delayed tasks, periodic tasks, and normal tasks\n        this.scheduler = new ScheduledThreadPoolExecutor(1,\n                ShenyuThreadFactory.create("long-polling", true));\n        // http sync properties\n        this.httpSyncProperties = httpSyncProperties;\n    }\n')),(0,i.kt)("p",null,"In addition, it has the following class diagram relationships."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(8841).Z})),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"InitializingBean")," interface is implemented, so the ",(0,i.kt)("inlineCode",{parentName:"p"},"afterInitialize()")," method is executed during the initialization of the ",(0,i.kt)("inlineCode",{parentName:"p"},"bean"),". Execute periodic tasks via thread pool: updating the data in memory ",(0,i.kt)("inlineCode",{parentName:"p"},"(CACHE)")," is executed every ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," minutes and starts after ",(0,i.kt)("inlineCode",{parentName:"p"},"5")," minutes. Refreshing the local cache is reading data from the database to the local cache (in this case the memory), done by ",(0,i.kt)("inlineCode",{parentName:"p"},"refreshLocalCache()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {\n\n    // ......\n\n    /**\n     * is called in the afterPropertiesSet() method of the InitializingBean interface, which is executed during the initialization of the bean\n     */\n    @Override\n    protected void afterInitialize() {\n        long syncInterval = httpSyncProperties.getRefreshInterval().toMillis();\n        // Periodically check the data for changes and update the cache\n\n        // Execution cycle task: Update data in memory (CACHE) is executed every 5 minutes and starts after 5 minutes\n        // Prevent the admin from starting up first for a while and then generating data; then the gateway doesn\'t get the full amount of data when it first connects\n        scheduler.scheduleWithFixedDelay(() -> {\n            LOG.info("http sync strategy refresh config start.");\n            try {\n                // Read data from database to local cache (in this case, memory)\n                this.refreshLocalCache();\n                LOG.info("http sync strategy refresh config success.");\n            } catch (Exception e) {\n                LOG.error("http sync strategy refresh config error!", e);\n            }\n        }, syncInterval, syncInterval, TimeUnit.MILLISECONDS);\n        LOG.info("http sync strategy refresh interval: {}ms", syncInterval);\n    }\n\n    // ......\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"refreshLocalCache()")),(0,i.kt)("p",null,"Update for each of the 5 data types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\n\n    // ......\n\n    // Read data from database to local cache (in this case, memory)\n    private void refreshLocalCache() {\n        //update app auth data\n        this.updateAppAuthCache();\n        //update plugin data\n        this.updatePluginCache();\n        //update rule data\n        this.updateRuleCache();\n        //update selector data\n        this.updateSelectorCache();\n        //update meta data\n        this.updateMetaDataCache();\n    }\n\n    // ......\n}\n")),(0,i.kt)("p",null,"The logic of the 5 update methods is similar, call the ",(0,i.kt)("inlineCode",{parentName:"p"},"service")," method to get the data and put it into the memory ",(0,i.kt)("inlineCode",{parentName:"p"},"CACHE"),". Take the updateRuleData method ",(0,i.kt)("inlineCode",{parentName:"p"},"updateRuleCache()")," for example, pass in the rule enumeration type and call ",(0,i.kt)("inlineCode",{parentName:"p"},"ruleService.listAll()")," to get all the rule data from the database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    /**\n     * Update rule cache.\n     */\n    protected void updateRuleCache() {\n        this.updateCache(ConfigGroupEnum.RULE, ruleService.listAll());\n    }\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"updateCache()")),(0,i.kt)("p",null,"Update the data in memory using the data in the database."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\n\n    // ......\n\n    // cache Map\n    protected static final ConcurrentMap<String, ConfigDataCache> CACHE = new ConcurrentHashMap<>();\n\n    /**\n     * if md5 is not the same as the original, then update lcoal cache.\n     * @param group ConfigGroupEnum\n     * @param <T> the type of class\n     * @param data the new config data\n     */\n    protected <T> void updateCache(final ConfigGroupEnum group, final List<T> data) {\n        // data serialization\n        String json = GsonUtils.getInstance().toJson(data);\n        // pass in md5 value and modification time\n        ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());\n        // update group data\n        ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);\n        log.info("update config cache[{}], old: {}, updated: {}", group, oldVal, newVal);\n    }\n\n    // ......\n}\n')),(0,i.kt)("p",null,"The initialization process is to start periodic tasks to update the memory data by fetching data from the database at regular intervals."),(0,i.kt)("p",null,"Next, we start the analysis of two interfaces."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/listener"),": determines if the group data has changed."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/fetch"),": fetching the changed group data.")),(0,i.kt)("h4",{id:"33--data-change-polling-interface"},"3.3  Data change polling interface"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/listener"),": determines if the group data has changed.")),(0,i.kt)("p",null,"The interface class is ",(0,i.kt)("inlineCode",{parentName:"p"},"ConfigController"),", which only takes effect when using ",(0,i.kt)("inlineCode",{parentName:"p"},"http long polling")," for data synchronization. The interface method ",(0,i.kt)("inlineCode",{parentName:"p"},"listener()")," has no other logic and calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"doLongPolling()")," method directly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'   \n/**\n * This Controller only when HttpLongPollingDataChangedListener exist, will take effect.\n */\n@ConditionalOnBean(HttpLongPollingDataChangedListener.class)\n@RestController\n@RequestMapping("/configs")\npublic class ConfigController {\n\n    private final HttpLongPollingDataChangedListener longPollingListener;\n\n    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {\n        this.longPollingListener = longPollingListener;\n    }\n    \n    // Omit other logic\n\n    /**\n     * Listener.\n     * Listen for data changes and perform long polling\n     * @param request  the request\n     * @param response the response\n     */\n    @PostMapping(value = "/listener")\n    public void listener(final HttpServletRequest request, final HttpServletResponse response) {\n        longPollingListener.doLongPolling(request, response);\n    }\n\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpLongPollingDataChangedListener#doLongPolling()")),(0,i.kt)("p",null,"Perform long polling tasks: If there are data changes, they will be responded to the client (in this case, the gateway side) immediately. Otherwise, the client will be blocked until there is a data change or a timeout."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {\n\n    // ......\n\n    /**\n     * Execute long polling: If there is a data change, it will be responded to the client (here is the gateway side) immediately.\n     * Otherwise, the client will otherwise remain blocked until there is a data change or a timeout.\n     * @param request\n     * @param response\n     */\n    public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {\n        // compare group md5\n        // Compare the md5, determine whether the data of the gateway and the data of the admin side are consistent, and get the data group that has changed\n        List<ConfigGroupEnum> changedGroup = compareChangedGroup(request);\n        String clientIp = getRemoteIp(request);\n        // response immediately.\n        // Immediate response to the gateway if there is changed data\n        if (CollectionUtils.isNotEmpty(changedGroup)) {\n            this.generateResponse(response, changedGroup);\n            Log.info("send response with the changed group, ip={}, group={}", clientIp, changedGroup);\n            return;\n        }\n\n        // No change, then the client (in this case the gateway) is put into the blocking queue\n        // listen for configuration changed.\n        final AsyncContext asyncContext = request.startAsync();\n        // AsyncContext.settimeout() does not timeout properly, so you have to control it yourself\n        asyncContext.setTimeout(0L);\n        // block client\'s thread.\n        scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));\n    }\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpLongPollingDataChangedListener#compareChangedGroup()")),(0,i.kt)("p",null,"To determine whether the group data has changed, the judgment logic is to compare the ",(0,i.kt)("inlineCode",{parentName:"p"},"md5")," value and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastModifyTime")," at the gateway side and the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"md5")," value is different, then it needs to be updated."),(0,i.kt)("li",{parentName:"ul"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"lastModifyTime")," on the ",(0,i.kt)("inlineCode",{parentName:"li"},"admin")," side is greater than the ",(0,i.kt)("inlineCode",{parentName:"li"},"lastModifyTime")," on the gateway side, then it needs to be updated.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"}," /**\n     * Determine if the group data has changed\n     * @param request\n     * @return\n     */\n    private List<ConfigGroupEnum> compareChangedGroup(final HttpServletRequest request) {\n        List<ConfigGroupEnum> changedGroup = new ArrayList<>(ConfigGroupEnum.values().length);\n        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {\n            // The md5 value and lastModifyTime of the data on the gateway side\n            String[] params = StringUtils.split(request.getParameter(group.name()), ',');\n            if (params == null || params.length != 2) {\n                throw new ShenyuException(\"group param invalid:\" + request.getParameter(group.name()));\n            }\n            String clientMd5 = params[0];\n            long clientModifyTime = NumberUtils.toLong(params[1]);\n            ConfigDataCache serverCache = CACHE.get(group.name());\n            // do check. determine if the group data has changed\n            if (this.checkCacheDelayAndUpdate(serverCache, clientMd5, clientModifyTime)) {\n                changedGroup.add(group);\n            }\n        }\n        return changedGroup;\n    }\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"LongPollingClient")),(0,i.kt)("p",null,"No change data, then the client (in this case the gateway) is put into the blocking queue. The blocking time is 60 seconds, i.e. after 60 seconds remove and respond to the client."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class LongPollingClient implements Runnable {\n      // omitted other logic\n    \n        @Override\n        public void run() {\n            try {\n                // Removal after 60 seconds and response to the client\n                this.asyncTimeoutFuture = scheduler.schedule(() -> {\n                    clients.remove(LongPollingClient.this);\n                    List<ConfigGroupEnum> changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());\n                    sendResponse(changedGroups);\n                }, timeoutTime, TimeUnit.MILLISECONDS);\n\n                // Add to blocking queue\n                clients.add(this);\n\n            } catch (Exception ex) {\n                log.error("add long polling client error", ex);\n            }\n        }\n\n        /**\n         * Send response.\n         *\n         * @param changedGroups the changed groups\n         */\n        void sendResponse(final List<ConfigGroupEnum> changedGroups) {\n            // cancel scheduler\n            if (null != asyncTimeoutFuture) {\n                asyncTimeoutFuture.cancel(false);\n            }\n            // Groups responding to changes\n            generateResponse((HttpServletResponse) asyncContext.getResponse(), changedGroups);\n            asyncContext.complete();\n        }\n    }\n')),(0,i.kt)("h4",{id:"34--get-change-data-interface"},"3.4  Get Change Data Interface"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/fetch"),": get change data;")),(0,i.kt)("p",null,"Get the grouped data and return the result according to the parameters passed in by the gateway. The main implementation method is ",(0,i.kt)("inlineCode",{parentName:"p"},"longPollingListener.fetchConfig()"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'\n@ConditionalOnBean(HttpLongPollingDataChangedListener.class)\n@RestController\n@RequestMapping("/configs")\npublic class ConfigController {\n\n    private final HttpLongPollingDataChangedListener longPollingListener;\n\n    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {\n        this.longPollingListener = longPollingListener;\n    }\n\n    /**\n     * Fetch configs shenyu result.\n     * @param groupKeys the group keys\n     * @return the shenyu result\n     */\n    @GetMapping("/fetch")\n    public ShenyuAdminResult fetchConfigs(@NotNull final String[] groupKeys) {\n        Map<String, ConfigData<?>> result = Maps.newHashMap();\n        for (String groupKey : groupKeys) {\n            ConfigData<?> data = longPollingListener.fetchConfig(ConfigGroupEnum.valueOf(groupKey));\n            result.put(groupKey, data);\n        }\n        return ShenyuAdminResult.success(ShenyuResultMessage.SUCCESS, result);\n    }\n    \n  // Other interfaces are omitted\n\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"AbstractDataChangedListener#fetchConfig()")),(0,i.kt)("p",null,"Data fetching is taken directly from ",(0,i.kt)("inlineCode",{parentName:"p"},"CACHE"),", and then matched and encapsulated according to different grouping types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\n    \n    // ......\n    \n    /**\n     * fetch configuration from cache.\n     * @param groupKey the group key\n     * @return the configuration data\n     */\n    public ConfigData<?> fetchConfig(final ConfigGroupEnum groupKey) {\n        // get data from CACHE\n        ConfigDataCache config = CACHE.get(groupKey.name());\n        switch (groupKey) {\n            case APP_AUTH: // app auth data\n                return buildConfigData(config, AppAuthData.class);\n            case PLUGIN: // plugin data\n                return buildConfigData(config, PluginData.class);\n            case RULE:   // rule data\n                return buildConfigData(config, RuleData.class);\n            case SELECTOR:  // selector data\n                return buildConfigData(config, SelectorData.class);\n            case META_DATA: // meta data \n                return buildConfigData(config, MetaData.class);\n            default:  // other data type, throw exception\n                throw new IllegalStateException("Unexpected groupKey: " + groupKey);\n        }\n    }\n    \n    // ......\n}\n')),(0,i.kt)("h4",{id:"35-data-change"},"3.5 Data Change"),(0,i.kt)("p",null,"In the previous ",(0,i.kt)("inlineCode",{parentName:"p"},"websocket")," data synchronization and ",(0,i.kt)("inlineCode",{parentName:"p"},"zookeeper")," data synchronization source code analysis article, we know that the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side data synchronization design structure is as follows."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(17780).Z})),(0,i.kt)("p",null,"Various data change listeners are subclasses of ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedListener"),"."),(0,i.kt)("p",null,"When the data is modified on the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side, event notifications are sent through the ",(0,i.kt)("inlineCode",{parentName:"p"},"Spring")," event handling mechanism. The sending logic is as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * Event forwarders, which forward the changed events to each ConfigEventListener.\n * Data change event distributor: synchronize the change data to ShenYu gateway when there is a data change in admin side\n * Data changes rely on Spring\'s event-listening mechanism: ApplicationEventPublisher --\x3e ApplicationEvent --\x3e ApplicationListener\n *\n */\n@Component\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\n\n  // other logic omitted\n\n    /**\n     * Call this method when there are data changes\n     * @param event\n     */\n    @Override\n    @SuppressWarnings("unchecked")\n    public void onApplicationEvent(final DataChangedEvent event) {\n        // Iterate through the data change listeners (it\'s generally good to use a kind of data synchronization)\n        for (DataChangedListener listener : listeners) {\n            // What kind of data has changed\n            switch (event.getGroupKey()) {\n                case APP_AUTH: // app auth data\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\n                    break;\n                case PLUGIN:  // plugin data\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\n                    break;\n                case RULE:    // rule data\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\n                    break;\n                case SELECTOR:   // selector data\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\n                    // pull and save API document on seletor changed\n                    applicationContext.getBean(LoadServiceDocEntry.class).loadDocOnSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\n                    break;\n                case META_DATA:  // meta data\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\n                    break;\n                default:  // other data type, throw exception\n                    throw new IllegalStateException("Unexpected value: " + event.getGroupKey());\n            }\n        }\n    }\n}\n')),(0,i.kt)("p",null,"Suppose, the plugin information is modified and the data is synchronized by ",(0,i.kt)("inlineCode",{parentName:"p"},"http long polling"),", then the actual call to ",(0,i.kt)("inlineCode",{parentName:"p"},"listener.onPluginChanged()")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"org.apache.shenyu.admin.listener. AbstractDataChangedListener#onPluginChanged"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    /**\n     * In the operation of the admin, there is an update of the plugin occurred\n     * @param changed   the changed\n     * @param eventType the event type\n     */\n    @Override\n    public void onPluginChanged(final List<PluginData> changed, final DataEventTypeEnum eventType) {\n        if (CollectionUtils.isEmpty(changed)) {\n            return;\n        }\n        // update CACHE\n        this.updatePluginCache();\n        // execute change task\n        this.afterPluginChanged(changed, eventType);\n    }\n")),(0,i.kt)("p",null,"There are two processing operations, one is to update the memory ",(0,i.kt)("inlineCode",{parentName:"p"},"CACHE"),", which was analyzed earlier, and the other is to execute the change task, which is executed in the thread pool."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"HttpLongPollingDataChangedListener#afterPluginChanged()")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    @Override\n    protected void afterPluginChanged(final List<PluginData> changed, final DataEventTypeEnum eventType) {\n        // execute by thread pool\n        scheduler.execute(new DataChangeTask(ConfigGroupEnum.PLUGIN));\n    }\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DataChangeTask")),(0,i.kt)("p",null,"Data change task: remove the clients in the blocking queue in turn and send a response to notify the gateway that a group of data has changed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'class DataChangeTask implements Runnable {\n        //other logic omitted\n  \n        @Override\n        public void run() {\n            // If the client in the blocking queue exceeds the given value of 100, it is executed in batches\n            if (clients.size() > httpSyncProperties.getNotifyBatchSize()) {\n                List<LongPollingClient> targetClients = new ArrayList<>(clients.size());\n                clients.drainTo(targetClients);\n                List<List<LongPollingClient>> partitionClients = Lists.partition(targetClients, httpSyncProperties.getNotifyBatchSize());\n               // batch execution\n                partitionClients.forEach(item -> scheduler.execute(() -> doRun(item)));\n            } else {\n                // execute task\n                doRun(clients);\n            }\n        }\n\n        private void doRun(final Collection<LongPollingClient> clients) {\n            // Notify all clients that a data change has occurred\n            for (Iterator<LongPollingClient> iter = clients.iterator(); iter.hasNext();) {\n                LongPollingClient client = iter.next();\n                iter.remove();\n                // send response to client\n                client.sendResponse(Collections.singletonList(groupKey));\n                Log.info("send response with the changed group,ip={}, group={}, changeTime={}", client.ip, groupKey, changeTime);\n            }\n        }\n    }\n')),(0,i.kt)("p",null,"At this point, the data synchronization logic on the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side is analyzed. In the ",(0,i.kt)("inlineCode",{parentName:"p"},"http long polling")," based data synchronization is, it has three main functions."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"providing a data change listening interface."),(0,i.kt)("li",{parentName:"ul"},"providing the interface to get the changed data."),(0,i.kt)("li",{parentName:"ul"},"When there is a data change, remove the client in the blocking queue and respond to the result.")),(0,i.kt)("p",null,"Finally, three diagrams describe the long polling task flow on the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/listener")," data change listener interface.")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(24197).Z})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"/configs/fetch")," fetch change data interface.")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(16735).Z})),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Update data in the admin backend management system for data synchronization.")),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(46780).Z})),(0,i.kt)("h3",{id:"4-summary"},"4. Summary"),(0,i.kt)("p",null,"This article focuses on the source code analysis of ",(0,i.kt)("inlineCode",{parentName:"p"},"http long polling")," data synchronization in the ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," gateway. The main knowledge points involved are as follows."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"http long polling")," is initiated by the gateway side, which constantly requests the ",(0,i.kt)("inlineCode",{parentName:"li"},"admin")," side."),(0,i.kt)("li",{parentName:"ul"},"change data at group granularity (authentication information, plugins, selectors, rules, metadata)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"http long polling")," results in getting only the change group, and another request needs to be initiated to get the group data."),(0,i.kt)("li",{parentName:"ul"},"Whether the data is updated or not is determined by the ",(0,i.kt)("inlineCode",{parentName:"li"},"md5")," value and the modification time ",(0,i.kt)("inlineCode",{parentName:"li"},"lastModifyTime"),".")))}c.isMDXComponent=!0},17780:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/data-changed-listener-admin-2f384e703652e9e28db8447b1cbdaea7.png"},8841:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/data-changed-listener-1c8e4c0f4279cdb33b27c52cc933cac5.png"},18726:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/data-refresh-a5628c71ea221ffb0a7a45f4ed40ae0e.png"},46780:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/http-long-polling-admin-update-en-f0892e8f170561e4237d2d89b07a3bc5.png"},16735:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/http-long-polling-fetch-en-85412d758bccd904e0f798b12d0d19de.png"},24197:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/http-long-polling-listener-en-e979b81dc72024abd7ca3c2258bdaeec.png"},60305:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/http-long-polling-sequence-en-f767de4dee173a720d632db5c800e147.png"},14064:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/http-long-polling-en-6d21af33dd02e70f631cddca7aa9d387.png"}}]);