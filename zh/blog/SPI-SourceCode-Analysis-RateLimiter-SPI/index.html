<!doctype html>
<html lang="zh" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="alternate" type="application/rss+xml" href="/zh/blog/rss.xml" title="Apache ShenYu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/blog/atom.xml" title="Apache ShenYu Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Apache ShenYu" href="/zh/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/zh/news/rss.xml" title="Apache ShenYu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/news/atom.xml" title="Apache ShenYu Blog Atom Feed"><title data-react-helmet="true">RateLimiter SPI 代码分析 | Apache ShenYu</title><meta data-react-helmet="true" property="og:title" content="RateLimiter SPI 代码分析 | Apache ShenYu"><meta data-react-helmet="true" name="description" content="限流是网关必备的功能，用来应对高并发请求的场景。当系统受到异常攻击，短期内聚集了大量的流量；当有大量低级别的请求，处理这些请求会影响关键业务的处理，需要限制这些请求的访问速度; 或者系统内部出现一些异常，不能满负荷的服务整个应用请求等等。这些情况下，都需要启用限流来保护系统。可以拒绝服务、等待或降级处理，将流量限制到系统可接受的量，或者只允许某些域名(或某些业务)的请求优先处理。"><meta data-react-helmet="true" property="og:description" content="限流是网关必备的功能，用来应对高并发请求的场景。当系统受到异常攻击，短期内聚集了大量的流量；当有大量低级别的请求，处理这些请求会影响关键业务的处理，需要限制这些请求的访问速度; 或者系统内部出现一些异常，不能满负荷的服务整个应用请求等等。这些情况下，都需要启用限流来保护系统。可以拒绝服务、等待或降级处理，将流量限制到系统可接受的量，或者只允许某些域名(或某些业务)的请求优先处理。"><meta data-react-helmet="true" property="og:url" content="https://shenyu.apache.org//zh/blog/SPI-SourceCode-Analysis-RateLimiter-SPI"><meta data-react-helmet="true" name="docsearch:language" content="zh"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="default"><link data-react-helmet="true" rel="shortcut icon" href="/zh/img/favicon.svg"><link data-react-helmet="true" rel="canonical" href="https://shenyu.apache.org//zh/blog/SPI-SourceCode-Analysis-RateLimiter-SPI"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog/SPI-SourceCode-Analysis-RateLimiter-SPI" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//zh/blog/SPI-SourceCode-Analysis-RateLimiter-SPI" hreflang="zh"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog/SPI-SourceCode-Analysis-RateLimiter-SPI" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/zh/assets/css/styles.6bd5fa92.css">
<link rel="preload" href="/zh/assets/js/runtime~main.95e9cd12.js" as="script">
<link rel="preload" href="/zh/assets/js/main.7e9dd650.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh/"><img src="/zh/img/logo.svg" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/zh/img/logo-light.svg" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/zh/download">下载</a><a class="navbar__item navbar__link" href="/zh/document">文档</a><a class="navbar__item navbar__link" href="/zh/community/contributor-guide">社区</a><a class="navbar__item navbar__link" href="/zh/team">团队</a><a class="navbar__item navbar__link" href="/zh/event">事件</a><a class="navbar__item navbar__link" href="/zh/news">新闻</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh/blog">博客</a><a class="navbar__item navbar__link" href="/zh/users">用户</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/policies/privacy.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div><a href="https://github.com/apache/shenyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__item navbar__link"><span><svg t="1631348384596" class="icon" viewBox="0 0 1024 1024" version="1.1" style="vertical-align:text-bottom;margin-right:5px" p-id="557" width="20" height="20"><path d="M547.797333 638.208l-104.405333-103.168 1.237333-1.28a720.170667 720.170667 0 0 0 152.490667-268.373333h120.448V183.082667h-287.744V100.906667H347.605333v82.218666H59.818667V265.386667h459.178666a648.234667 648.234667 0 0 1-130.304 219.946666 643.242667 643.242667 0 0 1-94.976-137.728H211.541333a722.048 722.048 0 0 0 122.453334 187.434667l-209.194667 206.378667 58.368 58.368 205.525333-205.525334 127.872 127.829334 31.232-83.84m231.424-208.426667h-82.218666l-184.96 493.312h82.218666l46.037334-123.306667h195.242666l46.464 123.306667h82.218667l-185.002667-493.312m-107.690666 287.744l66.56-178.005333 66.602666 178.005333z" fill="currentColor" p-id="558"></path></svg><span>简体中文</span></span></a><ul class="dropdown__menu"><li><a href="/blog/SPI-SourceCode-Analysis-RateLimiter-SPI" target="_self" rel="noopener noreferrer" class="dropdown__link" style="text-transform:capitalize">English</a></li><li><a href="/zh/blog/SPI-SourceCode-Analysis-RateLimiter-SPI" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" style="text-transform:capitalize">简体中文</a></li></ul></div><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_Bc3W"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-post-page"><div class="container margin-vert--lg"><div class="row"><main class="col col--9 col--offset-1"><article><header><h1 class="blogPostTitle_d4p0">RateLimiter SPI 代码分析</h1><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2024-01-06T12:12:51.742Z">2024年1月6日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/changanjennifer/" target="_blank" rel="noopener noreferrer">Huihui Yin</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><p>限流是网关必备的功能，用来应对高并发请求的场景。当系统受到异常攻击，短期内聚集了大量的流量；当有大量低级别的请求，处理这些请求会影响关键业务的处理，需要限制这些请求的访问速度; 或者系统内部出现一些异常，不能满负荷的服务整个应用请求等等。这些情况下，都需要启用限流来保护系统。可以拒绝服务、等待或降级处理，将流量限制到系统可接受的量，或者只允许某些域名(或某些业务)的请求优先处理。</p><p>   针对以上的场景需求，在设计一个<code>API</code>网关的限流功能时，就需要考虑如下的扩展点：</p><ol><li><p>可以支持多种限流的算法，并易于扩展。</p></li><li><p>要可以支持多种限流的方式，能区分用户群、高低优先级的请求。</p></li><li><p>要支持高并发，能快速的做出限制或通过的决策。</p></li><li><p>要有容错处理，如果限流程序出错，网关系统能继续执行。</p><p>本文会先介绍shenyu网关限流部分的总体技术架构，之后重点分析<code>RateLimiter</code> SPI扩展实现的代码。</p></li></ol><blockquote><p>This article based on <code>shenyu-2.4.0</code> version of the source code analysis.</p></blockquote><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiter--总体设计说明"></a>RateLimiter  总体设计说明<a class="hash-link" href="#ratelimiter--总体设计说明" title="Direct link to heading">#</a></h2><p>​        WebFlux是Spring 提供的基于Reactor模型的异步非阻塞框架，能提升吞吐量，使系统有更好的可伸缩性。Apache Shenyu网关的插件功能基于WebFlux框架实现的。RateLimiter功能是在<code>ratelimiter-plugin</code>中实现。在限流过程中，常用的算法有令牌桶、漏桶等算法，这些算法执行中，需要检核请求的来源，对已使用的流量做计数及逻辑计算，判定是否允许通过。为了提高并发及性能， 将计数和算法逻辑处理，都放到redis中。Java代码负责做数据参数的传递。在调用redis时，<a href="https://www.lua.org/" target="_blank" rel="noopener noreferrer">lua</a>脚本可以常驻在redis内存中，能减少网络开销，并可以作为一个整体执行，具有原子性。<a href="https://spring.io/projects/spring-data-redis" target="_blank" rel="noopener noreferrer">Spring Data Redis</a> 提供了对<a href="https://redis.io/commands" target="_blank" rel="noopener noreferrer">redis命令</a>执行的抽象，执行序列化，及自动使用redis 脚本缓存。在这个plugin中，由于采用了reactor 非阻塞框架，所以采用Spring Redis Reactive类库实现对redis的功能调用。</p><p>​        这个plugin中的类包图如下，重点标出了与<code>RateLimiter</code> <code>SPI</code>相关的两个package: resolver 和algorithm.</p><p><img alt="ratelimiter-package-diagram" src="/zh/assets/images/ratelimiter-package-diagram-b041571cdf2f8592c23ab33bf07fbc71.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiter-spi的设计"></a>RateLimiter SPI的设计<a class="hash-link" href="#ratelimiter-spi的设计" title="Direct link to heading">#</a></h2><p>由于采用了Spring data+ Redis +lua架构实现了高并发的需求。 如何做到对算法和限流方式的扩展呢？ Shenyu ratelimiter  plugin中设计了两个SPI来实现这两个需求：</p><ul><li><code>RateLimiterAlgorithm</code>：用来扩展不同的限流算法。</li><li><code>RateLimiterKeyResolver</code>： 用于扩展获取请求的关键信息，用于区分流量，例如按IP 地址、按某一段域名等来区分访问的请求。</li></ul><p>SPI的具体实作类与配置信息位于：<code>SHENYU_DIRECTORY</code>目录下 (默认在<code>/META-INF/shenyu</code>)下。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiterkeyresolver"></a>RateLimiterKeyResolver<a class="hash-link" href="#ratelimiterkeyresolver" title="Direct link to heading">#</a></h3><p>获取请求的关键信息，用于分组限流，例如按URL/ 用户 / IP 等， <code>RateLimiterKeyResolver</code> 接口定义如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface RateLimiterKeyResolver {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * get Key resolver&#x27;s name.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return Key resolver&#x27;s name</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String getKeyResolverName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * resolve.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param exchange exchange the current server exchange {@linkplain ServerWebExchange}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return rate limiter key</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resolve(ServerWebExchange exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>@SPI</code>将当前interface 注册为Shenyu SPI 接口。resolve(ServerWebExchange exchange)方法用来提供解析方式。</p><p>RateLimiterKeyResolver  SPI 提供了两种key resolver, <code>WholeKeyResolve</code>和 <code>RemoteAddrKeyResolver</code>，其中<code>RemoteAddrKeyResolver</code>中的<code>resolve</code>方法代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String resolve(final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>其key值为请求的IP地址。 基于SPI及工厂类的实现，可以非常方便的扩展实现新的key resolver，如URL,用户等等。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="ratelimiteralgorithm-spi"></a>RateLimiterAlgorithm SPI<a class="hash-link" href="#ratelimiteralgorithm-spi" title="Direct link to heading">#</a></h3><p><code>RateLimiterAlgorithm</code> SPI 用来实现对不同限流算法的识别、加载和定义，其类图如下：</p><p><img alt="ratelimiteral-class-diagram" src="/zh/assets/images/ratelimiteral-class-diagram-24df4785848602bdc5b321cf609d5cda.png"></p><p>本模组使用了工厂模式，提供了接口类、抽象类和工厂类，提供了4个实现类，其中实现类对应的Lua脚本在 <code>RateLimitEnum</code> 中做了定义，放置在 <code>/META-INF/scripts</code> 目录下。接口<code>RateLimiterAlgorithm</code>的代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface RateLimiterAlgorithm&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RedisScript&lt;T&gt; getScript();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; getKeys(String id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Callback string.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param script the script</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param keys the keys</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param scriptArgs the script args</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    default void callback(final RedisScript&lt;?&gt; script, final List&lt;String&gt; keys, final List&lt;String&gt; scriptArgs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>@SPI</code> 将这个接口注册为shenyu SPI, 其中定义了三个方法：</p><ul><li><code>getScript()</code> 方法返回一个 <code>RedisScript</code>对象，这个对象将传递给Redis。</li><li><code>getKeys(String id)</code> 返回一个键值的List.</li><li><code>callback()</code>回调函数用于异步处理一些需要在返回后做的处理，缺省是空方法。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="抽象类-abstractratelimiteralgorithm"></a>抽象类 AbstractRateLimiterAlgorithm<a class="hash-link" href="#抽象类-abstractratelimiteralgorithm" title="Direct link to heading">#</a></h4><p>在这个类中，实现了接口的模板方法，使用参数类型为<code>List&lt;Long&gt;</code>,  抽象方法getScriptName() 和getKeyName() 留给各个实作类来实现。如下的getScript() 是这个类中读取lua脚本的处理代码。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public RedisScript&lt;List&lt;Long&gt;&gt; getScript() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!this.initialized.get()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            DefaultRedisScript redisScript = new DefaultRedisScript&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String scriptPath = &quot;/META-INF/scripts/&quot; + getScriptName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptPath)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            redisScript.setResultType(List.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.script = redisScript;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            initialized.compareAndSet(false, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return redisScript;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return script;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>AtomicBoolean</code>类型的变量<code>initialized</code> 用来标记lua脚本是否有被加载。 如果还没有加载，就从/META-INF/scripts/目录下，读取<code>scriptName</code>指定的Lua文件，加载成<code>RedisScript</code>对象。指定结果为<code>List</code>类型， 设定量<code>initialized</code>为true,避免重复加载。 返回 <code>RedisScript</code>对象。</p><p><code>AbstractRateLimiterAlgorithm</code>中<code>getKeys()</code>的代码如下，</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;String&gt; getKeys(final String id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String prefix = getKeyName() + &quot;.{&quot; + id;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String tokenKey = prefix + &quot;}.tokens&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String timestampKey = prefix + &quot;}.timestamp&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Arrays.asList(tokenKey, timestampKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个模板方法中，产生了两个字符串，其中，<code>tokenKey</code>会作为Key传递给<code>redis</code>, 指向一个有序集合。 <code>timestampKey</code>是一个以传入id 为识别的字符串。</p><p>可以从上面的类图中看到，<code>ConcurrentRateLimiterAlgorithm</code> 和<code>SlidingWindowRateLimiterAlgorithm</code> 有覆写<code>getKeys(String id)</code>方法，而两外两个算法程序，则采用的是抽象类中的实现。也只有 <code>ConcurrentRateLimiterAlgorithm</code> 重写了<code>callback()</code>方法。下文中我们会对此做进一步的分析。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="工厂类ratelimiteralgorithmfactory"></a>工厂类RateLimiterAlgorithmFactory<a class="hash-link" href="#工厂类ratelimiteralgorithmfactory" title="Direct link to heading">#</a></h4><p><code>RateLimiterAlgorithmFactory</code> 中依据算法名称，获取RateLimiterAlgorithm实例的方法代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public static RateLimiterAlgorithm&lt;?&gt; newInstance(final String name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Optional.ofNullable(ExtensionLoader.getExtensionLoader(RateLimiterAlgorithm.class).getJoin(name)).orElse(new TokenBucketRateLimiterAlgorithm());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>按照Apache shenyu SPI的规则，由加载器<code>ExtensionLoader</code>获得实作类，当找不到算法时，默认返回令牌桶算法实现类。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="与redis做资料交互"></a>与Redis做资料交互<a class="hash-link" href="#与redis做资料交互" title="Direct link to heading">#</a></h3><p>从上面代码我们了解到Apache Shenyu网关中，RateLimiter SPI 的基本扩展点，在Shenyu网关运行中，应用ReactiveRedisTemplate 来异步执行对redis的调用处理。实现代码在RedisRateLimiter类的isAllowed()方法中，其部分代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public Mono&lt;RateLimiterResponse&gt; isAllowed(final String id, final RateLimiterHandle limiterHandle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // get parameters that will pass to redis from RateLimiterHandle Object</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double replenishRate = limiterHandle.getReplenishRate();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double burstCapacity = limiterHandle.getBurstCapacity();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        double requestCount = limiterHandle.getRequestCount();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // get the current used RateLimiterAlgorithm</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        RateLimiterAlgorithm&lt;?&gt; rateLimiterAlgorithm = RateLimiterAlgorithmFactory.newInstance(limiterHandle.getAlgorithmName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ........</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Flux&lt;List&lt;Long&gt;&gt; resultFlux = Singleton.INST.get(ReactiveRedisTemplate.class).execute(script, keys, scriptArgs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return resultFlux.onErrorResume(throwable -&gt; Flux.just(Arrays.asList(1L, -1L)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .reduce(new ArrayList&lt;Long&gt;(), (longs, l) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    longs.addAll(l);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return longs;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }).map(results -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    boolean allowed = results.get(0) == 1L;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Long tokensLeft = results.get(1);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    return new RateLimiterResponse(allowed, tokensLeft);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                })</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .doOnError(throwable -&gt; log.error(&quot;Error occurred while judging if user is allowed by RedisRateLimiter:{}&quot;, throwable.getMessage()))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .doFinally(signalType -&gt; rateLimiterAlgorithm.callback(script, keys, scriptArgs));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>POJO 对象RateLimiterHandle 中，定义了限流所需的属性算法名称, 速录，容量，请求的数量 。首先 从limiterHandle 包装类中取得需要传入redis的几个参数。之后从RateLimiterAlgorithmFactory 从工厂类取得当前配置的限流算法。 之后做Key值和参数的传递。</p><p>为了更方便阅读，下图给出了java代码与redis执行参数输入、输出的传递过程。左边是<code>isAllowed</code>() 函数的后半部分代码，右边是一个Lua脚本的输入输出代码。</p><p>下面说明Java代码的执行过程：</p><ol><li><p>从<code>getKeys()</code>方法获得两个键值<code>List&lt;String&gt;</code>. 其中第一个Key会映射为Redis中的有序集合。</p></li><li><p>设定4个参数：速率 replenishRate ,容量 burstCapacity, 时间戳， 返回当前java 纪元秒数(长整数)EpochSecond, 请求的数量 requestcount.</p></li><li><p>按所设定的脚本、Key值、参数调用<code>ReactiveRedisTemplate</code>功能，执行redis处理。返回参数是<code>Flux&lt;List&lt;Long&gt;&gt;</code>类型</p></li><li><p>通过reduce方法将其返回值从<code>Flux&lt;ArrayList&lt;Long&gt;&gt;</code> 类型转换为<code>Mono&lt;ArrayList&lt;Long&gt;&gt;</code>，再经过map方法，转换为<code>Mono&lt;RateLimiterResponse&gt;</code>返回。</p><p> 返回结果有两个资料，allowed =1, 代表允许通过，0-不通过；而第二个返回参数tokensLeft，是可用的剩余请求数量。</p></li></ol><p>5.容错性方面，由于使用的是reactor 的非阻塞通讯模型，当发生错误时，会执行onErrorResume()语句，Flux.just产生返回资料， 默认为<code>allowed</code>=1, 代表允许通过， 并丢出错误日志。</p><p>6.之后执行doFinally()方法,执行算法实现类的callback方法。</p><p><img alt="io-with-lua" src="/zh/assets/images/io-with-lua-eefcd28d4b59a8bd0e69e29400018c50.png"></p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4种限流算法"></a>4种限流算法<a class="hash-link" href="#4种限流算法" title="Direct link to heading">#</a></h2><p>上面我们了解了网关中如何通过Java代码如何与Redis 做通讯，这一节我们通过简要分析网关中提供的4种限流算法中的一些代码，来理解如何开发使用<code>RateLimiter SPI</code>的接口方法,并与Redis有效协作。</p><p><code>Ratelimiter SPI</code>目前提供了4种限流算法:</p><table><thead><tr><th>Algorithm name</th><th>Java class</th><th>Lua script file</th></tr></thead><tbody><tr><td>Request rate limiter</td><td><code>TokenBucketRateLimiterAlgorithm</code></td><td>request_rate_limiter.lua</td></tr><tr><td>Slide window rate limiter</td><td><code>SlidingWindowRateLimiterAlgorithm</code></td><td>liding_window_request_rate_limiter.lua</td></tr><tr><td>Concurrent rate limiter</td><td><code>ConcurrentRateLimiterAlgorithm</code></td><td>concurrent_request_rate_limiter.lua</td></tr><tr><td>Leaky bucket algorithm</td><td><code>LeakyBucketRateLimiterAlgorithm</code></td><td>request_leaky_rate_limiter.lua</td></tr></tbody></table><ol><li>令牌桶限流：按请求数量限流，设置每秒N个请求，超过N的请求会拒绝服务。算法实现时，以时间间隔计算匀速产生令牌的数量。若每次请求的数量，小于桶内令牌的数量，则允许通过。 时间窗口为 2*容积/速率。</li><li>滑动窗口限流：与令牌桶限流不同在于，其窗口大小比令牌桶的窗口小，为一个容积/速率。并且每次移动向后一个时间时间窗口。其他限流原理与令牌桶类似。</li><li>并发的请求速率限流：严格限制并发访问量为N个请求，大于N的请求会被拒绝。每次当有新请求，查看计数是否大于N, 若小于N则允许通过，计数加1。 当这个请求调用结束时，会释放这个信号（计数减1）</li><li>漏桶算法:  相对于令牌桶算法，漏桶算法有助于减少流量聚集，实现更为平滑的限流处理。 漏桶算法强制以常数N的速率输出流量，其以漏桶为模型，可漏水的量为时间间隔 *速率。若可漏水量&gt;已使用量，则已使用量设为0( 清空漏桶)，否则已使用量要减去可漏水量。  若请求数量+ 已使用量&lt; 总容量，则允许请求通过。</li></ol><p>下面以 并行限流算法为例，解读Lua和Java代码，查看callback 方法的使用。 通过解读令牌桶和滑动窗口算法代码，了解getKey()方法的使用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="并发请求数限流中使用callback方法"></a>并发请求数限流中使用callback方法<a class="hash-link" href="#并发请求数限流中使用callback方法" title="Direct link to heading">#</a></h3><p>首先<code>ConcurrentRateLimiterAlgorithm</code> 的<code>getKeys()</code> 方法覆写了抽象类中的模板方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;String&gt; getKeys(final String id) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String tokenKey = getKeyName() + &quot;.{&quot; + id + &quot;}.tokens&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String requestKey = UUIDUtils.getInstance().generateShortUuid();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Arrays.asList(tokenKey, requestKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>第二个元素 requestKey 是一个long型不重复值(由一个分布式ID产生器产生的，递增，比当前时间EpochSecond小)， 相应的concurrent_request_rate_limiter.lua的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local key = KEYS[1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local capacity = tonumber(ARGV[2])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp = tonumber(ARGV[3])</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local id = KEYS[2]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里id 即是取得上面的getKeys()方法产生的requestKey， 一个uuid.  后续的处理如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local count = redis.call(&quot;zcard&quot;, key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if count &lt; capacity then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  redis.call(&quot;zadd&quot;, key, timestamp, id)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  allowed = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  count = count + 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed, count }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>先用zcard命令统计redis中key值所对应的有序集合中的元素个数，若元素总数count小于容量，则允许通过，并用zadd key score member方法，向key所在的有序集合中，添加一个元素id, 其score为timestamp.  则此时元素的总个数count实际为count+1.  </p><p>以上的代码都是在redis中作为一个原子操作来执行的。当同一个key (例如Ip下)有大量并发请求时，redis记录的该ip的有序集合的数量count也在不断累加中。当超过容量限制，则会拒绝服务。</p><p>并发请求数限流算法中，要求当请求调用结束时，要释放这个信号量，lua代码中并没有做这个处理。</p><p>我们来看看 <code>ConcurrentRateLimiterAlgorithm</code>类中的回调函数：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void callback(final RedisScript&lt;?&gt; script, final List&lt;String&gt; keys, final List&lt;String&gt; scriptArgs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Singleton.INST.get(ReactiveRedisTemplate.class).opsForZSet().remove(keys.get(0), keys.get(1)).subscribe();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里做了一个异步的订阅处理，通过<code>ReactiveRedisTemplate</code>删除redis中(key, id)的元素，等待调用结束后，释放这个信号。这个remove的处理不能放到lua脚本中执行，否则逻辑就是错误的。这也正是<code>RateLimiterAlgorithm</code> SPI 设计<code>callback</code>方法的用意。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="令牌桶算法中使用getkeys"></a>令牌桶算法中使用getKeys()<a class="hash-link" href="#令牌桶算法中使用getkeys" title="Direct link to heading">#</a></h3><p>对应的Lua 代码如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local tokens_key = KEYS[1]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp_key = KEYS[2]</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>省略获取参数的代码</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local fill_time = capacity/rate</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local ttl = math.floor(fill_time*2)</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>时间窗口ttl 大概是 2* 容量/速率.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_tokens = tonumber(redis.call(&quot;get&quot;, tokens_key))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if last_tokens == nil then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  last_tokens = capacity</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从有序集合中取得上次使用的token,如果没有则last_tokens = 容量。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_refreshed = tonumber(redis.call(&quot;get&quot;, timestamp_key))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if last_refreshed == nil then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  last_refreshed = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>以timestamp_key为key,从有序集合中取得上次刷新时间，默认为0.</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local delta = math.max(0, now-last_refreshed)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local filled_tokens = math.min(capacity, last_tokens+(delta*rate))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed = filled_tokens &gt;= requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed_num = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if allowed then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  new_tokens = filled_tokens - requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  allowed_num = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>时间间隔*速率匀速产生令牌，若令牌数量&gt;请求数量，则allowed=1, 并且更新令牌数量。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&quot;setex&quot;, tokens_key, ttl, new_tokens)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&quot;setex&quot;, timestamp_key, ttl, now)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed_num, new_tokens }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里now是传入的当前时间(EpochSecond)，设置<code>tokens_key</code>所对应的有序集合的值为 <code>new_tokens</code>（即新令牌数量) ， 过期时间为<code>ttl</code>。 更新集合中，<code>timestamp_key</code>的值为当前时间，过期时间为<code>ttl</code>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="滑动窗口算法中使用getkeys方法"></a>滑动窗口算法中使用<code>getKeys</code>方法<a class="hash-link" href="#滑动窗口算法中使用getkeys方法" title="Direct link to heading">#</a></h3><p>在<code>SlidingWindowRateLimiterAlgorithm</code> 的<code>getKeys()</code>同样覆写了父类，代码与<code>ConcurrentRateLimiterAlgorithm</code> 方法代码一致。</p><p>如下为滑动窗口算法的Lua代码，省略了其他参数的接收代码。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local timestamp_key = KEYS[2]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">...... </span></span><span class="token-line" style="color:#393A34"><span class="token plain">local window_size = tonumber(capacity / rate)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local window_time = 1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>设定窗口大小为容积/速率。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local last_requested = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local exists_key = redis.call(&#x27;exists&#x27;, tokens_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (exists_key == 1) then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    last_requested = redis.call(&#x27;zcard&#x27;, tokens_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>获取当前key 的基数</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">local remain_request = capacity - last_requested</span></span><span class="token-line" style="color:#393A34"><span class="token plain">local allowed_num = 0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">if (last_requested &lt; capacity) then</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    allowed_num = 1</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    redis.call(&#x27;zadd&#x27;, tokens_key, now, timestamp_key)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">end</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>计算剩余可用量 = 容量 减去已使用量，若<code>last_requested</code> &lt; capacity ,则允许通过，并且在<code>tokens_key</code>为key的有序集合中，增加一个 元素（key =<code>timestam_key</code>,value= <code>now</code>)</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI lua"><pre tabindex="0" class="prism-code language-lua codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;zremrangebyscore&#x27;, tokens_key, 0, now - window_size / window_time)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">redis.call(&#x27;expire&#x27;, tokens_key, window_size)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">return { allowed_num, remain_request }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>前面已经设定<code>window_time</code>=1, 用Redis的 <code>zremrangebyscore</code>命令，移除有序集合中，score为[0- 当前时间-窗口大小]的元素，即移动一个窗口大小。设定tokens_key的过期时间为窗口大小。</p><p>在<code>AbstractRateLimiterAlgorithm</code>的模板方法中，<code>getKeys(final String id)</code> 给出的第二个值(以<code>secondKey</code>指代)，是拼接了{id} (即resolve key)的一个固定字符串。从上面三个算法代码可以看到，在令牌桶算法中，<code>secondKey</code>在Lua代码执行中会更新为最新的时间，所以无所谓传入的值。而在并发限流算法中，会以此<code>secondKey</code>为条件，在java <code>callback</code>方法中移除对应的元素。而在滑动窗口算法中，这个<code>secondKey</code>的值，会作为一个新元素的key, 增加到当前有序集合中，并在做窗口滑动中，过期的资料会被删除掉。</p><p>总之，当设计新的限流算法时，要根据算法需要仔细设计<code>getKey()</code>方法。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="如何调用-ratelimiter-spi"></a>如何调用 RateLimiter SPI<a class="hash-link" href="#如何调用-ratelimiter-spi" title="Direct link to heading">#</a></h2><p>在<code>RateLimiter</code> Plug中的<code>doExecute()</code>方法中，传入的三个参数 exchange 为请求的连接， chain 为shenyu插件的调用链，selector 是选择器，rule是系统中配置的规则参数资料。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RateLimiterHandle limiterHandle = RatelimiterRuleHandleCache.getInstance()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .obtainHandle(CacheKeyUtils.INST.getKey(rule));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String resolverKey = Optional.ofNullable(limiterHandle.getKeyResolverName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flatMap(name -&gt; Optional.of(&quot;-&quot; + RateLimiterKeyResolverFactory.newInstance(name).resolve(exchange)))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .orElse(&quot;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return redisRateLimiter.isAllowed(rule.getId() + resolverKey, limiterHandle)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        .flatMap(response -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!response.isAllowed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Object error = ShenyuResultWrap.error(ShenyuResultEnum.TOO_MANY_REQUESTS.getCode(), ShenyuResultEnum.TOO_MANY_REQUESTS.getMsg(), null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return WebFluxResultUtils.result(exchange, error);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return chain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>1.首先，从缓存中，取得系统设定的限流参数<code>RateLimiterHandle</code>实例 <code>limiterHandle</code>.
2.根据name指定的Resolver 获得请求的连接Key信息（如地址等).
3.调用 RedisRateLimiter的 isAllowed方法, 获取返回值后，
4.若<code>isAllowd</code>=false,做错误处理
5.如果 <code>isAllowed</code>=true，return chain.execute(exchange)， 对该请求做后续处理，传递到调用链的下一关。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="summary"></a>Summary<a class="hash-link" href="#summary" title="Direct link to heading">#</a></h2><p>整个<code>RateLimiter</code> plugin框架基于Spring WebFlux开发，用redis 和lua脚本做限流计数及核心逻辑处理，支持高并发及弹性扩展。</p><ol><li><p><code>RateLimiter</code> <code>SPI</code> 提供了两个<code>SPI</code> 接口，通过应用面向接口设计及各种设计模式，可以方便的增加新的限流算法，以及各种流量解析规则。</p></li><li><p>提供了令牌桶、并发速率限流、滑动窗口、漏桶4种限流算法。在设计算法实现时，需要根据算法特征设计KEY值，用Lua脚本实现在redis中要处理的逻辑，设计<code>callback()</code>方法做后续的数据处理。</p></li><li><p>响应式编程，实现过程简洁高效。</p></li></ol></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_xD8n"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/rate-limiter">rate limiter</a><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div><div class="col margin-top--sm"><a href="https://github.com/apache/shenyu-website/edit/main/i18n/zh/docusaurus-plugin-content-blog/SPI-SourceCode-Analysis-RateLimiter-SPI.md" target="_blank" rel="noreferrer noopener"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_mS5F" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑本文档</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/zh/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">« PredicateJudge-- 基于SPI的设计实现分析</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/zh/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor"><div class="pagination-nav__sublabel">Older Post</div><div class="pagination-nav__label">社区新人开发者启动及开发防踩坑指南 »</div></a></div></nav></main><div class="col col--2"><div class="tableOfContents_vrFS thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#ratelimiter--总体设计说明" class="table-of-contents__link">RateLimiter  总体设计说明</a></li><li><a href="#ratelimiter-spi的设计" class="table-of-contents__link">RateLimiter SPI的设计</a><ul><li><a href="#ratelimiterkeyresolver" class="table-of-contents__link">RateLimiterKeyResolver</a></li><li><a href="#ratelimiteralgorithm-spi" class="table-of-contents__link">RateLimiterAlgorithm SPI</a></li><li><a href="#与redis做资料交互" class="table-of-contents__link">与Redis做资料交互</a></li></ul></li><li><a href="#4种限流算法" class="table-of-contents__link">4种限流算法</a><ul><li><a href="#并发请求数限流中使用callback方法" class="table-of-contents__link">并发请求数限流中使用callback方法</a></li><li><a href="#令牌桶算法中使用getkeys" class="table-of-contents__link">令牌桶算法中使用getKeys()</a></li><li><a href="#滑动窗口算法中使用getkeys方法" class="table-of-contents__link">滑动窗口算法中使用<code>getKeys</code>方法</a></li></ul></li><li><a href="#如何调用-ratelimiter-spi" class="table-of-contents__link">如何调用 RateLimiter SPI</a></li><li><a href="#summary" class="table-of-contents__link">Summary</a></li></ul></div></div></div></div></div></div>
<script src="/zh/assets/js/runtime~main.95e9cd12.js"></script>
<script src="/zh/assets/js/main.7e9dd650.js"></script>
</body>
</html>