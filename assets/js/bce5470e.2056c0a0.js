"use strict";(self.webpackChunkshenyu_website=self.webpackChunkshenyu_website||[]).push([[22065],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var i=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),c=p(n),h=r,g=c["".concat(l,".").concat(h)]||c[h]||d[h]||a;return n?i.createElement(g,s(s({ref:t},u),{},{components:n})):i.createElement(g,s({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,s=new Array(a);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[c]="string"==typeof e?e:r,s[1]=o;for(var p=2;p<a;p++)s[p]=n[p];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},83043:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>s,default:()=>c,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=n(87462),r=(n(67294),n(3905));const a={title:"Register Center Source Code Analysis of Http Register",author:"midnight2104",author_title:"Apache ShenYu Committer",author_url:"https://github.com/midnight2104",tags:["http","register center","Apache ShenYu"]},s=void 0,o={permalink:"/blog/RegisterCenter-SourceCode-Analysis-Http-Register",editUrl:"https://github.com/apache/shenyu-website/edit/main/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md",source:"@site/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md",title:"Register Center Source Code Analysis of Http Register",description:"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.",date:"2023-12-23T07:38:47.486Z",formattedDate:"December 23, 2023",tags:[{label:"http",permalink:"/blog/tags/http"},{label:"register center",permalink:"/blog/tags/register-center"},{label:"Apache ShenYu",permalink:"/blog/tags/apache-shen-yu"}],readingTime:28.94,truncated:!1,prevItem:{title:"Code Analysis For Param-Mapping Plugin",permalink:"/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin"},nextItem:{title:"Code Analysis For Dubbo Plugin",permalink:"/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin"}},l=[{value:"1. Registration Center Principle",id:"1-registration-center-principle",children:[]},{value:"2. Client Registration Process",id:"2-client-registration-process",children:[]},{value:"3. Server-side registration process",id:"3-server-side-registration-process",children:[]},{value:"4. Summary",id:"4-summary",children:[]}],p={toc:l},u="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(u,(0,i.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/index"},"Apache ShenYu")," is an asynchronous, high-performance, cross-language, responsive API gateway.")),(0,r.kt)("p",null,"In ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," gateway, the registration center is used to register the client information to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," then synchronizes this information to the gateway through data synchronization, and the gateway completes traffic filtering through these data. The client information mainly includes ",(0,r.kt)("inlineCode",{parentName:"p"},"interface information")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI information"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This article is based on ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-2.5.0")," version for source code analysis, please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/design/register-center-design"},"Client Access Principles")," for the introduction of the official website.")),(0,r.kt)("h3",{id:"1-registration-center-principle"},"1. Registration Center Principle"),(0,r.kt)("p",null,"When the client starts, it reads the interface information and ",(0,r.kt)("inlineCode",{parentName:"p"},"uri information"),", and sends the data to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," by the specified registration type."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(34177).Z})),(0,r.kt)("p",null,"The registration center in the figure requires the user to specify which registration type to use. ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," currently supports ",(0,r.kt)("inlineCode",{parentName:"p"},"Http"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Zookeeper"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Etcd"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Consul")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Nacos")," for registration. Please refer to ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/user-guide/property-config/register-center-access"},"Client Access Configuration")," for details on how to configure them."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenYu")," introduces ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," in the principle design of the registration center, in which the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue plays a role in decoupling data and operations, which is conducive to expansion. If too many registration requests lead to registration exceptions, it also has a data buffering role."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(10318).Z})),(0,r.kt)("p",null,"As shown in the figure, the registration center is divided into two parts, one is the registration center client ",(0,r.kt)("inlineCode",{parentName:"p"},"register-client"),", the load processing client data reading. The other is the registration center server ",(0,r.kt)("inlineCode",{parentName:"p"},"register-server"),", which is loaded to handle the server side (that is ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),") data writing. Data is sent and received by specifying the registration type."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Client: Usually it is a microservice, which can be ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"spring-cloud"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"grpc"),", etc."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"register-client"),": register the central client, read the client interface and ",(0,r.kt)("inlineCode",{parentName:"li"},"uri")," information."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor"),": decoupling data from operations, data buffering role."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"register-server"),": registry server, here is ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu-admin"),", receive data, write to database, send data synchronization events."),(0,r.kt)("li",{parentName:"ul"},"registration-type: specify the registration type, complete data registration, currently supports ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),".")),(0,r.kt)("p",null,"This article analyzes the use of ",(0,r.kt)("inlineCode",{parentName:"p"},"Http")," for registration, so the specific processing flow is as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(13210).Z})),(0,r.kt)("p",null,"On the client side, after the data is out of the queue, the data is transferred via ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," and on the server side, the corresponding interface is provided to receive the data and then write it to the queue."),(0,r.kt)("h3",{id:"2-client-registration-process"},"2. Client Registration Process"),(0,r.kt)("p",null,"When the client starts, it reads the attribute information according to the relevant configuration, and then writes it to the queue. Let's take the official ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http"},"shenyu-examples-http")," as an example and start the source code analysis . The official example is a microservice built by ",(0,r.kt)("inlineCode",{parentName:"p"},"springboot"),". For the configuration of the registration center, please refer to the official website ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/user-guide/property-config/register-center-access"},"client access configuration")," ."),(0,r.kt)("h4",{id:"21-load-configuration-read-properties"},"2.1 Load configuration, read properties"),(0,r.kt)("p",null,"Let's start with a diagram that ties together the initialization process of the registry client."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(98557).Z})),(0,r.kt)("p",null,"We are analyzing registration by means of ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", so the following configuration is required."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n  register:\n    registerType: http\n    serverLists: http://localhost:9095\n  props:\n    username: admin\n    password: 123456\n  client:\n    http:\n        props:\n          contextPath: /http\n          appName: http\n          port: 8189  \n          isFull: false\n")),(0,r.kt)("p",null,"Each attribute indicates the following meaning."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"registerType"),": the service registration type, fill in ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"serverList"),": The address of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Shenyu-Admin")," project to fill in for the ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration type, note the addition of ",(0,r.kt)("inlineCode",{parentName:"li"},"http://")," and separate multiple addresses with English commas."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"username"),": The username of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Shenyu-Admin")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"password"),": The password of the ",(0,r.kt)("inlineCode",{parentName:"li"},"Shenyu-Admin")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"port"),": the start port of your project, currently ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc/tars/grpc")," needs to be filled in."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"contextPath"),": the routing prefix for your ",(0,r.kt)("inlineCode",{parentName:"li"},"mvc")," project in ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu")," gateway, such as ",(0,r.kt)("inlineCode",{parentName:"li"},"/order"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"/product"),", etc. The gateway will route according to your prefix."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"appName"),": the name of your application, if not configured, it will take the value of ",(0,r.kt)("inlineCode",{parentName:"li"},"spring.application.name")," by default."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"isFull"),": set ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," to proxy your entire service, ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," to proxy one of your ",(0,r.kt)("inlineCode",{parentName:"li"},"controllers"),"; currently applies to ",(0,r.kt)("inlineCode",{parentName:"li"},"springmvc/springcloud"),".")),(0,r.kt)("p",null,"After the project starts, it will first load the configuration file, read the property information and generate the corresponding ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"."),(0,r.kt)("p",null,"The first configuration file read is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClientConfiguration"),", which is the ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," registration configuration class for the ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu")," client, indicated by ",(0,r.kt)("inlineCode",{parentName:"p"},"@Configuration")," which is a configuration class, and by ",(0,r.kt)("inlineCode",{parentName:"p"},"@ImportAutoConfiguration")," which is a configuration class. to introduce other configuration classes. Create ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientEventListener"),", which mainly handles metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * Shenyu SpringMvc Client Configuration\n */\n@Configuration\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\n@ConditionalOnProperty(value = "shenyu.register.enabled", matchIfMissing = true, havingValue = "true")\npublic class ShenyuSpringMvcClientConfiguration {\n\n    // create SpringMvcClientEventListener to handle metadata and URI\n    @Bean\n    public SpringMvcClientEventListener springHttpClientEventListener(final ShenyuClientConfig clientConfig,\n                                                                      final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        return new SpringMvcClientEventListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);\n    }\n}\n\n')),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientCommonBeanConfiguration")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu")," client common configuration class that will create the ",(0,r.kt)("inlineCode",{parentName:"p"},"bean")," common to the registry client."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterRepository"),", which is created by factory class."),(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuRegisterCenterConfig"),", which reads the ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu.register")," property configuration."),(0,r.kt)("li",{parentName:"ul"},"Create ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientConfig"),", read the ",(0,r.kt)("inlineCode",{parentName:"li"},"shenyu.client")," property configuration.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * Shenyu Client Common Bean Configuration\n */\n@Configuration\npublic class ShenyuClientCommonBeanConfiguration {\n    \n   // create ShenyuClientRegisterRepository by factory \n    @Bean\n    public ShenyuClientRegisterRepository shenyuClientRegisterRepository(final ShenyuRegisterCenterConfig config) {\n        return ShenyuClientRegisterRepositoryFactory.newInstance(config);\n    }\n    \n    // create ShenyuRegisterCenterConfig to read shenyu.register properties\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu.register")\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\n        return new ShenyuRegisterCenterConfig();\n    }\n    \n  // create ShenyuClientConfig to read shenyu.client properties\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu")\n    public ShenyuClientConfig shenyuClientConfig() {\n        return new ShenyuClientConfig();\n    }\n}\n\n')),(0,r.kt)("h4",{id:"22-httpclientregisterrepository"},"2.2 HttpClientRegisterRepository"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterRepository")," generated in the configuration file above is a concrete implementation of the client registration, which is an interface with the following implementation class."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(47868).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HttpClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ConsulClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EtcdClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"EtcdClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"nacos"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"NacosClientRegisterRepository"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"nacos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperClientRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),".")),(0,r.kt)("p",null,"The specific way which is achieved by loading through ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),", the implementation logic is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * load ShenyuClientRegisterRepository\n */\npublic final class ShenyuClientRegisterRepositoryFactory {\n    \n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\n    \n    /**\n     * create ShenyuClientRegisterRepository\n     */\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\n            // Loading by means of SPI, type determined by registerType\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\n            //init ShenyuClientRegisterRepository\n            result.init(shenyuRegisterCenterConfig);\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\n            return result;\n        }\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\n    }\n}\n")),(0,r.kt)("p",null,"The load type is specified by ",(0,r.kt)("inlineCode",{parentName:"p"},"registerType"),", which is the type we specify in the configuration file at"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n  register:\n    registerType: http\n    serverLists: http://localhost:9095\n")),(0,r.kt)("p",null,"We specified ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", so it will go to load ",(0,r.kt)("inlineCode",{parentName:"p"},"HttpClientRegisterRepository"),". After the object is successfully created, the initialization method ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," is executed as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Join\npublic class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {\n\n    @Override\n    public void init(final ShenyuRegisterCenterConfig config) {\n        this.username = config.getProps().getProperty(Constants.USER_NAME);\n        this.password = config.getProps().getProperty(Constants.PASS_WORD);\n        this.serverList = Lists.newArrayList(Splitter.on(",").split(config.getServerLists()));\n        this.setAccessToken();\n    }\n  \n  // ......\n}\n')),(0,r.kt)("p",null,"Read ",(0,r.kt)("inlineCode",{parentName:"p"},"username"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"password")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"serverLists")," from the configuration file, the username, password and address of ",(0,r.kt)("inlineCode",{parentName:"p"},"sheenyu-admin"),", in preparation for subsequent data sending. The class annotation ",(0,r.kt)("inlineCode",{parentName:"p"},"@Join")," is used for ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI")," loading."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),", known as ",(0,r.kt)("inlineCode",{parentName:"p"},"Service Provider Interface"),", is a service provider discovery feature built into the ",(0,r.kt)("inlineCode",{parentName:"p"},"JDK"),", a mechanism for dynamic replacement discovery."),(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-spi"},"shenyu-spi")," is a custom ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI")," extension implementation for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," gateway, designed and implemented with reference to Dubbo ",(0,r.kt)("a",{parentName:"p",href:"https://dubbo.apache.org/zh/docs/v2.7/dev/impls/"},"SPI extension implementation"),".")),(0,r.kt)("h4",{id:"23-springmvcclienteventlistener"},"2.3 SpringMvcClientEventListener"),(0,r.kt)("p",null,"Create ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientEventListener"),", which is responsible for the construction and registration of client-side metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, and its creation is done in the configuration file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"@Configuration\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\npublic class ShenyuSpringMvcClientConfiguration {\n     // ......\n    \n    // create SpringMvcClientEventListener\n    @Bean\n    public SpringMvcClientEventListener springHttpClientEventListener(final ShenyuClientConfig clientConfig,\n                                                                      final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        return new SpringMvcClientEventListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvcClientEventListener")," implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractContextRefreshedEventListener")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(87570).Z})),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractContextRefreshedEventListener")," is an abstract class. it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationListener")," interface and overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()")," method, which is executed when a Spring event occurs. It has several implementation classes, which support different kind of ",(0,r.kt)("inlineCode",{parentName:"p"},"RPC")," styles."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AlibabaDubboServiceBeanListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Alibaba Dubbo")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ApacheDubboServiceBeanListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Apache Dubbo")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"GrpcClientEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"grpc")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"MotanServiceEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Motan")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SofaServiceEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Sofa")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SpringMvcClientEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SpringWebSocketClientEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Websocket")," protocol."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"TarsServiceBeanEventListener"),"\uff1ahandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Tars")," protocol.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public abstract class AbstractContextRefreshedEventListener<T, A extends Annotation> implements ApplicationListener<ContextRefreshedEvent> {\n\n    //......\n\n    // Instantiation is done through the constructor\n    public AbstractContextRefreshedEventListener(final PropertiesConfig clientConfig,\n                                                 final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        // read shenyu.client.http properties\n        Properties props = clientConfig.getProps();\n        // appName \n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\n        // contextPath\n        this.contextPath = Optional.ofNullable(props.getProperty(ShenyuClientConstants.CONTEXT_PATH)).map(UriUtils::repairData).orElse("");\n        if (StringUtils.isBlank(appName) && StringUtils.isBlank(contextPath)) {\n            String errorMsg = "client register param must config the appName or contextPath";\n            LOG.error(errorMsg);\n            throw new ShenyuClientIllegalArgumentException(errorMsg);\n        }\n        this.ipAndPort = props.getProperty(ShenyuClientConstants.IP_PORT);\n        // host\n        this.host = props.getProperty(ShenyuClientConstants.HOST);\n        // port\n        this.port = props.getProperty(ShenyuClientConstants.PORT);\n        // publish event\n        publisher.start(shenyuClientRegisterRepository);\n    }\n\n    // This method is executed when a context refresh event(ContextRefreshedEvent), occurs\n    @Override\n    public void onApplicationEvent(@NonNull final ContextRefreshedEvent event) {\n        // The contents of the method are guaranteed to be executed only once\n        if (!registered.compareAndSet(false, true)) {\n            return;\n        }\n        final ApplicationContext context = event.getApplicationContext();\n        // get the specific beans \n        Map<String, T> beans = getBeans(context);\n        if (MapUtils.isEmpty(beans)) {\n            return;\n        }\n        // build URI data and register it\n        publisher.publishEvent(buildURIRegisterDTO(context, beans));\n        // build metadata and register it\n        beans.forEach(this::handle);\n    }\n    \n    @SuppressWarnings("all")\n    protected abstract URIRegisterDTO buildURIRegisterDTO(ApplicationContext context,\n                                                          Map<String, T> beans);\n\n\n    protected void handle(final String beanName, final T bean) {\n        Class<?> clazz = getCorrectedClass(bean);\n        final A beanShenyuClient = AnnotatedElementUtils.findMergedAnnotation(clazz, getAnnotationType());\n        final String superPath = buildApiSuperPath(clazz, beanShenyuClient);\n        if (Objects.nonNull(beanShenyuClient) && superPath.contains("*")) {\n            handleClass(clazz, bean, beanShenyuClient, superPath);\n            return;\n        }\n        final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(clazz);\n        for (Method method : methods) {\n            handleMethod(bean, clazz, beanShenyuClient, method, superPath);\n        }\n    }\n\n    // default implementation. build URI data and register it\n    protected void handleClass(final Class<?> clazz,\n                               final T bean,\n                               @NonNull final A beanShenyuClient,\n                               final String superPath) {\n        publisher.publishEvent(buildMetaDataDTO(bean, beanShenyuClient, pathJoin(contextPath, superPath), clazz, null));\n    }\n\n    // default implementation. build metadata and register it\n    protected void handleMethod(final T bean,\n                                final Class<?> clazz,\n                                @Nullable final A beanShenyuClient,\n                                final Method method,\n                                final String superPath) {\n        // get the annotation\n        A methodShenyuClient = AnnotatedElementUtils.findMergedAnnotation(method, getAnnotationType());\n        if (Objects.nonNull(methodShenyuClient)) {\n            // \u6784\u5efa\u5143\u6570\u636e\uff0c\u53d1\u9001\u6ce8\u518c\u4e8b\u4ef6\n            publisher.publishEvent(buildMetaDataDTO(bean, methodShenyuClient, buildApiPath(method, superPath, methodShenyuClient), clazz, method));\n        }\n    }\n    \n    protected abstract MetaDataRegisterDTO buildMetaDataDTO(T bean,\n                                                            @NonNull A shenyuClient,\n                                                            String path,\n                                                            Class<?> clazz,\n                                                            Method method);\n}\n\n')),(0,r.kt)("p",null,"In the constructor, the main purpose is to read the property information and then perform the checksum."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n  client:\n    http:\n      props:\n        contextPath: /http\n        appName: http\n        port: 8189\n        isFull: false\n")),(0,r.kt)("p",null,"Finally, publisher.start() is executed to start event publishing and prepare for registration."),(0,r.kt)("p",null,"ShenyuClientRegisterEventPublisher is implemented via singleton pattern, mainly generating metadata and URI subscribers (subsequently used for data publishing), and then starting the Disruptor queue. A common method publishEvent() is provided to publish events and send data to the Disruptor queue."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class ShenyuClientRegisterEventPublisher {\n    \n    private static final ShenyuClientRegisterEventPublisher INSTANCE = new ShenyuClientRegisterEventPublisher();\n\n    private DisruptorProviderManage<DataTypeParent> providerManage;\n    \n    public static ShenyuClientRegisterEventPublisher getInstance() {\n        return INSTANCE;\n    }\n    \n    public void start(final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        RegisterClientExecutorFactory factory = new RegisterClientExecutorFactory();\n        factory.addSubscribers(new ShenyuClientMetadataExecutorSubscriber(shenyuClientRegisterRepository));\n        factory.addSubscribers(new ShenyuClientURIExecutorSubscriber(shenyuClientRegisterRepository));\n        providerManage = new DisruptorProviderManage(factory);\n        providerManage.startup();\n    }\n    \n    public <T> void publishEvent(final DataTypeParent data) {\n        DisruptorProvider<DataTypeParent> provider = providerManage.getProvider();\n        provider.onData(data);\n    }\n}\n")),(0,r.kt)("p",null,"The logic of the constructor of ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractContextRefreshedEventListener")," is analyzed, it mainly reads the property configuration, creates metadata and URI subscribers, and starts the Disruptor queue."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()")," method is executed when a ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," event occurs, the parameter here is ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextRefreshedEvent"),", which means the context refresh event. "),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("inlineCode",{parentName:"p"},"ContextRefreshedEvent")," is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring")," built-in event. It is fired when the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationContext")," is initialized or refreshed. This can also happen in the ",(0,r.kt)("inlineCode",{parentName:"p"},"ConfigurableApplicationContext")," interface using the ",(0,r.kt)("inlineCode",{parentName:"p"},"refresh()")," method. Initialization here means that all ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"s have been successfully loaded, post-processing ",(0,r.kt)("inlineCode",{parentName:"p"},"Bean"),"s have been detected and activated, all ",(0,r.kt)("inlineCode",{parentName:"p"},"Singleton Bean"),"s have been pre-instantiated, and the ",(0,r.kt)("inlineCode",{parentName:"p"},"ApplicationContext")," container is ready to be used.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SpringMvcClientEventListener"),": the ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," implementation of ",(0,r.kt)("inlineCode",{parentName:"li"},"AbstractContextRefreshedEventListener"),":")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class SpringMvcClientEventListener extends AbstractContextRefreshedEventListener<Object, ShenyuSpringMvcClient> {\n    \n    private final List<Class<? extends Annotation>> mappingAnnotation = new ArrayList<>(3);\n    \n    private final Boolean isFull;\n    \n    private final String protocol;\n    \n    // \u6784\u9020\u51fd\u6570\n    public SpringMvcClientEventListener(final PropertiesConfig clientConfig,\n                                        final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\n        super(clientConfig, shenyuClientRegisterRepository);\n        Properties props = clientConfig.getProps();\n        // get isFull\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\n        // http protocol\n        this.protocol = props.getProperty(ShenyuClientConstants.PROTOCOL, ShenyuClientConstants.HTTP);\n        mappingAnnotation.add(ShenyuSpringMvcClient.class);\n        mappingAnnotation.add(RequestMapping.class);\n    }\n    \n    @Override\n    protected Map<String, Object> getBeans(final ApplicationContext context) {\n        // Configuration attribute, if isFull=true, means register the whole microservice\n        if (Boolean.TRUE.equals(isFull)) {\n            getPublisher().publishEvent(MetaDataRegisterDTO.builder()\n                    .contextPath(getContextPath())\n                    .appName(getAppName())\n                    .path(PathUtils.decoratorPathWithSlash(getContextPath()))\n                    .rpcType(RpcTypeEnum.HTTP.getName())\n                    .enabled(true)\n                    .ruleName(getContextPath())\n                    .build());\n            return null;\n        }\n        // get bean with Controller annotation\n        return context.getBeansWithAnnotation(Controller.class);\n    }\n    \n    @Override\n    protected URIRegisterDTO buildURIRegisterDTO(final ApplicationContext context,\n                                                 final Map<String, Object> beans) {\n        // ...\n    }\n    \n    @Override\n    protected String buildApiSuperPath(final Class<?> clazz, @Nullable final ShenyuSpringMvcClient beanShenyuClient) {\n        if (Objects.nonNull(beanShenyuClient) && StringUtils.isNotBlank(beanShenyuClient.path())) {\n            return beanShenyuClient.path();\n        }\n        RequestMapping requestMapping = AnnotationUtils.findAnnotation(clazz, RequestMapping.class);\n        // Only the first path is supported temporarily\n        if (Objects.nonNull(requestMapping) && ArrayUtils.isNotEmpty(requestMapping.path()) && StringUtils.isNotBlank(requestMapping.path()[0])) {\n            return requestMapping.path()[0];\n        }\n        return "";\n    }\n    \n    @Override\n    protected Class<ShenyuSpringMvcClient> getAnnotationType() {\n        return ShenyuSpringMvcClient.class;\n    }\n    \n    @Override\n    protected void handleMethod(final Object bean, final Class<?> clazz,\n                                @Nullable final ShenyuSpringMvcClient beanShenyuClient,\n                                final Method method, final String superPath) {\n        // get RequestMapping annotation\n        final RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);\n        // get ShenyuSpringMvcClient annotation\n        ShenyuSpringMvcClient methodShenyuClient = AnnotatedElementUtils.findMergedAnnotation(method, ShenyuSpringMvcClient.class);\n        methodShenyuClient = Objects.isNull(methodShenyuClient) ? beanShenyuClient : methodShenyuClient;\n        // the result of ReflectionUtils#getUniqueDeclaredMethods contains method such as hashCode, wait, toSting\n        // add Objects.nonNull(requestMapping) to make sure not register wrong method\n        if (Objects.nonNull(methodShenyuClient) && Objects.nonNull(requestMapping)) {\n            getPublisher().publishEvent(buildMetaDataDTO(bean, methodShenyuClient, buildApiPath(method, superPath, methodShenyuClient), clazz, method));\n        }\n    }\n    \n    //...\n    \n    // \u6784\u9020\u5143\u6570\u636e\n    @Override\n    protected MetaDataRegisterDTO buildMetaDataDTO(final Object bean,\n                                                   @NonNull final ShenyuSpringMvcClient shenyuClient,\n                                                   final String path, final Class<?> clazz,\n                                                   final Method method) {\n        //...\n    }\n}\n')),(0,r.kt)("p",null,"The registration logic is done through ",(0,r.kt)("inlineCode",{parentName:"p"},"publisher.publishEvent()"),". "),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Controller")," annotation and the ",(0,r.kt)("inlineCode",{parentName:"p"},"RequestMapping")," annotation are provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"Spring"),", which you should be familiar with, so I won't go into details. The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuSpringMvcClient")," annotation is provided by ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," to register the ",(0,r.kt)("inlineCode",{parentName:"p"},"SpringMvc")," client, which is defined as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * ShenyuSpringMvcClient\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface ShenyuSpringMvcClient {\n\n    // path\n    @AliasFor(attribute = "path")\n    String value() default "";\n    \n    // path\n    @AliasFor(attribute = "value")\n    String path();\n    \n    // ruleName\n    String ruleName() default "";\n    \n    // desc info\n    String desc() default "";\n\n    // enabled\n    boolean enabled() default true;\n    \n    // register MetaData \n    boolean  registerMetaData() default false;\n}\n\n')),(0,r.kt)("p",null,"It is used as follows."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register the entire interface")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\n@RequestMapping("/test")\n@ShenyuSpringMvcClient(path = "/test/**")  // register the entire interface\npublic class HttpTestController {\n    //......\n}\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register current method")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RestController\n@RequestMapping("/order")\n@ShenyuSpringMvcClient(path = "/order")\npublic class OrderController {\n\n    /**\n     * Save order dto.\n     *\n     * @param orderDTO the order dto\n     * @return the order dto\n     */\n    @PostMapping("/save")\n    @ShenyuSpringMvcClient(path = "/save", desc = "Save order") // register current method\n    public OrderDTO save(@RequestBody final OrderDTO orderDTO) {\n        orderDTO.setName("hello world save order");\n        return orderDTO;\n    }\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"publisher.publishEvent()")),(0,r.kt)("p",null,"This method sends the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. More details about the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue are not described here, which does not affect the flow of analyzing the registration."),(0,r.kt)("p",null,"When the data is sent, the consumers of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue will process the data for consumption."),(0,r.kt)("p",null,"This method sends the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue. More details about the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue are not described here, which does not affect the flow of analyzing the registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"QueueConsumer")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," is a consumer that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface, which is created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"providerManage.startup()")," logic. The ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface is the data consumption interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor"),", and the only method is ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.lmax.disruptor;\n\npublic interface WorkHandler<T> {\n    void onEvent(T event) throws Exception;\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()")," method, and the main logic is to generate the consumption task and then go to the thread pool to execute it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * \n * QueueConsumer\n */\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\n    \n    // ......\n\n    @Override\n    public void onEvent(final DataEvent<T> t) {\n        if (t != null) {\n            // Use different thread pools based on DataEvent type\n            ThreadPoolExecutor executor = orderly(t);\n            // create queue consumption tasks via factory\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\n            // set data\n            queueConsumerExecutor.setData(t.getData());\n            // help gc\n            t.setData(null);\n            // put in the thread pool to execute the consumption task\n            executor.execute(queueConsumerExecutor);\n        }\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," is the task that is executed in the thread pool, it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface, and there are two specific implementation classes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterClientConsumerExecutor"),"\uff1athe client-side consumer executor."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor"),"\uff1aserver-side consumer executor.")),(0,r.kt)("p",null,"As the name implies, one is responsible for handling client-side tasks, and one is responsible for handling server-side tasks (the server side is ",(0,r.kt)("inlineCode",{parentName:"p"},"admin"),", which is analyzed below)."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(5847).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterClientConsumerExecutor")),(0,r.kt)("p",null,"The logic of the rewritten ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," is as follows."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic final class RegisterClientConsumerExecutor<T extends DataTypeParent> extends QueueConsumerExecutor<T> {\n    \n    //...... \n\n    @Override\n    public void run() {\n        // get data\n        final T data = getData();\n        // call the appropriate processor for processing according to the data type\n        subscribers.get(data.getType()).executor(Lists.newArrayList(data));\n    }\n    \n}\n")),(0,r.kt)("p",null,"Different processors are called to perform the corresponding tasks based on different data types. There are two types of data, one is metadata, which records the client registration information. One is the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, which records the client service information."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public enum DataType {\n   \n    META_DATA,\n    \n    URI,\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The actuator subscribers are divided into two categories, one that handles metadata and one that handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URIs"),". There are two on the client side and two on the server side, so there are four in total."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(60797).Z})),(0,r.kt)("p",null,"Here is the registration metadata information, so the execution class is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientMetadataExecutorSubscriber"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientMetadataExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The metadata processing logic on the client side is: iterate through the metadata information and call the interface method ",(0,r.kt)("inlineCode",{parentName:"p"},"persistInterface()")," to finish publishing the data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class ShenyuClientMetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\n   \n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.META_DATA;\n    }\n    \n    @Override\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\n        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {\n            // call the interface method persistInterface() to finish publishing the data\n            shenyuClientRegisterRepository.persistInterface(metaDataRegisterDTO);\n        }\n    }\n}\n")),(0,r.kt)("p",null,"The two registration interfaces get the data well and call the ",(0,r.kt)("inlineCode",{parentName:"p"},"publish()")," method to publish the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuServerRegisterRepository"))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuServerRegisterRepository")," interface is a service registration interface, which has five implementation classes, indicating five types of registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ConsulServerRegisterRepository"),": registration is achieved through ",(0,r.kt)("inlineCode",{parentName:"li"},"Consul"),";"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EtcdServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Etcd"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NacosServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Nacos"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"; ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController"),": registration via ",(0,r.kt)("inlineCode",{parentName:"li"},"Http"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ZookeeperServerRegisterRepository"),": registration through ",(0,r.kt)("inlineCode",{parentName:"li"},"Zookeeper"),".")),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(79568).Z})),(0,r.kt)("p",null,"As you can see from the diagram, the loading of the registry is done by means of SPI. This was mentioned earlier, and the specific class loading is done in the client-side generic configuration file by specifying the properties in the configuration file."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * load ShenyuClientRegisterRepository\n */\npublic final class ShenyuClientRegisterRepositoryFactory {\n    \n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\n    \n    /**\n     * create ShenyuClientRegisterRepository\n     */\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\n            // loading by means of SPI, type determined by registerType\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\n            // perform initialization operations\n            result.init(shenyuRegisterCenterConfig);\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\n            return result;\n        }\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\n    }\n}\n")),(0,r.kt)("p",null,"The source code analysis in this article is based on the Http way of registration, so we first analyze the HttpClientRegisterRepository, and the other registration methods will be analyzed afterwards."),(0,r.kt)("p",null,"Registration by way of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," is very simple, it is to call the tool class to send http requests. The registration metadata and URI are both called by the same method ",(0,r.kt)("inlineCode",{parentName:"p"},"doRegister()"),", specifying the interface and type."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Constants.URI_PATH")," = ",(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-metadata"),": the interface provided by the server for registering metadata."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Constants.META_PATH")," = ",(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-uri"),": Server-side interface for registering URIs.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Join\npublic class HttpClientRegisterRepository extends FailbackRegistryRepository {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientRegisterRepository.class);\n\n    private static URIRegisterDTO uriRegisterDTO;\n\n    private String username;\n\n    private String password;\n\n    private List<String> serverList;\n\n    private String accessToken;\n    \n    public HttpClientRegisterRepository() {\n    }\n    \n    public HttpClientRegisterRepository(final ShenyuRegisterCenterConfig config) {\n        init(config);\n    }\n\n    @Override\n    public void init(final ShenyuRegisterCenterConfig config) {\n        // admin username\n        this.username = config.getProps().getProperty(Constants.USER_NAME);\n        // admin paaword\n        this.password = config.getProps().getProperty(Constants.PASS_WORD);\n        // admin server address\n        this.serverList = Lists.newArrayList(Splitter.on(",").split(config.getServerLists()));\n        // set access token\n        this.setAccessToken();\n    }\n\n    /**\n     * Persist uri.\n     *\n     * @param registerDTO the register dto\n     */\n    @Override\n    public void doPersistURI(final URIRegisterDTO registerDTO) {\n        if (RuntimeUtils.listenByOther(registerDTO.getPort())) {\n            return;\n        }\n        doRegister(registerDTO, Constants.URI_PATH, Constants.URI);\n        uriRegisterDTO = registerDTO;\n    }\n\n    @Override\n    public void doPersistInterface(final MetaDataRegisterDTO metadata) {\n        doRegister(metadata, Constants.META_PATH, Constants.META_TYPE);\n    }\n\n    @Override\n    public void close() {\n        if (uriRegisterDTO != null) {\n            uriRegisterDTO.setEventType(EventType.DELETED);\n            doRegister(uriRegisterDTO, Constants.URI_PATH, Constants.URI);\n        }\n    }\n\n    private void setAccessToken() {\n        for (String server : serverList) {\n            try {\n                Optional<?> login = RegisterUtils.doLogin(username, password, server.concat(Constants.LOGIN_PATH));\n                login.ifPresent(v -> this.accessToken = String.valueOf(v));\n            } catch (Exception e) {\n                LOGGER.error("Login admin url :{} is fail, will retry. cause: {} ", server, e.getMessage());\n            }\n        }\n    }\n\n    private <T> void doRegister(final T t, final String path, final String type) {\n        int i = 0;\n        // iterate through the list of admin services (admin may be clustered)\n        for (String server : serverList) {\n            i++;\n            String concat = server.concat(path);\n            try {\n                // \u8bbe\u7f6e\u8bbf\u95eetoken\n                if (StringUtils.isBlank(accessToken)) {\n                    this.setAccessToken();\n                    if (StringUtils.isBlank(accessToken)) {\n                        throw new NullPointerException("accessToken is null");\n                    }\n                }\n                // calling the tool class to send http requests\n                RegisterUtils.doRegister(GsonUtils.getInstance().toJson(t), concat, type, accessToken);\n                return;\n            } catch (Exception e) {\n                LOGGER.error("Register admin url :{} is fail, will retry. cause:{}", server, e.getMessage());\n                if (i == serverList.size()) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Serialize the data and send it via OkHttp."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\npublic final class RegisterUtils {\n   \n   //...... \n\n    // Sending data via OkHttp\n    public static void doRegister(final String json, final String url, final String type) throws IOException {\n        if (!StringUtils.hasLength(accessToken)) {\n            LOGGER.error("{} client register error accessToken is null, please check the config : {} ", type, json);\n            return;\n        }\n        Headers headers = new Headers.Builder().add(Constants.X_ACCESS_TOKEN, accessToken).build();\n        String result = OkHttpTools.getInstance().post(url, json, headers);\n        if (Objects.equals(SUCCESS, result)) {\n            LOGGER.info("{} client register success: {} ", type, json);\n        } else {\n            LOGGER.error("{} client register error: {} ", type, json);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"At this point, the logic of the client registering metadata by means of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," is finished. To summarize: construct metadata by reading custom annotation information, send the data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, then consume the data from the queue, put the consumer into the thread pool to execute, and finally send an ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," request to the ",(0,r.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,r.kt)("p",null,"Similarly, ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientURIExecutorSubscriber")," is the execution class of registering ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," information."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientURIExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The main logic is to iterate through the URI data collection and implement data registration through the persistURI() method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\npublic class ShenyuClientURIExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\n    \n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.URI; \n    }\n    \n    // register URI\n    @Override\n    public void executor(final Collection<URIRegisterDTO> dataList) {\n        for (URIRegisterDTO uriRegisterDTO : dataList) {\n            Stopwatch stopwatch = Stopwatch.createStarted();\n            while (true) {\n                try (Socket ignored = new Socket(uriRegisterDTO.getHost(), uriRegisterDTO.getPort())) {\n                    break;\n                } catch (IOException e) {\n                    long sleepTime = 1000;\n                    // maybe the port is delay exposed\n                    if (stopwatch.elapsed(TimeUnit.SECONDS) > 5) {\n                        LOG.error("host:{}, port:{} connection failed, will retry",\n                                uriRegisterDTO.getHost(), uriRegisterDTO.getPort());\n                        // If the connection fails for a long time, Increase sleep time\n                        if (stopwatch.elapsed(TimeUnit.SECONDS) > 180) {\n                            sleepTime = 10000;\n                        }\n                    }\n                    try {\n                        TimeUnit.MILLISECONDS.sleep(sleepTime);\n                    } catch (InterruptedException ex) {\n                        ex.printStackTrace();\n                    }\n                }\n            }\n            ShenyuClientShutdownHook.delayOtherHooks();\n            \n            shenyuClientRegisterRepository.persistURI(uriRegisterDTO);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"while(true)")," loop in the code is to ensure that the client has been successfully started and can connect via ",(0,r.kt)("inlineCode",{parentName:"p"},"host")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"port"),"."),(0,r.kt)("p",null,"The logic behind it is: add the ",(0,r.kt)("inlineCode",{parentName:"p"},"hook")," function for gracefully stopping the client ."),(0,r.kt)("p",null,"Data registration is achieved through the ",(0,r.kt)("inlineCode",{parentName:"p"},"persistURI()")," method. The whole logic is also analyzed in the previous section, and ultimately it is the ",(0,r.kt)("inlineCode",{parentName:"p"},"OkHttp")," client that initiates ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," and registers the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," by way of ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),"."),(0,r.kt)("p",null,"The analysis of the registration logic of the client is finished here, and the metadata and URI data constructed are sent to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, from which they are then consumed, read, and sent to ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),"."),(0,r.kt)("p",null,"The source code analysis of the client-side metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," registration process is complete, with the following flow chart."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(52009).Z})),(0,r.kt)("h3",{id:"3-server-side-registration-process"},"3. Server-side registration process"),(0,r.kt)("h4",{id:"31-shenyuhttpregistrycontroller"},"3.1 ShenyuHttpRegistryController"),(0,r.kt)("p",null,"From the previous analysis, we know that the server side provides two interfaces for registration."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-metadata"),": The interface provided by the server side is used to register metadata."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"/shenyu-client/register-uri"),": The server-side interface is provided for registering URIs.")),(0,r.kt)("p",null,"These two interfaces are located in ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuHttpRegistryController"),", which implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuServerRegisterRepository")," interface and is the implementation class for server-side registration. It is marked with ",(0,r.kt)("inlineCode",{parentName:"p"},"@Join")," to indicate loading via ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@RequestMapping("/shenyu-client")\n@Join\npublic class ShenyuHttpRegistryController implements ShenyuServerRegisterRepository {\n\n    private ShenyuServerRegisterPublisher publisher;\n\n    @Override\n    public void init(final ShenyuServerRegisterPublisher publisher, final ShenyuRegisterCenterConfig config) {\n        this.publisher = publisher;\n    }\n    \n    // register Metadata\n    @PostMapping("/register-metadata")\n    @ResponseBody\n    public String registerMetadata(@RequestBody final MetaDataRegisterDTO metaDataRegisterDTO) {\n        publisher.publish(metaDataRegisterDTO);\n        return ShenyuResultMessage.SUCCESS;\n    }\n        \n   // register URI\n    @PostMapping("/register-uri")\n    @ResponseBody\n    public String registerURI(@RequestBody final URIRegisterDTO uriRegisterDTO) {\n        publisher.publish(uriRegisterDTO);\n        return ShenyuResultMessage.SUCCESS;\n    }\n}\n\n')),(0,r.kt)("p",null,"The exact method used is specified by the configuration file and then loaded via ",(0,r.kt)("inlineCode",{parentName:"p"},"SPI"),"."),(0,r.kt)("p",null,"In the ",(0,r.kt)("inlineCode",{parentName:"p"},"application.yml")," file in ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin")," configure the registration method, ",(0,r.kt)("inlineCode",{parentName:"p"},"registerType")," specify the registration type, when registering with ",(0,r.kt)("inlineCode",{parentName:"p"},"http"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"serverLists")," do not need to be filled in, for more configuration instructions you can refer to the official website ",(0,r.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/user-guide/register-center-access"},"Client Access Configuration"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"shenyu:\n  register:\n    registerType: http \n    serverLists: \n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterCenterConfiguration ")),(0,r.kt)("p",null,"After introducing the relevant dependencies and properties configuration, when starting ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyu-admin"),", the configuration file will be loaded first, and the configuration file class related to the registration center is ",(0,r.kt)("inlineCode",{parentName:"p"},"RegisterCenterConfiguration"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'@Configuration\npublic class RegisterCenterConfiguration {\n    @Bean\n    @ConfigurationProperties(prefix = "shenyu.register")\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\n        return new ShenyuRegisterCenterConfig();\n    }\n    \n    //create ShenyuServerRegisterRepository to register in admin\n    @Bean(destroyMethod = "close")\n    public ShenyuServerRegisterRepository shenyuServerRegisterRepository(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig, final List<ShenyuClientRegisterService> shenyuClientRegisterService) {\n        // 1. get the registration type from the configuration property\n        String registerType = shenyuRegisterCenterConfig.getRegisterType();\n        // 2. load the implementation class by registering the type with the SPI method\n        ShenyuServerRegisterRepository registerRepository = ExtensionLoader.getExtensionLoader(ShenyuServerRegisterRepository.class).getJoin(registerType);\n        // 3. get the publisher and write data to the Disruptor queue\n        RegisterServerDisruptorPublisher publisher = RegisterServerDisruptorPublisher.getInstance();\n        // 4. ShenyuClientRegisterService, rpcType -> registerService\n        Map<String, ShenyuClientRegisterService> registerServiceMap = shenyuClientRegisterService.stream().collect(Collectors.toMap(ShenyuClientRegisterService::rpcType, e -> e));\n        // 5. start publisher\n        publisher.start(registerServiceMap);\n        // 6. init registerRepository\n        registerRepository.init(publisher, shenyuRegisterCenterConfig);\n        return registerRepository;\n    }\n}\n\n')),(0,r.kt)("p",null,"Two ",(0,r.kt)("inlineCode",{parentName:"p"},"bean"),"s are generated in the configuration class."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"shenyuRegisterCenterConfig"),": to read the attribute configuration.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("inlineCode",{parentName:"p"},"shenyuServerRegisterRepository"),": for server-side registration."))),(0,r.kt)("p",null,"In the process of creating ",(0,r.kt)("inlineCode",{parentName:"p"},"shenyuServerRegisterRepository"),", a series of preparations are also performed."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"get the registration type from the configuration property."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:2},(0,r.kt)("li",{parentName:"ol"},"Load the implementation class by the registration type with the ",(0,r.kt)("inlineCode",{parentName:"li"},"SPI")," method: for example, if the specified type is ",(0,r.kt)("inlineCode",{parentName:"li"},"http"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuHttpRegistryController")," will be loaded."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:3},(0,r.kt)("li",{parentName:"ol"},"Get ",(0,r.kt)("inlineCode",{parentName:"li"},"publisher")," and write data to the ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:4},(0,r.kt)("li",{parentName:"ol"},"Register ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"rpcType -> registerService"),": get the registered ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),", each ",(0,r.kt)("inlineCode",{parentName:"li"},"rpc")," has a corresponding ",(0,r.kt)("inlineCode",{parentName:"li"},"Service"),". The client for this article is built through ",(0,r.kt)("inlineCode",{parentName:"li"},"springboot"),", which belongs to the ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," type, and other client types: ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Spring Cloud"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC"),", etc."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:5},(0,r.kt)("li",{parentName:"ol"},"Preparation for event publishing: add server-side metadata and ",(0,r.kt)("inlineCode",{parentName:"li"},"URI")," subscribers, process the data. And start the ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue."))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:6},(0,r.kt)("li",{parentName:"ol"},"Initialization operation for registration: ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," type registration initialization operation is to save ",(0,r.kt)("inlineCode",{parentName:"li"},"publisher"),".")))),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"RegisterClientServerDisruptorPublisher#publish()")),(0,r.kt)("p",null,"The server-side publisher that writes data to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue , built via the singleton pattern."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class RegisterClientServerDisruptorPublisher implements ShenyuServerRegisterPublisher {\n    private static final RegisterClientServerDisruptorPublisher INSTANCE = new     private static final RegisterClientServerDisruptorPublisher INSTANCE = new RegisterServerDisruptorPublisher();\n();\n\n    public static RegisterClientServerDisruptorPublisher getInstance() {\n        return INSTANCE;\n    }\n    \n   //prepare for event publishing, add server-side metadata and URI subscribers, process data. And start the Disruptor queue.\n    public void start(final Map<String, ShenyuClientRegisterService> shenyuClientRegisterService) {\n        RegisterServerExecutorFactory factory = new RegisterServerExecutorFactory();\n        // add URI data subscriber\n        factory.addSubscribers(new URIRegisterExecutorSubscriber(shenyuClientRegisterService));\n        // add Metadata subscriber\n        factory.addSubscribers(new MetadataExecutorSubscriber(shenyuClientRegisterService));\n        //start Disruptor\n        providerManage = new DisruptorProviderManage(factory);\n        providerManage.startup();\n    }\n    \n    // write data to queue\n    @Override\n    public <T> void publish(final DataTypeParent data) {\n        DisruptorProvider<Object> provider = providerManage.getProvider();\n        provider.onData(Collections.singleton(data));\n    }\n\n    // write data to queue on batch\n    @Override\n    public void publish(final Collection<? extends DataTypeParent> dataList) {\n        DisruptorProvider<Collection<DataTypeParent>> provider = providerManage.getProvider();\n        provider.onData(dataList.stream().map(DataTypeParent.class::cast).collect(Collectors.toList()));\n    }\n    \n    @Override\n    public void close() {\n        providerManage.getProvider().shutdown();\n    }\n}\n")),(0,r.kt)("p",null,"The loading of the configuration file, which can be seen as the initialization process of the registry server, is described in the following diagram."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(99019).Z})),(0,r.kt)("h4",{id:"32-queueconsumer"},"3.2 QueueConsumer"),(0,r.kt)("p",null,"In the previous analysis of the client-side ",(0,r.kt)("inlineCode",{parentName:"p"},"disruptor")," queue consumption of data over. The server side has the same logic, except that the executor performing the task changes."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," is a consumer that implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface, which is created in the ",(0,r.kt)("inlineCode",{parentName:"p"},"providerManage.startup()")," logic. The ",(0,r.kt)("inlineCode",{parentName:"p"},"WorkHandler")," interface is the data consumption interface for ",(0,r.kt)("inlineCode",{parentName:"p"},"disruptor"),", and the only method is ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"package com.lmax.disruptor;\n\npublic interface WorkHandler<T> {\n    void onEvent(T var1) throws Exception;\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumer")," overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"onEvent()")," method, and the main logic is to generate the consumption task and then go to the thread pool to execute it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * \n * QueueConsumer\n */\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\n    \n    // ......\n\n    @Override\n    public void onEvent(final DataEvent<T> t) {\n        if (t != null) {\n            // Use different thread pools based on DataEvent type\n            ThreadPoolExecutor executor = orderly(t);\n            // create queue consumption tasks via factory\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\n            // set data\n            queueConsumerExecutor.setData(t.getData());\n            // help gc\n            t.setData(null);\n            // put in the thread pool to execute the consumption task\n            executor.execute(queueConsumerExecutor);\n        }\n    }\n}\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," is the task that is executed in the thread pool, it implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface, and there are two specific implementation classes."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterClientConsumerExecutor"),": the client-side consumer executor."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor"),": server-side consumer executor.")),(0,r.kt)("p",null,"As the name implies, one is responsible for handling client-side tasks and one is responsible for handling server-side tasks."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RegisterServerConsumerExecutor#run()"))),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"RegisterServerConsumerExecutor")," is a server-side consumer executor that indirectly implements the ",(0,r.kt)("inlineCode",{parentName:"p"},"Runnable")," interface via ",(0,r.kt)("inlineCode",{parentName:"p"},"QueueConsumerExecutor")," and overrides the ",(0,r.kt)("inlineCode",{parentName:"p"},"run()")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'\npublic final class RegisterServerConsumerExecutor extends QueueConsumerExecutor<List<DataTypeParent>> {\n   // ...\n\n    @Override\n    public void run() {\n        //get the data from the disruptor queue and check data\n        Collection<DataTypeParent> results = getData()\n                .stream()\n                .filter(this::isValidData)\n                .collect(Collectors.toList());\n        if (CollectionUtils.isEmpty(results)) {\n            return;\n        }\n        //execute operations according to type\n        getType(results).executor(results);\n    }\n    \n    // get subscribers by type\n    private ExecutorSubscriber<DataTypeParent> selectExecutor(final Collection<DataTypeParent> list) {\n        final Optional<DataTypeParent> first = list.stream().findFirst();\n        return subscribers.get(first.orElseThrow(() -> new RuntimeException("the data type is not found")).getType());\n    }\n}\n\n')),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ExecutorSubscriber#executor()")),(0,r.kt)("p",null,"The actuator subscribers are divided into two categories, one that handles metadata and one that handles ",(0,r.kt)("inlineCode",{parentName:"p"},"URIs"),". There are two on the client side and two on the server side, so there are four in total."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(60797).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"MetadataExecutorSubscriber#executor()")),(0,r.kt)("p",null,"In case of registering metadata, this is achieved by ",(0,r.kt)("inlineCode",{parentName:"p"},"MetadataExecutorSubscriber#executor()"),": get the registered ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," according to the type and call ",(0,r.kt)("inlineCode",{parentName:"p"},"register()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class MetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\n \n    //......\n\n    @Override\n    public DataType getType() {\n        return DataType.META_DATA; \n    }\n\n    @Override\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\n        // Traversing the metadata list\n        metaDataRegisterDTOList.forEach(meta -> {\n            Optional.ofNullable(this.shenyuClientRegisterService.get(meta.getRpcType())) // Get registered Service by type\n                    .ifPresent(shenyuClientRegisterService -> {\n                        // Registration of metadata, locking to ensure sequential execution and prevent concurrent errors\n                        synchronized (shenyuClientRegisterService) {\n                            shenyuClientRegisterService.register(meta);\n                        }\n                    });\n        });\n    }\n}\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"URIRegisterExecutorSubscriber#executor()")),(0,r.kt)("p",null,"In case of registration metadata, this is achieved by ",(0,r.kt)("inlineCode",{parentName:"p"},"URIRegisterExecutorSubscriber#executor()"),": construct ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, find ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," according to the registration type, and achieve registration by the ",(0,r.kt)("inlineCode",{parentName:"p"},"registerURI")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"\npublic class URIRegisterExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\n    //......\n    \n    @Override\n    public DataType getType() {\n        return DataType.URI; \n    }\n    \n    @Override\n    public void executor(final Collection<URIRegisterDTO> dataList) {\n        if (CollectionUtils.isEmpty(dataList)) {\n            return;\n        }\n        \n        findService(dataList).ifPresent(service -> {\n            Map<String, List<URIRegisterDTO>> listMap = buildData(dataList);\n            listMap.forEach(service::registerURI);\n        });\n        final Map<String, List<URIRegisterDTO>> groupByRpcType = dataList.stream()\n                .filter(data -> StringUtils.isNotBlank(data.getRpcType()))\n                .collect(Collectors.groupingBy(URIRegisterDTO::getRpcType));\n        for (Map.Entry<String, List<URIRegisterDTO>> entry : groupByRpcType.entrySet()) {\n            final String rpcType = entry.getKey();\n            // Get registered Service by type\n            Optional.ofNullable(shenyuClientRegisterService.get(rpcType))\n                    .ifPresent(service -> {\n                        final List<URIRegisterDTO> list = entry.getValue();\n                        // Build URI data types and register them with the registerURI method\n                        Map<String, List<URIRegisterDTO>> listMap = buildData(list);\n                        listMap.forEach(service::registerURI);\n                    });\n        }\n    }\n    \n    // Find Service by type\n    private Optional<ShenyuClientRegisterService> findService(final Collection<URIRegisterDTO> dataList) {\n        return dataList.stream().map(dto -> shenyuClientRegisterService.get(dto.getRpcType())).findFirst();\n    }\n}\n\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ShenyuClientRegisterService#register()")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterService")," is the registration method interface, which has several implementation classes."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(76122).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AbstractContextPathRegisterService"),": abstract class, handling part of the public logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"AbstractShenyuClientRegisterServiceImpl"),": : abstract class, handles part of the public logic."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterDivideServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"divide")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterDubboServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"dubbo")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterGrpcServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"gRPC")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterMotanServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Motan")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Motan")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterSofaServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Sofa")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Sofa")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterSpringCloudServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"SpringCloud")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"SpringCloud")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterTarsServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"li"},"Tars")," class, handles ",(0,r.kt)("inlineCode",{parentName:"li"},"Tars")," registration types."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ShenyuClientRegisterWebSocketServiceImpl"),"\uff1a ",(0,r.kt)("inlineCode",{parentName:"li"},"Websocket")," class\uff0chandles ",(0,r.kt)("inlineCode",{parentName:"li"},"Websocket")," registration types.")),(0,r.kt)("p",null,"From the above, we can see that each microservice has a corresponding registration implementation class. The source code analysis in this article is based on the official ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/incubator-shenyu/tree/master/shenyu-examples/shenyu-examples-http"},"shenyu-examples-http")," as an example, it is of ",(0,r.kt)("inlineCode",{parentName:"p"},"http")," registration type, so the registration implementation class for metadata and URI data is ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterDivideServiceImpl"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"ShenyuClientRegisterDivideServiceImpl"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"register(): ")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public abstract class AbstractShenyuClientRegisterServiceImpl extends FallbackShenyuClientRegisterService implements ShenyuClientRegisterService {\n\n    //......\n\n    public String register(final MetaDataRegisterDTO dto) {\n        // 1.register selector information\n        String selectorHandler = selectorHandler(dto);\n        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);\n        // 2.register rule information\n        String ruleHandler = ruleHandler();\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\n        ruleService.registerDefault(ruleDTO);\n        // 3.register metadata information\n        registerMetadata(dto);\n        // 4.register contextPath\n        String contextPath = dto.getContextPath();\n        if (StringUtils.isNotEmpty(contextPath)) {\n            registerContextPath(dto);\n        }\n        return ShenyuResultMessage.SUCCESS;\n    }\n}\n")),(0,r.kt)("p",null,"The whole registration logic can be divided into 4 steps."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},"Register selector information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:2},(0,r.kt)("li",{parentName:"ol"},"Register rule information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:3},(0,r.kt)("li",{parentName:"ol"},"Register metadata information"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("ol",{parentName:"li",start:4},(0,r.kt)("li",{parentName:"ol"},"Register `contextPath")))),(0,r.kt)("p",null,"This side of ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," requires the construction of selectors, rules, metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"ContextPath")," through the metadata information of the client. The specific registration process and details of processing are related to the ",(0,r.kt)("inlineCode",{parentName:"p"},"rpc")," type. We will not continue to track down the logical analysis of the registration center, tracking to this point is enough."),(0,r.kt)("p",null,"The source code of the server-side metadata registration process is analyzed and the flow chart is described as follows."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(25808).Z})),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"registerURI()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public abstract class AbstractShenyuClientRegisterServiceImpl extends FallbackShenyuClientRegisterService implements ShenyuClientRegisterService {\n\n    //......\n\n    public String registerURI(final String selectorName, final List<URIRegisterDTO> uriList) {\n        if (CollectionUtils.isEmpty(uriList)) {\n            return "";\n        }\n        // Does the corresponding selector exist\n        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\n        if (Objects.isNull(selectorDO)) {\n            return "";\n        }\n        // Handle handler information in the selector\n        String handler = buildHandle(uriList, selectorDO);\n        selectorDO.setHandle(handler);\n        SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\n        selectorData.setHandle(handler);\n\n        // Update records in the database\n        selectorService.updateSelective(selectorDO);\n        // publish Event to gateway\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));\n        return ShenyuResultMessage.SUCCESS;\n    }\n}\n')),(0,r.kt)("p",null,"After ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," gets the ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data, it mainly updates the ",(0,r.kt)("inlineCode",{parentName:"p"},"handler")," information in the selector, then writes it to the database, and finally publishes the event notification gateway. The logic of notifying the gateway is done by the data synchronization operation, which has been analyzed in the previous article, so we will not repeat it."),(0,r.kt)("p",null,"The source code analysis of the server-side ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," registration process is complete and is described in the following diagram."),(0,r.kt)("p",null,(0,r.kt)("img",{src:n(33844).Z})),(0,r.kt)("p",null,"At this point, the server-side registration process is also analyzed, mainly through the interface provided externally, accept the registration information from the client, and then write to the ",(0,r.kt)("inlineCode",{parentName:"p"},"Disruptor")," queue, and then consume data from it, and update the ",(0,r.kt)("inlineCode",{parentName:"p"},"admin")," selector, rules, metadata and selector ",(0,r.kt)("inlineCode",{parentName:"p"},"handler")," according to the received metadata and ",(0,r.kt)("inlineCode",{parentName:"p"},"URI")," data."),(0,r.kt)("h3",{id:"4-summary"},"4. Summary"),(0,r.kt)("p",null,"This article focuses on the ",(0,r.kt)("inlineCode",{parentName:"p"},"http registration")," module of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Apache ShenYu")," gateway for source code analysis. The main knowledge points involved are summarized as follows."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The register center is for registering client information to ",(0,r.kt)("inlineCode",{parentName:"li"},"admin")," to facilitate traffic filtering."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"http")," registration is to register client metadata information and ",(0,r.kt)("inlineCode",{parentName:"li"},"URI")," information to ",(0,r.kt)("inlineCode",{parentName:"li"},"admin"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"http")," service access is identified by the annotation ",(0,r.kt)("inlineCode",{parentName:"li"},"@ShenyuSpringMvcClient"),"."),(0,r.kt)("li",{parentName:"ul"},"construction of the registration information mainly through the application listener ",(0,r.kt)("inlineCode",{parentName:"li"},"ApplicationListener"),"."),(0,r.kt)("li",{parentName:"ul"},"loading of the registration type is done through ",(0,r.kt)("inlineCode",{parentName:"li"},"SPI"),"."),(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"Disruptor")," queue was introduced to decouple data from operations, and data buffering."),(0,r.kt)("li",{parentName:"ul"},"The implementation of the registry uses interface-oriented programming, using design patterns such as template methods, singleton, and observer.")))}c.isMDXComponent=!0},52009:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-metadata-uri-register-en-7ccc8df4fc77fdf28480f15a6de6022b.png"},98557:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-init-en-782b6467880bcb85cee72f2beba708c5.png"},79568:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-repository-61756e3284c1d3a27083b25d393edf9c.png"},76122:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/client-register-service-949e3110cb57db2f250dafdc41446eb4.png"},5847:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/consumer-executor-f7ad67d35abaa5a2fac94ef913445a19.png"},60797:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/executor-subscriber-86d5645d204ad1d05fe12dd30992c8d1.png"},34177:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/register-center-en-d38e8150e48eec9bef3727dbadc124ec.png"},25808:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-metadata-register-en-8290907a57a1189a4b5863f3c47254bb.png"},99019:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-register-init-en-c20ecd9991817e159730a8aea38db110.png"},33844:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/server-uri-register-en-6026d791dbc404cadee04b237add0691.png"},87570:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-client-event-listener-0cd56409c59f2546a285a6426f9c8fee.png"},47868:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-client-register-repository-dba8edf50af1be31d8b53c9573b1e015.png"},10318:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-register-center-en-732853d1dc114c56034d14f70e92be06.png"},13210:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/shenyu-register-center-http-en-2bf3e3a1e2c72d3fca6059fae46886f8.png"}}]);