"use strict";(self.webpackChunkshenyu_website=self.webpackChunkshenyu_website||[]).push([[33051],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=c(n),h=i,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||l;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,r=new Array(l);r[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var c=2;c<l;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},58200:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>r,default:()=>d,frontMatter:()=>l,metadata:()=>o,toc:()=>s});var a=n(87462),i=(n(67294),n(3905));const l={title:"Etcd Data Synchronization Source Code Analysis",author:"4zd",author_title:"Apache ShenYu Contributor",author_url:"https://github.com/4zd",tags:["etcd","data sync","Apache ShenYu"]},r=void 0,o={permalink:"/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync",editUrl:"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync.md",source:"@site/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync.md",title:"Etcd Data Synchronization Source Code Analysis",description:"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.",date:"2022-11-26T22:45:59.515Z",formattedDate:"November 26, 2022",tags:[{label:"etcd",permalink:"/blog/tags/etcd"},{label:"data sync",permalink:"/blog/tags/data-sync"},{label:"Apache ShenYu",permalink:"/blog/tags/apache-shen-yu"}],readingTime:17.25,truncated:!1,nextItem:{title:"Http Long Polling Data Synchronization Source Code Analysis",permalink:"/blog/DataSync-SourceCode-Analysis-Http-Data-Sync"}},s=[{value:"1. About Etcd",id:"1-about-etcd",children:[]},{value:"2. Admin Data Sync",id:"2-admin-data-sync",children:[]},{value:"3. Gateway Data Sync",id:"3-gateway-data-sync",children:[]},{value:"4. Admin Data Sync  initialization",id:"4-admin-data-sync--initialization",children:[]},{value:"5. Gateway Data Sync Init",id:"5-gateway-data-sync-init",children:[]},{value:"6. Summary",id:"6-summary",children:[]}],c={toc:s};function d(e){let{components:t,...l}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/zh/docs/index"},"Apache ShenYu")," is an asynchronous, high-performance, cross-language, responsive API gateway.")),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for ",(0,i.kt)("inlineCode",{parentName:"p"},"ZooKeeper"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"WebSocket"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"http long poll"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Nacos"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"Etcd")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Consul"),". The main content of this article is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"Etcd")," data synchronization source code analysis."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This paper based on ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu-2.4.0")," version of the source code analysis, the official website of the introduction of please refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://shenyu.apache.org/docs/design/data-sync/"},"Data Synchronization Design")," .")),(0,i.kt)("h3",{id:"1-about-etcd"},"1. About Etcd"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://etcd.io"},"Etcd")," is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines."),(0,i.kt)("h3",{id:"2-admin-data-sync"},"2. Admin Data Sync"),(0,i.kt)("p",null,"We traced the source code from a real case, such as updating a selector data in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Divide")," plugin to a weight of 90 in a background administration system:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(55519).Z})),(0,i.kt)("h4",{id:"21-accept-data"},"2.1 Accept Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SelectorController.createSelector()")),(0,i.kt)("p",null,"Enter the createSelector() method of the ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorController")," class, which validates data, adds or updates data, and returns results."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'@Validated\n@RequiredArgsConstructor\n@RestController\n@RequestMapping("/selector")\npublic class SelectorController {\n    \n    @PutMapping("/{id}")\n    public ShenyuAdminResult updateSelector(@PathVariable("id") final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {\n        // set the current selector data ID\n        selectorDTO.setId(id);\n        // create or update operation\n        Integer updateCount = selectorService.createOrUpdate(selectorDTO);\n        // return result \n        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);\n    }\n    \n    // ......\n}\n')),(0,i.kt)("h4",{id:"22-handle-data"},"2.2 Handle Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SelectorServiceImpl.createOrUpdate()")),(0,i.kt)("p",null,"Convert data in the ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorServiceImpl")," class using the ",(0,i.kt)("inlineCode",{parentName:"p"},"createOrUpdate()")," method, save it to the database, publish the event, update ",(0,i.kt)("inlineCode",{parentName:"p"},"upstream"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@RequiredArgsConstructor\n@Service\npublic class SelectorServiceImpl implements SelectorService {\n    // eventPublisher\n    private final ApplicationEventPublisher eventPublisher;\n    \n    @Override\n    @Transactional(rollbackFor = Exception.class)\n    public int createOrUpdate(final SelectorDTO selectorDTO) {\n        int selectorCount;\n        // build data DTO --\x3e DO\n        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\n        List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\n        // insert or update ?\n        if (StringUtils.isEmpty(selectorDTO.getId())) {\n            //  insert into data\n            selectorCount = selectorMapper.insertSelective(selectorDO);\n            // insert into condition data\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\n            });\n            // check selector add\n            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() > 0) {\n                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();\n                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());\n                dataPermissionDTO.setDataId(selectorDO.getId());\n                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);\n                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));\n            }\n\n        } else {\n            // update data, delete and then insert\n            selectorCount = selectorMapper.updateSelective(selectorDO);\n            //delete rule condition then add\n            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\n                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);\n                selectorConditionMapper.insertSelective(selectorConditionDO);\n            });\n        }\n        // publish event\n        publishEvent(selectorDO, selectorConditionDTOs);\n\n        // update upstream\n        updateDivideUpstream(selectorDO);\n        return selectorCount;\n    }\n    \n    // ......\n    \n}\n")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"Service")," class to persist data, i.e. to the database, this should be familiar, not expand. The update upstream operation is analyzed in the corresponding section below, focusing on the publish event operation, which performs data synchronization."),(0,i.kt)("p",null,"The logic of the ",(0,i.kt)("inlineCode",{parentName:"p"},"publishEvent()"),"  method is to find the plugin corresponding to the selector, build the conditional data, and publish the change data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"       private void publishEvent(final SelectorDO selectorDO, final List<SelectorConditionDTO> selectorConditionDTOs) {\n        // find plugin of selector\n        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\n        // build condition data\n        List<ConditionData> conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());\n        // publish event\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\n                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));\n    }\n")),(0,i.kt)("p",null,"Change data released by ",(0,i.kt)("inlineCode",{parentName:"p"},"eventPublisher.PublishEvent()")," is complete, the ",(0,i.kt)("inlineCode",{parentName:"p"},"eventPublisher")," object is a ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEventPublisher")," class, The fully qualified class name is ",(0,i.kt)("inlineCode",{parentName:"p"},"org.springframework.context.ApplicationEventPublisher"),". Here we see that publishing data is done through ",(0,i.kt)("inlineCode",{parentName:"p"},"Spring")," related functionality."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEventPublisher"),"\uff1a"),(0,i.kt)("p",{parentName:"blockquote"},"When a state change, the publisher calls ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEventPublisher")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"publishEvent")," method to release an event, ",(0,i.kt)("inlineCode",{parentName:"p"},"Spring")," container broadcast event for all observers, The observer's ",(0,i.kt)("inlineCode",{parentName:"p"},"onApplicationEvent")," method is called to pass the event object to the observer. There are two ways to call ",(0,i.kt)("inlineCode",{parentName:"p"},"publishEvent")," method, one is to implement the interface by the container injection ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEventPublisher")," object and then call the method, the other is a direct call container, the method of two methods of publishing events not too big difference."),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ApplicationEventPublisher"),": publish event;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ApplicationEvent"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"Spring")," event, record the event source, time, and data;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ApplicationListener"),": event listener, observer."))),(0,i.kt)("p",null,"In Spring event publishing mechanism, there are three objects,"),(0,i.kt)("p",null,"An object is a publish event ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEventPublisher"),", in ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," through the constructor in the injected a ",(0,i.kt)("inlineCode",{parentName:"p"},"eventPublisher"),"."),(0,i.kt)("p",null,"The other object is ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationEvent")," , inherited from ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," through ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedEvent"),", representing the event object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class DataChangedEvent extends ApplicationEvent {\n//......\n}\n")),(0,i.kt)("p",null,"The last object is ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationListener")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," in through ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedEventDispatcher")," class implements this interface, as the event listener, responsible for handling the event object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@Component\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\n\n    //......\n    \n}\n")),(0,i.kt)("h4",{id:"23-dispatch-data"},"2.3 Dispatch Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"DataChangedEventDispatcher.onApplicationEvent()")),(0,i.kt)("p",null,"Released when the event is completed, will automatically enter the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedEventDispatcher")," class ",(0,i.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()")," method of handling events."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'@Component\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\n\n  /**\n     * This method is called when there are data changes\n   * @param event\n     */\n    @Override\n    @SuppressWarnings("unchecked")\n    public void onApplicationEvent(final DataChangedEvent event) {\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\n      for (DataChangedListener listener : listeners) {\n            // What kind of data has changed\n        switch (event.getGroupKey()) {\n                case APP_AUTH: // app auth data\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\n                    break;\n                case PLUGIN:  // plugin data\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\n                    break;\n                case RULE:    // rule data\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\n                    break;\n                case SELECTOR:   // selector data\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\n                    break;\n                case META_DATA:  // metadata\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\n                    break;\n                default:  // other types throw exception\n                  throw new IllegalStateException("Unexpected value: " + event.getGroupKey());\n            }\n        }\n    }\n    \n}\n')),(0,i.kt)("p",null,"When there is a data change, the ",(0,i.kt)("inlineCode",{parentName:"p"},"onApplicationEvent")," method is called and all the data change listeners are iterated to determine the data type and handed over to the appropriate data listener for processing."),(0,i.kt)("p",null,"ShenYu groups all the data into five categories: ",(0,i.kt)("inlineCode",{parentName:"p"},"APP_AUTH"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"PLUGIN"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"RULE"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECTOR")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"META_DATA"),"."),(0,i.kt)("p",null,"Here the data change listener (",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedListener"),") is an abstraction of the data synchronization policy. Its concrete implementation is:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(24668).Z})),(0,i.kt)("p",null,"These implementation classes are the synchronization strategies currently supported by ShenYu:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"WebsocketDataChangedListener"),": data synchronization based on Websocket;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ZookeeperDataChangedListener"),":data synchronization based on Zookeeper;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ConsulDataChangedListener"),": data synchronization based on Consul;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"EtcdDataDataChangedListener"),"\uff1adata synchronization based on etcd;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"HttpLongPollingDataChangedListener"),"\uff1adata synchronization based on http long polling;"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"NacosDataChangedListener"),"\uff1adata synchronization based on nacos;")),(0,i.kt)("p",null,"Given that there are so many implementation strategies, how do you decide which to use?"),(0,i.kt)("p",null,"Because this paper is based on ",(0,i.kt)("inlineCode",{parentName:"p"},"Etcd")," data synchronization source code analysis, so here to ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdDataDataChangedListener")," as an example, the analysis of how it is loaded and implemented."),(0,i.kt)("p",null,"A global search in the source code project shows that its implementation is done in the ",(0,i.kt)("inlineCode",{parentName:"p"},"DataSyncConfiguration")," class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'/**\n * Data Sync Configuration\n * By springboot conditional assembly\n * The type Data sync configuration.\n */\n@Configuration\npublic class DataSyncConfiguration {\n    \n    \n    /**\n     * The type Etcd listener.\n     */\n    @Configuration\n    @ConditionalOnProperty(prefix = "shenyu.sync.etcd", name = "url")\n    @EnableConfigurationProperties(EtcdProperties.class)\n    static class EtcdListener {\n\n        @Bean\n        public EtcdClient etcdClient(final EtcdProperties etcdProperties) {\n            Client client = Client.builder()\n                    .endpoints(etcdProperties.getUrl())\n                    .build();\n            return new EtcdClient(client);\n        }\n\n        /**\n         * Config event listener data changed listener.\n         *\n         * @param etcdClient the etcd client\n         * @return the data changed listener\n         */\n        @Bean\n        @ConditionalOnMissingBean(EtcdDataDataChangedListener.class)\n        public DataChangedListener etcdDataChangedListener(final EtcdClient etcdClient) {\n            return new EtcdDataDataChangedListener(etcdClient);\n        }\n\n        /**\n         * data init.\n         *\n         * @param etcdClient        the etcd client\n         * @param syncDataService the sync data service\n         * @return the etcd data init\n         */\n        @Bean\n        @ConditionalOnMissingBean(EtcdDataInit.class)\n        public EtcdDataInit etcdDataInit(final EtcdClient etcdClient, final SyncDataService syncDataService) {\n            return new EtcdDataInit(etcdClient, syncDataService);\n        }\n    }\n    \n    // other code is omitted......\n}\n\n')),(0,i.kt)("p",null,"This configuration class is implemented through the SpringBoot conditional assembly class. The ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdListener")," class has several annotations:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"@Configuration"),": Configuration file, application context;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},'@ConditionalOnProperty(prefix = "shenyu.sync.etcd", name = "url")'),": attribute condition. The configuration class takes effect only when the condition is met. That is, when we have the following configuration, ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," is used for data synchronization."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-properties"},"shenyu:  \n  sync:\n     etcd:\n          url: localhost:2181\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"@EnableConfigurationProperties(EtcdProperties.class)"),"\uff1aimport ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdProperties"),"; The properties in the class ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdProperties")," is relative to the properties which is with ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu.sync.etcd")," as prefix in the configuration file."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},' @Data\n@ConfigurationProperties(prefix = "shenyu.sync.etcd")\npublic class EtcdProperties {\n\n  private String url;\n\n  private Integer sessionTimeout;\n\n  private Integer connectionTimeout;\n\n  private String serializer;\n}\n')),(0,i.kt)("p",null,"When the ",(0,i.kt)("inlineCode",{parentName:"p"},"shenyu.sync.etcd.url")," property is set in the configuration file, ",(0,i.kt)("inlineCode",{parentName:"p"},"Admin")," would use the ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," data synchronization, ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdListener")," is generated and the beans with type ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdClient"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdDataDataChangedListener")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdDataInit")," would also be generated. "),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The bean with the type ",(0,i.kt)("inlineCode",{parentName:"li"},"EtcdClient")," would be generated, named ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdClient"),". This bean configues the connection properties of the ",(0,i.kt)("inlineCode",{parentName:"li"},"etcd")," server based on the configuration file and can operate the ",(0,i.kt)("inlineCode",{parentName:"li"},"etcd"),"nodes directly."),(0,i.kt)("li",{parentName:"ul"},"The bean with the type ",(0,i.kt)("inlineCode",{parentName:"li"},"EtcdDataDataChangedListener")," would be generated, named ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdDataDataChangedListener"),".  This bean use the bean ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdClient")," as a member variable and so when the event is listened, ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdDataDataChangedListener")," would call the callback method and use the ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdClient"),"  to operate the ",(0,i.kt)("inlineCode",{parentName:"li"},"etcd")," nodes."),(0,i.kt)("li",{parentName:"ul"},"The bean with the type ",(0,i.kt)("inlineCode",{parentName:"li"},"EtcdDataInit")," would be generated, named ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdDataInit"),". This bean use the bean ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdClient")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"syncDataService")," as member variables, and use ",(0,i.kt)("inlineCode",{parentName:"li"},"etcdClient")," to judge whether the data are initialized, if not, would use ",(0,i.kt)("inlineCode",{parentName:"li"},"syncDataService")," to refresh data. We would dive into the details later.       ")),(0,i.kt)("p",null,"So in the event handler ",(0,i.kt)("inlineCode",{parentName:"p"},"onApplicationEvent()"),", it goes to the corresponding ",(0,i.kt)("inlineCode",{parentName:"p"},"listener"),". In our case, it is a selector data update, data synchronization is ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),", so, the code will enter the ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdDataDataChangedListener")," selector data change process."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'    @Override\n    @SuppressWarnings("unchecked")\n    public void onApplicationEvent(final DataChangedEvent event) {\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\n        for (DataChangedListener listener : listeners) {\n            // what kind of data has changed\n         switch (event.getGroupKey()) {\n                    \n                // other code logic is omitted\n                    \n                case SELECTOR:   // selector data\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());   // In our case, will enter the EtcdDataDataChangedListener selector data change process\n                    break;\n         }\n    }\n')),(0,i.kt)("h4",{id:"24-etcd-data-changed-listener"},"2.4 Etcd Data Changed Listener"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"EtcdDataDataChangedListener.onSelectorChanged()")),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"onSelectorChanged()")," method, determine the type of action, whether to refresh synchronization or update or create synchronization. Determine whether the node is in ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," based on the current selector data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"\n/**\n * EtcdDataDataChangedListener.\n */\n@Slf4j\npublic class EtcdDataDataChangedListener implements DataChangedListener {\n    @Override\n    public void onSelectorChanged(final List<SelectorData> changed, final DataEventTypeEnum eventType) {\n        if (eventType == DataEventTypeEnum.REFRESH && !changed.isEmpty()) {\n            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());\n            etcdClient.deleteEtcdPathRecursive(selectorParentPath);\n        }\n        for (SelectorData data : changed) {\n            String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());\n            if (eventType == DataEventTypeEnum.DELETE) {\n                etcdClient.delete(selectorRealPath);\n                continue;\n            }\n            //create or update\n            updateNode(selectorRealPath, data);\n        }\n    }\n  \n}\n")),(0,i.kt)("p",null,"This part is very important. The variable ",(0,i.kt)("inlineCode",{parentName:"p"},"changed")," represents the ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorData")," list, the variable ",(0,i.kt)("inlineCode",{parentName:"p"},"eventType")," reprents the event type. When the event type is ",(0,i.kt)("inlineCode",{parentName:"p"},"REFRESH")," and the ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorData")," has changed, all the ",(0,i.kt)("inlineCode",{parentName:"p"},"selector")," nodes under this ",(0,i.kt)("inlineCode",{parentName:"p"},"plugin")," would be deleted in ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),". We should notice that the condition that the ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorData")," has changed is necessary, otherwise a bug would appear that all the selector nodes would be deleted when no ",(0,i.kt)("inlineCode",{parentName:"p"},"SelectorData")," data has changed. "),(0,i.kt)("p",null,"As long as the changed data is correctly written to the ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," node, the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," side of the operation is complete. "),(0,i.kt)("p",null,"In our current case, updating one of the selector data in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Divide")," plugin with a weight of 90 updates specific nodes in the graph."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(83780).Z})),(0,i.kt)("p",null,"We series the above update flow with a sequence diagram."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(28801).Z})),(0,i.kt)("h3",{id:"3-gateway-data-sync"},"3. Gateway Data Sync"),(0,i.kt)("p",null,"Assume that the ShenYu gateway is already running properly, and the data synchronization mode is also ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),". How does the gateway receive and process the selector data after updating it on the admin side and sending the changed data to etcd? Let's continue our source code analysis to find out."),(0,i.kt)("h4",{id:"31-etcdclient-accept-data"},"3.1 EtcdClient Accept Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"EtcdClient.watchDataChange()")),(0,i.kt)("p",null,"There is a ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdSyncDataService")," class on the gateway, which subscribing to the data node through ",(0,i.kt)("inlineCode",{parentName:"p"},"etcdClient")," and can sense when the data changes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Data synchronize of etcd.\n */\n@Slf4j\npublic class EtcdSyncDataService implements SyncDataService, AutoCloseable {\n    private void subscribeSelectorDataChanges(final String path) {\n      etcdClient.watchDataChange(path, (updateNode, updateValue) -> cacheSelectorData(updateValue),\n              this::unCacheSelectorData);\n    }\n  //other codes omitted\n}\n")),(0,i.kt)("p",null,"Etcd's  ",(0,i.kt)("inlineCode",{parentName:"p"},"Watch")," mechanism notifies subscribing clients of node changes. In our case, updating the selector information goes to the ",(0,i.kt)("inlineCode",{parentName:"p"},"watchDataChange()")," method. ",(0,i.kt)("inlineCode",{parentName:"p"},"cacheSelectorData()")," is used to process data."),(0,i.kt)("h4",{id:"32-handle-data"},"3.2 Handle Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"EtcdSyncDataService.cacheSelectorData()")),(0,i.kt)("p",null,"The data is not null, and caching the selector data is again handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"PluginDataSubscriber"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"    private void cacheSelectorData(final SelectorData selectorData) {\n        Optional.ofNullable(selectorData)\n                .ifPresent(data -> Optional.ofNullable(pluginDataSubscriber).ifPresent(e -> e.onSelectorSubscribe(data)));\n    }\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"PluginDataSubscriber")," is an interface, it is only a ",(0,i.kt)("inlineCode",{parentName:"p"},"CommonPluginDataSubscriber")," implementation class, responsible for data processing plugin, selector and rules."),(0,i.kt)("h4",{id:"33-common-plugin-data-subscriber"},"3.3 Common Plugin Data Subscriber"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PluginDataSubscriber.onSelectorSubscribe()")),(0,i.kt)("p",null,"It has no additional logic and calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"subscribeDataHandler()")," method directly. Within methods, there are data types (plugins, selectors, or rules) and action types (update or delete) to perform different logic."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * The common plugin data subscriber, responsible for handling all plug-in, selector, and rule information\n */\npublic class CommonPluginDataSubscriber implements PluginDataSubscriber {\n    //......\n     // handle selector data\n    @Override\n    public void onSelectorSubscribe(final SelectoData selectorData) {\n        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);\n    }    \n    \n    // A subscription data handler that handles updates or deletions of data\n    private <T> void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {\n        Optional.ofNullable(classData).ifPresent(data -> {\n            // plugin data\n            if (data instanceof PluginData) {\n                PluginData pluginData = (PluginData) data;\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\n                    // save the data to gateway memory\n                     BaseDataCache.getInstance().cachePluginData(pluginData);\n                    // If each plugin has its own processing logic, then do it\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.handlerPlugin(pluginData));\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\n                    // delete the data from gateway memory\n                    BaseDataCache.getInstance().removePluginData(pluginData);\n                    // If each plugin has its own processing logic, then do it\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.removePlugin(pluginData));\n                }\n            } else if (data instanceof SelectorData) {  // selector data\n                SelectorData selectorData = (SelectorData) data;\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\n                    // save the data to gateway memory\n                    BaseDataCache.getInstance().cacheSelectData(selectorData);\n                    // If each plugin has its own processing logic, then do it \n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\n                    // delete the data from gateway memory\n                    BaseDataCache.getInstance().removeSelectData(selectorData);\n                    // If each plugin has its own processing logic, then do it\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.removeSelector(selectorData));\n                }\n            } else if (data instanceof RuleData) {  // rule data\n                RuleData ruleData = (RuleData) data;\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\n                    // save the data to gateway memory\n                    BaseDataCache.getInstance().cacheRuleData(ruleData);\n                    // If each plugin has its own processing logic, then do it\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.handlerRule(ruleData));\n                } else if (dataType == DataEventTypeEnum.DELETE) { // delete\n                    // delete the data from gateway memory\n                    BaseDataCache.getInstance().removeRuleData(ruleData);\n                    // If each plugin has its own processing logic, then do it\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.removeRule(ruleData));\n                }\n            }\n        });\n    }\n    \n}\n")),(0,i.kt)("h4",{id:"34-data-cached-to-memory"},"3.4 Data cached to Memory"),(0,i.kt)("p",null,"Adding a selector will enter the following logic:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"// save the data to gateway memory\nBaseDataCache.getInstance().cacheSelectData(selectorData);\n// If each plugin has its own processing logic, then do it\nOptional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\n")),(0,i.kt)("p",null,"One is to save the data to the gateway's memory. BaseDataCache is the class that ultimately caches data, implemented in a singleton pattern. The selector data is stored in the ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECTOR_MAP")," Map. In the subsequent use, also from this data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public final class BaseDataCache {\n    // private instance\n    private static final BaseDataCache INSTANCE = new BaseDataCache();\n    // private constructor\n    private BaseDataCache() {\n    }\n    \n    /**\n     * Gets instance.\n     *  public method\n     * @return the instance\n     */\n    public static BaseDataCache getInstance() {\n        return INSTANCE;\n    }\n    \n    /**\n      * A Map of the cache selector data\n     * pluginName -> SelectorData.\n     */\n    private static final ConcurrentMap<String, List<SelectorData>> SELECTOR_MAP = Maps.newConcurrentMap();\n    \n    public void cacheSelectData(final SelectorData selectorData) {\n        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);\n    }\n        \n   /**\n     * cache selector data.\n     * @param data the selector data\n     */\n    private void selectorAccept(final SelectorData data) {\n        String key = data.getPluginName();\n        if (SELECTOR_MAP.containsKey(key)) { // Update operation, delete before insert\n            List<SelectorData> existList = SELECTOR_MAP.get(key);\n            final List<SelectorData> resultList = existList.stream().filter(r -> !r.getId().equals(data.getId())).collect(Collectors.toList());\n            resultList.add(data);\n            final List<SelectorData> collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());\n            SELECTOR_MAP.put(key, collect);\n        } else {  // Add new operations directly to Map\n            SELECTOR_MAP.put(key, Lists.newArrayList(data));\n        }\n    }\n    \n}\n")),(0,i.kt)("p",null,"Second, if each plugin has its own processing logic, then do it. Through the ",(0,i.kt)("inlineCode",{parentName:"p"},"IDEA")," editor, you can see that after adding a selector, there are the following plugins and processing. We're not going to expand it here."),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(59469).Z})),(0,i.kt)("p",null,"After the above source tracking, and through a practical case, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," end to update a selector data, the ",(0,i.kt)("inlineCode",{parentName:"p"},"ZooKeeper")," data synchronization process analysis is clear."),(0,i.kt)("p",null,"Let's series the data synchronization process on the gateway side through the sequence diagram:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(11548).Z})),(0,i.kt)("p",null,"The data synchronization process has been analyzed. In order to prevent the synchronization process from being interrupted, other logic is ignored during the analysis. We also need to analyze the process of Admin synchronization data initialization and gateway synchronization operation initialization."),(0,i.kt)("h3",{id:"4-admin-data-sync--initialization"},"4. Admin Data Sync  initialization"),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"admin")," starts, the current data will be fully synchronized to ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),", the implementation logic is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'\n/**\n * EtcdDataInit.\n */\n@Slf4j\npublic class EtcdDataInit implements CommandLineRunner {\n\n  private final EtcdClient etcdClient;\n\n  private final SyncDataService syncDataService;\n\n  public EtcdDataInit(final EtcdClient client, final SyncDataService syncDataService) {\n    this.etcdClient = client;\n    this.syncDataService = syncDataService;\n  }\n\n  @Override\n  public void run(final String... args) throws Exception {\n    final String pluginPath = DefaultPathConstants.PLUGIN_PARENT;\n    final String authPath = DefaultPathConstants.APP_AUTH_PARENT;\n    final String metaDataPath = DefaultPathConstants.META_DATA;\n    if (!etcdClient.exists(pluginPath) && !etcdClient.exists(authPath) && !etcdClient.exists(metaDataPath)) {\n      log.info("Init all data from database");\n      syncDataService.syncAll(DataEventTypeEnum.REFRESH);\n    }\n  }\n}\n\n')),(0,i.kt)("p",null,"Check whether there is data in ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),", if not, then synchronize."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EtcdDataInit")," implements the ",(0,i.kt)("inlineCode",{parentName:"p"},"CommandLineRunner")," interface. It is an interface provided by ",(0,i.kt)("inlineCode",{parentName:"p"},"SpringBoot")," that executes the ",(0,i.kt)("inlineCode",{parentName:"p"},"run()")," method after all ",(0,i.kt)("inlineCode",{parentName:"p"},"Spring Beans")," initializations and is often used for initialization operations in a project."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"SyncDataService.syncAll()")),(0,i.kt)("p",null,"Query data from the database, and then perform full data synchronization, all authentication information, plugin information, selector information, rule information, and metadata information. Synchronous events are published primarily through ",(0,i.kt)("inlineCode",{parentName:"p"},"eventPublisher"),". After publishing the event via ",(0,i.kt)("inlineCode",{parentName:"p"},"publishEvent()"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplicationListener")," performs the event change operation. In ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu")," is mentioned in ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedEventDispatcher"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"@Service\npublic class SyncDataServiceImpl implements SyncDataService {\n    // eventPublisher\n    private final ApplicationEventPublisher eventPublisher;\n    \n     /***\n     * sync all data\n     * @param type the type\n     * @return\n     */\n    @Override\n    public boolean syncAll(final DataEventTypeEnum type) {\n        // app auth data\n        appAuthService.syncData();\n        // plugin data\n        List<PluginData> pluginDataList = pluginService.listAll();\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));\n        // selector data\n        List<SelectorData> selectorDataList = selectorService.listAll();\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));\n        // rule data\n        List<RuleData> ruleDataList = ruleService.listAll();\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));\n        // metadata\n        metaDataService.syncData();\n        return true;\n    }\n    \n}\n")),(0,i.kt)("h3",{id:"5-gateway-data-sync-init"},"5. Gateway Data Sync Init"),(0,i.kt)("p",null,"The initial operation of data synchronization on the gateway side is mainly the node in the subscription ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),". When there is a data change, the changed data will be received. This relies on the ",(0,i.kt)("inlineCode",{parentName:"p"},"Watch")," mechanism of ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd"),". In ",(0,i.kt)("inlineCode",{parentName:"p"},"ShenYu"),", the one responsible for ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," data synchronization is ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdSyncDataService"),", also mentioned earlier."),(0,i.kt)("p",null,"The function logic of ",(0,i.kt)("inlineCode",{parentName:"p"},"EtcdSyncDataService")," is completed in the process of instantiation: the subscription to ",(0,i.kt)("inlineCode",{parentName:"p"},"Shenyu")," data synchronization node in ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," is completed. Subscription here is divided into two kinds, one kind is existing node data updated above, through this ",(0,i.kt)("inlineCode",{parentName:"p"},"etcdClient.subscribeDataChanges()")," method; Another kind is under the current node, add or delete nodes change namely child nodes, it through ",(0,i.kt)("inlineCode",{parentName:"p"},"etcdClient.subscribeChildChanges()")," method."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EtcdSyncDataService")," code is a bit too much, here we use plugin data read and subscribe to track, other types of data operation principle is the same."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"/**\n * Data synchronize of etcd.\n */\n@Slf4j\npublic class EtcdSyncDataService implements SyncDataService, AutoCloseable {\n    /**\n     * Instantiates a new Zookeeper cache manager.\n     *\n     * @param etcdClient             the etcd client\n     * @param pluginDataSubscriber the plugin data subscriber\n     * @param metaDataSubscribers  the meta data subscribers\n     * @param authDataSubscribers  the auth data subscribers\n     */\n    public EtcdSyncDataService(final EtcdClient etcdClient, final PluginDataSubscriber pluginDataSubscriber,\n                                    final List<MetaDataSubscriber> metaDataSubscribers, final List<AuthDataSubscriber> authDataSubscribers) {\n        this.etcdClient = etcdClient;\n        this.pluginDataSubscriber = pluginDataSubscriber;\n        this.metaDataSubscribers = metaDataSubscribers;\n        this.authDataSubscribers = authDataSubscribers;\n        watcherData();\n        watchAppAuth();\n        watchMetaData();\n    }\n\n    private void watcherData() {\n        final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;\n        List<String> pluginZKs = etcdClientGetChildren(pluginParent);\n        for (String pluginName : pluginZKs) {\n            watcherAll(pluginName);\n        }\n\n        etcdClient.watchChildChange(pluginParent, (updateNode, updateValue) -> {\n            if (!updateNode.isEmpty()) {\n                watcherAll(updateNode);\n            }\n        }, null);\n    }\n\n    private void watcherAll(final String pluginName) {\n        watcherPlugin(pluginName);\n        watcherSelector(pluginName);\n        watcherRule(pluginName);\n    }\n\n    private void watcherPlugin(final String pluginName) {\n        String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);\n        cachePluginData(etcdClient.get(pluginPath));\n        subscribePluginDataChanges(pluginPath, pluginName);\n    }\n\n    private void cachePluginData(final String dataString) {\n        final PluginData pluginData = GsonUtils.getInstance().fromJson(dataString, PluginData.class);\n        Optional.ofNullable(pluginData)\n                .flatMap(data -> Optional.ofNullable(pluginDataSubscriber)).ifPresent(e -> e.onSubscribe(pluginData));\n    }\n\n    private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {\n    etcdClient.watchDataChange(pluginPath, (updatePath, updateValue) -> {\n      final String dataPath = buildRealPath(pluginPath, updatePath);\n      final String dataStr = etcdClient.get(dataPath);\n      final PluginData data = GsonUtils.getInstance().fromJson(dataStr, PluginData.class);\n      Optional.ofNullable(data)\n              .ifPresent(d -> Optional.ofNullable(pluginDataSubscriber).ifPresent(e -> e.onSubscribe(d)));\n    }, deleteNode -> deletePlugin(pluginName));\n  }\n  \n}\n\n")),(0,i.kt)("p",null,"The above source code is given comments, I believe you can understand. The main logic for subscribing to plug-in data is as follows:"),(0,i.kt)("blockquote",null,(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},"Create the current plugin path"),(0,i.kt)("li",{parentName:"ol"},"Read the current node data on etcd and deserialize it"),(0,i.kt)("li",{parentName:"ol"},"The plugin data is cached in the gateway memory"),(0,i.kt)("li",{parentName:"ol"},"Subscribe to the plug-in node"))),(0,i.kt)("h3",{id:"6-summary"},"6. Summary"),(0,i.kt)("p",null,"This paper through a practical case, ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," data synchronization principle source code analysis. The main knowledge points involved are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Data synchronization based on ",(0,i.kt)("inlineCode",{parentName:"p"},"etcd")," is mainly implemented through ",(0,i.kt)("inlineCode",{parentName:"p"},"watch")," mechanism;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Complete event publishing and listening via ",(0,i.kt)("inlineCode",{parentName:"p"},"Spring"),";")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Support multiple synchronization strategies through abstract ",(0,i.kt)("inlineCode",{parentName:"p"},"DataChangedListener")," interface, interface oriented programming;")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Use singleton design pattern to cache data class ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseDataCache"),";")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Loading of configuration classes via conditional assembly of ",(0,i.kt)("inlineCode",{parentName:"p"},"SpringBoot")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"starter")," loading mechanism."))))}d.isMDXComponent=!0},28801:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/etcd-sync-sequence-admin-en-29e7ea74b69fcc2faa148fc0459fc16d.png"},11548:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/etcd-sync-sequence-gateway-en-4da1d7160168a3ee75741e84d7298e0d.png"},24668:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"},59469:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"},55519:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/update-selector-en-4efb58e488bd424a54213d31929d7eb1.png"},83780:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/zookeeper-node-c7628b680a1f1afa0eada97b66fcd5b1.png"}}]);