"use strict";(globalThis.webpackChunkshenyu_website=globalThis.webpackChunkshenyu_website||[]).push([[95894],{76042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/DataSync-SourceCode-Analysis-Apollo-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-Apollo-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Apollo-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-Apollo-Data-Sync.md","title":"Apollo Data Synchronization Source Code Analysis","description":"This article is based on the source code analysis of version \'shenyu-2.6.1\'. Please refer to the official website for an introduction Data Synchronization Design.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"apollo","permalink":"/blog/tags/apollo"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":11.975,"hasTruncateMarker":false,"authors":[{"name":"hql0312","title":"Apache ShenYu Contributor","url":"https://github.com/hql0312"}],"frontMatter":{"title":"Apollo Data Synchronization Source Code Analysis","author":"hql0312","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/hql0312","tags":["apollo","data sync","Apache ShenYu"]},"unlisted":false,"nextItem":{"title":"Etcd Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync"}},"content":"> This article is based on the source code analysis of version \'shenyu-2.6.1\'. Please refer to the official website for an introduction [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/).\\n\\n### Admin management\\n\\nUnderstand the overall process through the process of adding plugins\\n\\n![](/img/activities/code-analysis-apollo-data-sync/Apollo-Sync.png)\\n\\n### Receive Data\\n\\n- PluginController.createPlugin()\\n\\nEnter the `createPlugin()` method in the `PluginController` class, which is responsible for data validation, adding or updating data, and returning result information.\\n\\n```java\\n@Validated\\n@RequiredArgsConstructor\\n@RestController\\n@RequestMapping(\\"/plugin\\")\\npublic class PluginController {\\n\\n  @PostMapping(\\"\\")\\n  @RequiresPermissions(\\"system:plugin:add\\")\\n  public ShenyuAdminResult createPlugin(@Valid @ModelAttribute final PluginDTO pluginDTO) {\\n      // Call pluginService.createOrUpdate for processing logic\\n      return ShenyuAdminResult.success(pluginService.createOrUpdate(pluginDTO));\\n  }\\n    \\n    // ......\\n}\\n```\\n\\n### Processing data\\n\\n- PluginServiceImpl.createOrUpdate() -> PluginServiceImpl.create()\\n\\nUse the `create()` method in the `PluginServiceImpl` class to convert data, save it to the database, and publish events.\\n\\n```java\\n@RequiredArgsConstructor\\n@Service\\npublic class PluginServiceImpl implements SelectorService {\\n    // Event publishing object pluginEventPublisher\\n    private final PluginEventPublisher pluginEventPublisher;\\n\\n   private String create(final PluginDTO pluginDTO) {\\n      // Check if there is a corresponding plugin\\n      Assert.isNull(pluginMapper.nameExisted(pluginDTO.getName()), AdminConstants.PLUGIN_NAME_IS_EXIST);\\n      // check if Customized plugin jar\\n      if (!Objects.isNull(pluginDTO.getFile())) {\\n        Assert.isTrue(checkFile(Base64.decode(pluginDTO.getFile())), AdminConstants.THE_PLUGIN_JAR_FILE_IS_NOT_CORRECT_OR_EXCEEDS_16_MB);\\n      }\\n      // Create plugin object\\n      PluginDO pluginDO = PluginDO.buildPluginDO(pluginDTO);\\n      // Insert object into database\\n      if (pluginMapper.insertSelective(pluginDO) > 0) {\\n        // publish create event. init plugin data\\n        pluginEventPublisher.onCreated(pluginDO);\\n      }\\n      return ShenyuResultMessage.CREATE_SUCCESS;\\n  }\\n    \\n    \\n    // ......\\n    \\n}\\n\\n```\\n\\nComplete the data persistence operation in the `PluginServiceImpl` class, that is, save the data to the database and publish events through `pluginEventPublisher`.\\n\\nThe logic of the `pluginEventPublisher.onCreated` method is to publish the changed event:\\n\\n```java\\n    @Override\\npublic void onCreated(final PluginDO plugin) {\\n        // Publish DataChangeEvent events: event grouping (plugins, selectors, rules), event types (create, delete, update), changed data\\n        publisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, DataEventTypeEnum.CREATE,\\n        Collections.singletonList(PluginTransfer.INSTANCE.mapToData(plugin))));\\n        // Publish PluginCreatedEvent\\n        publish(new PluginCreatedEvent(plugin, SessionUtil.visitorName()));\\n}\\n```\\n\\nPublishing change data is completed through `publisher.publishEvent()`, which is an \'Application EventPublisher\' object with the fully qualified name of \'org. springframework. contentxt.\' Application EventPublisher `. From here, we know that publishing data is accomplished through the Spring related features.\\n\\n> About `ApplicationEventPublisher`\uff1a\\n>\\n> When there is a state change, the publisher calls the `publishEvent` method of `ApplicationEventPublisher` to publish an event, the `Spring` container broadcasts the event to all observers, and calls the observer\'s `onApplicationEvent` method to pass the event object to the observer. There are two ways to call the `publishEvent` method. One is to implement the interface, inject the `ApplicationEventPublisher` object into the container, and then call its method. The other is to call the container directly. There is not much difference between the two methods to publish events.\\n>\\n> - `ApplicationEventPublisher`\uff1aPublish events\uff1b\\n> - `ApplicationEvent`\uff1a`Spring` events\uff0cRecord the source, time, and data of the event;\\n> - `ApplicationListener`\uff1aEvent listeners, observers;\\n\\n\\nIn the event publishing mechanism of Spring, there are three objects,\\n\\nOne is the `ApplicationEventPublisher` that publishes events, injecting an `publisher` through a constructor in `ShenYu`.\\n\\nThe other object is `ApplicationEvent`, which is inherited from `ShenYu` through `DataChangedEvent`, representing the event object\\n\\n```java\\npublic class DataChangedEvent extends ApplicationEvent {\\n//......\\n}\\n```\\n\\nThe last one is `ApplicationListener`, which is implemented in `ShenYu` through the `DataChangedEventDispatcher` class as a listener for events, responsible for handling event objects.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n    //......\\n    \\n}\\n```\\n\\n### Distribute data\\n\\n- DataChangedEventDispatcher.onApplicationEvent()\\n\\nAfter the event is published, it will automatically enter the `onApplicationEvent()` method in the `DataChangedEventDispatcher` class for event processing.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  /**\\n     * When there is a data change, call this method\\n     * @param event\\n     */\\n  @Override\\n  @SuppressWarnings(\\"unchecked\\")\\n  public void onApplicationEvent(final DataChangedEvent event) {\\n    // Traverse data change listeners (only ApolloDataChangedListener will be registered here)\\n    for (DataChangedListener listener : listeners) {\\n      // Forward according to different grouping types\\n      switch (event.getGroupKey()) {\\n        case APP_AUTH: // authentication information\\n          listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n          break;\\n        case PLUGIN: // Plugin events\\n          // Calling the registered listener object\\n          listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n          break;\\n        case RULE: // Rule events\\n          listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n          break;\\n        case SELECTOR: // Selector event\\n          listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n          break;\\n        case META_DATA: // Metadata events\\n          listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n          break;\\n        case PROXY_SELECTOR: // Proxy selector event\\n          listener.onProxySelectorChanged((List<ProxySelectorData>) event.getSource(), event.getEventType());\\n          break;\\n        case DISCOVER_UPSTREAM: // Registration discovery of downstream list events\\n          listener.onDiscoveryUpstreamChanged((List<DiscoverySyncData>) event.getSource(), event.getEventType());\\n          applicationContext.getBean(LoadServiceDocEntry.class).loadDocOnUpstreamChanged((List<DiscoverySyncData>) event.getSource(), event.getEventType());\\n          break;\\n        default:\\n          throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n      }\\n    }\\n  }\\n    \\n}\\n```\\n\\nWhen there is a data change, call the `onApplicationEvent` method, then traverse all data change listeners, determine which data type it is, and hand it over to the corresponding data listeners for processing.\\n\\n`ShenYu` has grouped all data into the following types: authentication information, plugin information, rule information, selector information, metadata, proxy selector, and downstream event discovery.\\n\\nThe Data Change Listener here is an abstraction of the data synchronization strategy, processed by specific implementations, and different listeners are processed by different implementations. Currently, Apollo is being analyzed\\nListening, so here we only focus on `ApolloDataChangedListener`.\\n\\n```java\\n// Inheriting AbstractNodeDataChangedListener\\npublic class ApolloDataChangedListener extends AbstractNodeDataChangedListener {\\n    \\n}\\n```\\n\\n`ApolloDataChangedListener` inherits the `AbstractNodeDataChangedListener` class, which mainly uses key as the base class for storage, such as Apollo, Nacos, etc., while others such as Zookeeper\\nConsul, etc. are searched in a hierarchical manner using a path.\\n\\n```java\\n// Using key as the base class for finding storage methods\\npublic abstract class AbstractNodeDataChangedListener implements DataChangedListener { \\n    \\n    protected AbstractNodeDataChangedListener(final ChangeData changeData) {\\n      this.changeData = changeData;\\n    }\\n}\\n```\\n\\n`AbstractNodeDataChangedListener` receives ChangeData as a parameter, which defines the key names for each data stored in Apollo. The data stored in Apollo includes the following data:\\n- Plugin(plugin)\\n- Selector(selector)\\n- Rules(rule)\\n- Authorization(auth)\\n- Metadata(meta)\\n- Proxy selector(proxy.selector)\\n- Downstream List (discovery)\\n\\nThese information are specified by the ApolloDataChangedListener constructor:\\n\\n```java\\npublic class ApolloDataChangedListener extends AbstractNodeDataChangedListener {\\n  public ApolloDataChangedListener(final ApolloClient apolloClient) {\\n    // Configure prefixes for several types of grouped data\\n    super(new ChangeData(ApolloPathConstants.PLUGIN_DATA_ID,\\n            ApolloPathConstants.SELECTOR_DATA_ID,\\n            ApolloPathConstants.RULE_DATA_ID,\\n            ApolloPathConstants.AUTH_DATA_ID,\\n            ApolloPathConstants.META_DATA_ID,\\n            ApolloPathConstants.PROXY_SELECTOR_DATA_ID,\\n            ApolloPathConstants.DISCOVERY_DATA_ID));\\n    // Manipulating objects of Apollo\\n    this.apolloClient = apolloClient;\\n  }\\n}\\n```\\n\\n`DataChangedListener` defines the following methods:\\n\\n```java\\n// Data Change Listener\\npublic interface DataChangedListener {\\n\\n    // Call when authorization information changes\\n    default void onAppAuthChanged(List<AppAuthData> changed, DataEventTypeEnum eventType) {\\n    }\\n\\n    // Called when plugin information changes\\n    default void onPluginChanged(List<PluginData> changed, DataEventTypeEnum eventType) {\\n    }\\n\\n    // Called when selector information changes\\n    default void onSelectorChanged(List<SelectorData> changed, DataEventTypeEnum eventType) {\\n    }\\n    \\n     // Called when metadata information changes\\n    default void onMetaDataChanged(List<MetaData> changed, DataEventTypeEnum eventType) {\\n\\n    }\\n\\n    // Call when rule information changes\\n    default void onRuleChanged(List<RuleData> changed, DataEventTypeEnum eventType) {\\n    }\\n\\n    // Called when proxy selector changes\\n    default void onProxySelectorChanged(List<ProxySelectorData> changed, DataEventTypeEnum eventType) {\\n    }\\n    // Called when downstream information changes are discovered\\n    default void onDiscoveryUpstreamChanged(List<DiscoverySyncData> changed, DataEventTypeEnum eventType) {\\n    }\\n\\n}\\n```\\n\\nWhen the plugin is processed by `DataChangedEventDispatcher`, the method `listener.onPluginChanged` is called. Next, analyze the logic of the object and implement the processing by `AbstractNodeDataChangedListener`:\\n\\n```java\\npublic abstract class AbstractNodeDataChangedListener implements DataChangedListener {\\n  @Override\\n  public void onPluginChanged(final List<PluginData> changed, final DataEventTypeEnum eventType) {\\n    //Configure prefix as plugin.\\n    final String configKeyPrefix = changeData.getPluginDataId() + DefaultNodeConstants.JOIN_POINT;\\n    this.onCommonChanged(configKeyPrefix, changed, eventType, PluginData::getName, PluginData.class);\\n    LOG.debug(\\"[DataChangedListener] PluginChanged {}\\", configKeyPrefix);\\n  }\\n}\\n```\\n\\nFirstly, the key prefix for constructing configuration data is: `plugin.`, Call `onCommonChanged` again for unified processing:\\n\\n```java\\nprivate <T> void onCommonChanged(final String configKeyPrefix, final List<T> changedList,\\n                                     final DataEventTypeEnum eventType, final Function<? super T, ? extends String> mapperToKey,\\n                                     final Class<T> tClass) {\\n        // Avoiding concurrent operations on list nodes\\n        final ReentrantLock reentrantLock = listSaveLockMap.computeIfAbsent(configKeyPrefix, key -> new ReentrantLock());\\n        try {\\n            reentrantLock.lock();\\n            // Current incoming plugin list\\n            final List<String> changeNames = changedList.stream().map(mapperToKey).collect(Collectors.toList());\\n            switch (eventType) {\\n                // Delete Operation\\n                case DELETE:\\n                    // delete plugin.${pluginName}\\n                    changedList.stream().map(mapperToKey).forEach(removeKey -> {\\n                        delConfig(configKeyPrefix + removeKey);\\n                    });\\n                    // Remove the corresponding plugin name from plugin. list\\n                    // The plugin.list records the currently enabled list\\n                    delChangedData(configKeyPrefix, changeNames);\\n                    break;\\n                case REFRESH:\\n                case MYSELF:\\n                    // Overload logic\\n                    // Get a list of all plugins in plugin.list\\n                    final List<String> configDataNames = this.getConfigDataNames(configKeyPrefix);\\n                    // Update each currently adjusted plug-in in turn\\n                    changedList.forEach(changedData -> {\\n                        // Publish Configuration\\n                        publishConfig(configKeyPrefix + mapperToKey.apply(changedData), changedData);\\n                    });\\n                    // If there is more data in the currently stored list than what is currently being passed in, delete the excess data\\n                    if (configDataNames != null && configDataNames.size() > changedList.size()) {\\n                        // Kick out the currently loaded data\\n                        configDataNames.removeAll(changeNames);\\n                        // Delete cancelled data one by one\\n                        configDataNames.forEach(this::delConfig);\\n                    }\\n                    // Update list data again\\n                    publishConfig(configKeyPrefix + DefaultNodeConstants.LIST_STR, changeNames);\\n                    break;\\n                default:\\n                    // Add or update\\n                    changedList.forEach(changedData -> {\\n                        publishConfig(configKeyPrefix + mapperToKey.apply(changedData), changedData);\\n                    });\\n                    // Update the newly added plugin\\n                    putChangeData(configKeyPrefix, changeNames);\\n                    break;\\n            }\\n        } catch (Exception e) {\\n            LOG.error(\\"AbstractNodeDataChangedListener onCommonMultiChanged error \\", e);\\n        } finally {\\n            reentrantLock.unlock();\\n        }\\n    }\\n```\\n\\nIn the above logic, it actually includes the handling of full overloading (REFRESH, MYSELF) and increment (Delete, UPDATE, CREATE)\\n\\nThe plugin mainly includes two nodes:\\n- `plugin.list` List of currently effective plugins\\n- `plugin.${plugin.name}` Detailed information on specific plugins\\nFinally, write the data corresponding to these two nodes into Apollo.\\n\\n\\n\\n### Data initialization\\n\\nAfter starting `admin`, the current data information will be fully synchronized to `Apollo`, which is implemented by `ApolloDataChangedInit`:\\n\\n```java\\n// Inheriting AbstractDataChangedInit\\npublic class ApolloDataChangedInit extends AbstractDataChangedInit {\\n    // Apollo operation object\\n    private final ApolloClient apolloClient;\\n    \\n    public ApolloDataChangedInit(final ApolloClient apolloClient) {\\n        this.apolloClient = apolloClient;\\n    }\\n    \\n    @Override\\n    protected boolean notExist() {\\n        // Check if nodes such as plugin, auth, meta, proxy.selector exist\\n        // As long as one does not exist, it enters reload (these nodes will not be created, why check once?)\\n        return Stream.of(ApolloPathConstants.PLUGIN_DATA_ID, ApolloPathConstants.AUTH_DATA_ID, ApolloPathConstants.META_DATA_ID, ApolloPathConstants.PROXY_SELECTOR_DATA_ID).allMatch(\\n                this::dataIdNotExist);\\n    }\\n\\n    /**\\n     * Data id not exist boolean.\\n     *\\n     * @param pluginDataId the plugin data id\\n     * @return the boolean\\n     */\\n    private boolean dataIdNotExist(final String pluginDataId) {\\n        return Objects.isNull(apolloClient.getItemValue(pluginDataId));\\n    }\\n}\\n\\n```\\n\\nCheck if there is data in `apollo`, and if it does not exist, synchronize it.\\nThere is a bug here because the key determined here will not be created during synchronization, which will cause data to be reloaded every time it is restarted. [PR#5435](https://github.com/apache/shenyu/pull/5435)\\n\\n`ApolloDataChangedInit` implements the `CommandLineRunner` interface. It is an interface provided by `springboot` that executes the `run()` method after all `Spring Beans` are initialized. It is commonly used for initialization operations in projects.\\n- SyncDataService.syncAll()\\n\\nQuery data from the database, then perform full data synchronization, including all authentication information, plugin information, rule information, selector information, metadata, proxy selector, and discover downstream events. Mainly, synchronization events are published through `eventPublisher`. After publishing events through `publishEvent()`, `ApplicationListener` performs event change operations, which is referred to as `DataChangedEventDispatcher` in `ShenYu`.\\n\\n```java\\n@Service\\npublic class SyncDataServiceImpl implements SyncDataService {\\n    // Event Publishing\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n     /***\\n     * Full data synchronization\\n     * @param type the type\\n     * @return\\n     */\\n     @Override\\n     public boolean syncAll(final DataEventTypeEnum type) {\\n         // Synchronize auth data\\n         appAuthService.syncData();\\n         // Synchronize plugin data\\n         List<PluginData> pluginDataList = pluginService.listAll();\\n         //Notify subscribers through the Spring publish/subscribe mechanism (publishing DataChangedEvent)\\n         //Unified monitoring by DataChangedEventDispatcher\\n         //DataChangedEvent comes with configuration grouping type, current operation type, and data\\n         eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));\\n         // synchronizing selector\\n         List<SelectorData> selectorDataList = selectorService.listAll();\\n         eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));\\n         // Synchronization rules\\n         List<RuleData> ruleDataList = ruleService.listAll();\\n         eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));\\n         // Synchronization metadata\\n         metaDataService.syncData();\\n         // Synchronization Downstream List\\n         discoveryService.syncData();\\n         return true;\\n     }\\n    \\n}\\n```\\n\\n### Bootstrap synchronization operation initialization\\n\\nThe data synchronization initialization operation on the gateway side mainly involves subscribing to nodes in `apollo`, and receiving changed data when there are changes. This depends on the `listener` mechanism of `apollo`. In `ShenYu`, the person responsible for `Apollo` data synchronization is `ApolloDataService`.\\nThe functional logic of Apollo DataService is completed during the instantiation process: subscribe to the `shenyu` data synchronization node in Apollo. Implement through the `configService.addChangeListener()` method;\\n\\n\\n```java\\npublic class ApolloDataService extends AbstractNodeDataSyncService implements SyncDataService {\\n    public ApolloDataService(final Config configService, final PluginDataSubscriber pluginDataSubscriber,\\n                             final List<MetaDataSubscriber> metaDataSubscribers,\\n                             final List<AuthDataSubscriber> authDataSubscribers,\\n                             final List<ProxySelectorDataSubscriber> proxySelectorDataSubscribers,\\n                             final List<DiscoveryUpstreamDataSubscriber> discoveryUpstreamDataSubscribers) {\\n        // Configure the prefix for listening\\n        super(new ChangeData(ApolloPathConstants.PLUGIN_DATA_ID,\\n                        ApolloPathConstants.SELECTOR_DATA_ID,\\n                        ApolloPathConstants.RULE_DATA_ID,\\n                        ApolloPathConstants.AUTH_DATA_ID,\\n                        ApolloPathConstants.META_DATA_ID,\\n                        ApolloPathConstants.PROXY_SELECTOR_DATA_ID,\\n                        ApolloPathConstants.DISCOVERY_DATA_ID),\\n                pluginDataSubscriber, metaDataSubscribers, authDataSubscribers, proxySelectorDataSubscribers, discoveryUpstreamDataSubscribers);\\n        this.configService = configService;\\n        // Start listening\\n        // Note: The Apollo method is only responsible for obtaining data from Apollo and adding it to the local cache, and does not handle listening\\n        startWatch();\\n        // Configure listening\\n        apolloWatchPrefixes();\\n    }\\n}\\n```\\n\\nFirstly, configure the key information that needs to be processed and synchronize it with the admin\'s key. Next, call the `startWatch()` method to process data acquisition and listening. But in the implementation of Apollo, this method is only responsible for handling data retrieval and setting it to the local cache.\\nListening is handled by the `apolloWatchPrefixes` method\\n\\n```java\\nprivate void apolloWatchPrefixes() {\\n        // Defining Listeners\\n        final ConfigChangeListener listener = changeEvent -> {\\n            changeEvent.changedKeys().forEach(changeKey -> {\\n                try {\\n                    final ConfigChange configChange = changeEvent.getChange(changeKey);\\n                    // Skip if not changed\\n                    if (configChange == null) {\\n                        LOG.error(\\"apollo watchPrefixes error configChange is null {}\\", changeKey);\\n                        return;\\n                    }\\n                    final String newValue = configChange.getNewValue();\\n                    // skip last is \\"list\\"\\n                    // If it is a Key at the end of the list, such as plugin.list, skip it because it is only a list that records the effectiveness and will not be cached locally\\n                    final int lastListStrIndex = changeKey.length() - DefaultNodeConstants.LIST_STR.length();\\n                    if (changeKey.lastIndexOf(DefaultNodeConstants.LIST_STR) == lastListStrIndex) {\\n                        return;\\n                    }\\n                    // If it starts with plugin. => Process plugin data\\n                    if (changeKey.indexOf(ApolloPathConstants.PLUGIN_DATA_ID) == 0) {\\n                        // delete\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            // clear cache\\n                            unCachePluginData(changeKey);\\n                        } else {\\n                            // update cache\\n                            cachePluginData(newValue);\\n                        }\\n                        // If it starts with selector. => Process selector data\\n                    } else if (changeKey.indexOf(ApolloPathConstants.SELECTOR_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheSelectorData(changeKey);\\n                        } else {\\n                            cacheSelectorData(newValue);\\n                        }\\n                        // If it starts with rule. => Process rule data\\n                    } else if (changeKey.indexOf(ApolloPathConstants.RULE_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheRuleData(changeKey);\\n                        } else {\\n                            cacheRuleData(newValue);\\n                        }\\n                      // If it starts with auth. => Process auth data\\n                    } else if (changeKey.indexOf(ApolloPathConstants.AUTH_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheAuthData(changeKey);\\n                        } else {\\n                            cacheAuthData(newValue);\\n                        }\\n                        // If it starts with meta. => Process meta data\\n                    } else if (changeKey.indexOf(ApolloPathConstants.META_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheMetaData(changeKey);\\n                        } else {\\n                            cacheMetaData(newValue);\\n                        }\\n                        // If it starts with proxy.selector. => Process proxy.selector meta\\n                    } else if (changeKey.indexOf(ApolloPathConstants.PROXY_SELECTOR_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheProxySelectorData(changeKey);\\n                        } else {\\n                            cacheProxySelectorData(newValue);\\n                        }\\n                        // If it starts with discovery. => Process discovery meta\\n                    } else if (changeKey.indexOf(ApolloPathConstants.DISCOVERY_DATA_ID) == 0) {\\n                        if (PropertyChangeType.DELETED.equals(configChange.getChangeType())) {\\n                            unCacheDiscoveryUpstreamData(changeKey);\\n                        } else {\\n                            cacheDiscoveryUpstreamData(newValue);\\n                        }\\n                    }\\n                } catch (Exception e) {\\n                    LOG.error(\\"apollo sync listener change key handler error\\", e);\\n                }\\n            });\\n        };\\n        watchConfigChangeListener = listener;\\n        // Add listening\\n        configService.addChangeListener(listener, Collections.emptySet(), ApolloPathConstants.pathKeySet());\\n\\n    }\\n```\\n\\nThe logic of loading data from the previous admin will only add two keys to the plugin: `plugin.list` and `plugin.${plugin.name}`, while `plugin.list` is a list of all enabled plugins, and the data for this key is in the\\nThere is no data in the local cache, only `plugin$\\\\{plugin.name} will be  focus.\\n\\nAt this point, the synchronization logic of bootstrap in `apollo` has been analyzed."},{"id":"/DataSync-SourceCode-Analysis-Etcd-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync.md","title":"Etcd Data Synchronization Source Code Analysis","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"etcd","permalink":"/blog/tags/etcd"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":17.25,"hasTruncateMarker":false,"authors":[{"name":"4zd","title":"Apache ShenYu Contributor","url":"https://github.com/4zd"}],"frontMatter":{"title":"Etcd Data Synchronization Source Code Analysis","author":"4zd","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/4zd","tags":["etcd","data sync","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Apollo Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Apollo-Data-Sync"},"nextItem":{"title":"Http Long Polling Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Http-Data-Sync"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\nIn `ShenYu` gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for `ZooKeeper`, `WebSocket`, `http long poll`, `Nacos`, `Etcd` and `Consul`. The main content of this article is based on `Etcd` data synchronization source code analysis.\\n\\n> This paper based on `shenyu-2.4.0` version of the source code analysis, the official website of the introduction of please refer to the [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/) .\\n\\n### 1. About Etcd\\n\\n[Etcd](https://etcd.io) is a strongly consistent, distributed key-value store that provides a reliable way to store data that needs to be accessed by a distributed system or cluster of machines.\\n\\n### 2. Admin Data Sync\\n\\nWe traced the source code from a real case, such as updating a selector data in the `Divide` plugin to a weight of 90 in a background administration system:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/update-selector-en.png)\\n\\n#### 2.1 Accept Data\\n\\n- SelectorController.createSelector()\\n\\nEnter the createSelector() method of the `SelectorController` class, which validates data, adds or updates data, and returns results.\\n\\n```java\\n@Validated\\n@RequiredArgsConstructor\\n@RestController\\n@RequestMapping(\\"/selector\\")\\npublic class SelectorController {\\n    \\n    @PutMapping(\\"/{id}\\")\\n    public ShenyuAdminResult updateSelector(@PathVariable(\\"id\\") final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {\\n        // set the current selector data ID\\n        selectorDTO.setId(id);\\n        // create or update operation\\n        Integer updateCount = selectorService.createOrUpdate(selectorDTO);\\n        // return result \\n        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n#### 2.2 Handle Data\\n\\n- SelectorServiceImpl.createOrUpdate()\\n\\nConvert data in the `SelectorServiceImpl` class using the `createOrUpdate()` method, save it to the database, publish the event, update `upstream`.\\n\\n```java\\n@RequiredArgsConstructor\\n@Service\\npublic class SelectorServiceImpl implements SelectorService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n    @Override\\n    @Transactional(rollbackFor = Exception.class)\\n    public int createOrUpdate(final SelectorDTO selectorDTO) {\\n        int selectorCount;\\n        // build data DTO --\x3e DO\\n        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n        List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n        // insert or update ?\\n        if (StringUtils.isEmpty(selectorDTO.getId())) {\\n            //  insert into data\\n            selectorCount = selectorMapper.insertSelective(selectorDO);\\n            // insert into condition data\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n            });\\n            // check selector add\\n            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() > 0) {\\n                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();\\n                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());\\n                dataPermissionDTO.setDataId(selectorDO.getId());\\n                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);\\n                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));\\n            }\\n\\n        } else {\\n            // update data, delete and then insert\\n            selectorCount = selectorMapper.updateSelective(selectorDO);\\n            //delete rule condition then add\\n            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);\\n                selectorConditionMapper.insertSelective(selectorConditionDO);\\n            });\\n        }\\n        // publish event\\n        publishEvent(selectorDO, selectorConditionDTOs);\\n\\n        // update upstream\\n        updateDivideUpstream(selectorDO);\\n        return selectorCount;\\n    }\\n    \\n    // ......\\n    \\n}\\n```\\n\\nIn the `Service` class to persist data, i.e. to the database, this should be familiar, not expand. The update upstream operation is analyzed in the corresponding section below, focusing on the publish event operation, which performs data synchronization.\\n\\nThe logic of the `publishEvent()`  method is to find the plugin corresponding to the selector, build the conditional data, and publish the change data.\\n\\n```java\\n       private void publishEvent(final SelectorDO selectorDO, final List<SelectorConditionDTO> selectorConditionDTOs) {\\n        // find plugin of selector\\n        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\\n        // build condition data\\n        List<ConditionData> conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());\\n        // publish event\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\\n                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));\\n    }\\n```\\n\\nChange data released by `eventPublisher.PublishEvent()` is complete, the `eventPublisher` object is a `ApplicationEventPublisher` class, The fully qualified class name is `org.springframework.context.ApplicationEventPublisher`. Here we see that publishing data is done through `Spring` related functionality.\\n\\n> `ApplicationEventPublisher`\uff1a\\n>\\n> When a state change, the publisher calls `ApplicationEventPublisher` of `publishEvent` method to release an event, `Spring` container broadcast event for all observers, The observer\'s `onApplicationEvent` method is called to pass the event object to the observer. There are two ways to call `publishEvent` method, one is to implement the interface by the container injection `ApplicationEventPublisher` object and then call the method, the other is a direct call container, the method of two methods of publishing events not too big difference.\\n>\\n> - `ApplicationEventPublisher`: publish event;\\n> - `ApplicationEvent`: `Spring` event, record the event source, time, and data;\\n> - `ApplicationListener`: event listener, observer.\\n\\nIn Spring event publishing mechanism, there are three objects,\\n\\nAn object is a publish event `ApplicationEventPublisher`, in `ShenYu` through the constructor in the injected a `eventPublisher`.\\n\\nThe other object is `ApplicationEvent` , inherited from `ShenYu` through `DataChangedEvent`, representing the event object.\\n\\n```java\\npublic class DataChangedEvent extends ApplicationEvent {\\n//......\\n}\\n```\\n\\nThe last object is `ApplicationListener` in `ShenYu` in through `DataChangedEventDispatcher` class implements this interface, as the event listener, responsible for handling the event object.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n    //......\\n    \\n}\\n```\\n\\n#### 2.3 Dispatch Data\\n\\n- DataChangedEventDispatcher.onApplicationEvent()\\n\\nReleased when the event is completed, will automatically enter the `DataChangedEventDispatcher` class `onApplicationEvent()` method of handling events.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  /**\\n     * This method is called when there are data changes\\n   * @param event\\n     */\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n      for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n        switch (event.getGroupKey()) {\\n                case APP_AUTH: // app auth data\\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n                    break;\\n                case PLUGIN:  // plugin data\\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n                    break;\\n                case RULE:    // rule data\\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n                    break;\\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    break;\\n                case META_DATA:  // metadata\\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n                    break;\\n                default:  // other types throw exception\\n                  throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n            }\\n        }\\n    }\\n    \\n}\\n```\\n\\nWhen there is a data change, the `onApplicationEvent` method is called and all the data change listeners are iterated to determine the data type and handed over to the appropriate data listener for processing.\\n\\nShenYu groups all the data into five categories: `APP_AUTH`, `PLUGIN`, `RULE`, `SELECTOR` and `META_DATA`.\\n\\nHere the data change listener (`DataChangedListener`) is an abstraction of the data synchronization policy. Its concrete implementation is:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/data-changed-listener.png)\\n\\nThese implementation classes are the synchronization strategies currently supported by ShenYu:\\n\\n- `WebsocketDataChangedListener`: data synchronization based on Websocket;\\n- `ZookeeperDataChangedListener`:data synchronization based on Zookeeper;\\n- `ConsulDataChangedListener`: data synchronization based on Consul;\\n- `EtcdDataDataChangedListener`\uff1adata synchronization based on etcd;\\n- `HttpLongPollingDataChangedListener`\uff1adata synchronization based on http long polling;\\n- `NacosDataChangedListener`\uff1adata synchronization based on nacos;\\n\\nGiven that there are so many implementation strategies, how do you decide which to use?\\n\\nBecause this paper is based on `Etcd` data synchronization source code analysis, so here to `EtcdDataDataChangedListener` as an example, the analysis of how it is loaded and implemented.\\n\\nA global search in the source code project shows that its implementation is done in the `DataSyncConfiguration` class.\\n\\n```java\\n/**\\n * Data Sync Configuration\\n * By springboot conditional assembly\\n * The type Data sync configuration.\\n */\\n@Configuration\\npublic class DataSyncConfiguration {\\n    \\n    \\n    /**\\n     * The type Etcd listener.\\n     */\\n    @Configuration\\n    @ConditionalOnProperty(prefix = \\"shenyu.sync.etcd\\", name = \\"url\\")\\n    @EnableConfigurationProperties(EtcdProperties.class)\\n    static class EtcdListener {\\n\\n        @Bean\\n        public EtcdClient etcdClient(final EtcdProperties etcdProperties) {\\n            Client client = Client.builder()\\n                    .endpoints(etcdProperties.getUrl())\\n                    .build();\\n            return new EtcdClient(client);\\n        }\\n\\n        /**\\n         * Config event listener data changed listener.\\n         *\\n         * @param etcdClient the etcd client\\n         * @return the data changed listener\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(EtcdDataDataChangedListener.class)\\n        public DataChangedListener etcdDataChangedListener(final EtcdClient etcdClient) {\\n            return new EtcdDataDataChangedListener(etcdClient);\\n        }\\n\\n        /**\\n         * data init.\\n         *\\n         * @param etcdClient        the etcd client\\n         * @param syncDataService the sync data service\\n         * @return the etcd data init\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(EtcdDataInit.class)\\n        public EtcdDataInit etcdDataInit(final EtcdClient etcdClient, final SyncDataService syncDataService) {\\n            return new EtcdDataInit(etcdClient, syncDataService);\\n        }\\n    }\\n    \\n    // other code is omitted......\\n}\\n\\n```\\n\\nThis configuration class is implemented through the SpringBoot conditional assembly class. The `EtcdListener` class has several annotations:\\n\\n- `@Configuration`: Configuration file, application context;\\n\\n- `@ConditionalOnProperty(prefix = \\"shenyu.sync.etcd\\", name = \\"url\\")`: attribute condition. The configuration class takes effect only when the condition is met. That is, when we have the following configuration, `etcd` is used for data synchronization.\\n\\n  ```properties\\n  shenyu:  \\n    sync:\\n       etcd:\\n            url: localhost:2181\\n  ```\\n  \\n- `@EnableConfigurationProperties(EtcdProperties.class)`\uff1aimport `EtcdProperties`; The properties in the class `EtcdProperties` is relative to the properties which is with `shenyu.sync.etcd` as prefix in the configuration file.\\n\\n```java\\n @Data\\n@ConfigurationProperties(prefix = \\"shenyu.sync.etcd\\")\\npublic class EtcdProperties {\\n\\n  private String url;\\n\\n  private Integer sessionTimeout;\\n\\n  private Integer connectionTimeout;\\n\\n  private String serializer;\\n}\\n```\\n\\nWhen the `shenyu.sync.etcd.url` property is set in the configuration file, `Admin` would use the `etcd` data synchronization, `EtcdListener` is generated and the beans with type `EtcdClient`, `EtcdDataDataChangedListener` and `EtcdDataInit` would also be generated. \\n\\n* The bean with the type `EtcdClient` would be generated, named `etcdClient`. This bean configues the connection properties of the `etcd` server based on the configuration file and can operate the `etcd`nodes directly.\\n* The bean with the type `EtcdDataDataChangedListener` would be generated, named `etcdDataDataChangedListener`.  This bean use the bean `etcdClient` as a member variable and so when the event is listened, `etcdDataDataChangedListener` would call the callback method and use the `etcdClient`  to operate the `etcd` nodes.\\n* The bean with the type `EtcdDataInit` would be generated, named `etcdDataInit`. This bean use the bean `etcdClient` and `syncDataService` as member variables, and use `etcdClient` to judge whether the data are initialized, if not, would use `syncDataService` to refresh data. We would dive into the details later.       \\n\\nSo in the event handler `onApplicationEvent()`, it goes to the corresponding `listener`. In our case, it is a selector data update, data synchronization is `etcd`, so, the code will enter the `EtcdDataDataChangedListener` selector data change process.\\n\\n```java\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n        for (DataChangedListener listener : listeners) {\\n            // what kind of data has changed\\n         switch (event.getGroupKey()) {\\n                    \\n                // other code logic is omitted\\n                    \\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());   // In our case, will enter the EtcdDataDataChangedListener selector data change process\\n                    break;\\n         }\\n    }\\n```\\n\\n#### 2.4 Etcd Data Changed Listener\\n\\n- EtcdDataDataChangedListener.onSelectorChanged()\\n\\nIn the `onSelectorChanged()` method, determine the type of action, whether to refresh synchronization or update or create synchronization. Determine whether the node is in `etcd` based on the current selector data.\\n\\n```java\\n\\n/**\\n * EtcdDataDataChangedListener.\\n */\\n@Slf4j\\npublic class EtcdDataDataChangedListener implements DataChangedListener {\\n    @Override\\n    public void onSelectorChanged(final List<SelectorData> changed, final DataEventTypeEnum eventType) {\\n        if (eventType == DataEventTypeEnum.REFRESH && !changed.isEmpty()) {\\n            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());\\n            etcdClient.deleteEtcdPathRecursive(selectorParentPath);\\n        }\\n        for (SelectorData data : changed) {\\n            String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());\\n            if (eventType == DataEventTypeEnum.DELETE) {\\n                etcdClient.delete(selectorRealPath);\\n                continue;\\n            }\\n            //create or update\\n            updateNode(selectorRealPath, data);\\n        }\\n    }\\n  \\n}\\n```\\n\\nThis part is very important. The variable `changed` represents the `SelectorData` list, the variable `eventType` reprents the event type. When the event type is `REFRESH` and the `SelectorData` has changed, all the `selector` nodes under this `plugin` would be deleted in `etcd`. We should notice that the condition that the `SelectorData` has changed is necessary, otherwise a bug would appear that all the selector nodes would be deleted when no `SelectorData` data has changed. \\n\\nAs long as the changed data is correctly written to the `etcd` node, the `admin` side of the operation is complete. \\n\\nIn our current case, updating one of the selector data in the `Divide` plugin with a weight of 90 updates specific nodes in the graph.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/zookeeper-node.png)\\n\\n\\nWe series the above update flow with a sequence diagram.\\n\\n\\n![](/img/activities/code-analysis-etcd-data-sync/etcd-sync-sequence-admin-en.png)\\n\\n\\n### 3. Gateway Data Sync\\n\\nAssume that the ShenYu gateway is already running properly, and the data synchronization mode is also `etcd`. How does the gateway receive and process the selector data after updating it on the admin side and sending the changed data to etcd? Let\'s continue our source code analysis to find out.\\n\\n#### 3.1 EtcdClient Accept Data\\n\\n- EtcdClient.watchDataChange()\\n\\nThere is a `EtcdSyncDataService` class on the gateway, which subscribing to the data node through `etcdClient` and can sense when the data changes.\\n\\n\\n```java\\n/**\\n * Data synchronize of etcd.\\n */\\n@Slf4j\\npublic class EtcdSyncDataService implements SyncDataService, AutoCloseable {\\n    private void subscribeSelectorDataChanges(final String path) {\\n      etcdClient.watchDataChange(path, (updateNode, updateValue) -> cacheSelectorData(updateValue),\\n              this::unCacheSelectorData);\\n    }\\n  //other codes omitted\\n}\\n```\\n\\nEtcd\'s  `Watch` mechanism notifies subscribing clients of node changes. In our case, updating the selector information goes to the `watchDataChange()` method. `cacheSelectorData()` is used to process data.\\n\\n\\n#### 3.2 Handle Data\\n\\n- EtcdSyncDataService.cacheSelectorData()\\n\\nThe data is not null, and caching the selector data is again handled by `PluginDataSubscriber`.\\n\\n```java\\n    private void cacheSelectorData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData)\\n                .ifPresent(data -> Optional.ofNullable(pluginDataSubscriber).ifPresent(e -> e.onSelectorSubscribe(data)));\\n    }\\n```\\n\\n`PluginDataSubscriber` is an interface, it is only a `CommonPluginDataSubscriber` implementation class, responsible for data processing plugin, selector and rules.\\n\\n\\n\\n#### 3.3 Common Plugin Data Subscriber\\n\\n- PluginDataSubscriber.onSelectorSubscribe()\\n\\nIt has no additional logic and calls the `subscribeDataHandler()` method directly. Within methods, there are data types (plugins, selectors, or rules) and action types (update or delete) to perform different logic.\\n\\n\\n```java\\n/**\\n * The common plugin data subscriber, responsible for handling all plug-in, selector, and rule information\\n */\\npublic class CommonPluginDataSubscriber implements PluginDataSubscriber {\\n    //......\\n     // handle selector data\\n    @Override\\n    public void onSelectorSubscribe(final SelectoData selectorData) {\\n        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);\\n    }    \\n    \\n    // A subscription data handler that handles updates or deletions of data\\n    private <T> void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {\\n        Optional.ofNullable(classData).ifPresent(data -> {\\n            // plugin data\\n            if (data instanceof PluginData) {\\n                PluginData pluginData = (PluginData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                     BaseDataCache.getInstance().cachePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.handlerPlugin(pluginData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.removePlugin(pluginData));\\n                }\\n            } else if (data instanceof SelectorData) {  // selector data\\n                SelectorData selectorData = (SelectorData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it \\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.removeSelector(selectorData));\\n                }\\n            } else if (data instanceof RuleData) {  // rule data\\n                RuleData ruleData = (RuleData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.handlerRule(ruleData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) { // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.removeRule(ruleData));\\n                }\\n            }\\n        });\\n    }\\n    \\n}\\n```\\n\\n#### 3.4 Data cached to Memory\\n\\n\\nAdding a selector will enter the following logic:\\n\\n```java\\n// save the data to gateway memory\\nBaseDataCache.getInstance().cacheSelectData(selectorData);\\n// If each plugin has its own processing logic, then do it\\nOptional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n```\\n\\nOne is to save the data to the gateway\'s memory. BaseDataCache is the class that ultimately caches data, implemented in a singleton pattern. The selector data is stored in the `SELECTOR_MAP` Map. In the subsequent use, also from this data.\\n\\n\\n```java\\npublic final class BaseDataCache {\\n    // private instance\\n    private static final BaseDataCache INSTANCE = new BaseDataCache();\\n  \\t// private constructor\\n    private BaseDataCache() {\\n    }\\n    \\n    /**\\n     * Gets instance.\\n     *  public method\\n     * @return the instance\\n     */\\n    public static BaseDataCache getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n    /**\\n      * A Map of the cache selector data\\n     * pluginName -> SelectorData.\\n     */\\n    private static final ConcurrentMap<String, List<SelectorData>> SELECTOR_MAP = Maps.newConcurrentMap();\\n    \\n    public void cacheSelectData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);\\n    }\\n        \\n   /**\\n     * cache selector data.\\n     * @param data the selector data\\n     */\\n    private void selectorAccept(final SelectorData data) {\\n        String key = data.getPluginName();\\n        if (SELECTOR_MAP.containsKey(key)) { // Update operation, delete before insert\\n            List<SelectorData> existList = SELECTOR_MAP.get(key);\\n            final List<SelectorData> resultList = existList.stream().filter(r -> !r.getId().equals(data.getId())).collect(Collectors.toList());\\n            resultList.add(data);\\n            final List<SelectorData> collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());\\n            SELECTOR_MAP.put(key, collect);\\n        } else {  // Add new operations directly to Map\\n            SELECTOR_MAP.put(key, Lists.newArrayList(data));\\n        }\\n    }\\n    \\n}\\n```\\n\\nSecond, if each plugin has its own processing logic, then do it. Through the `IDEA` editor, you can see that after adding a selector, there are the following plugins and processing. We\'re not going to expand it here.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/handler-selector.png)\\n\\nAfter the above source tracking, and through a practical case, in the `admin` end to update a selector data, the `ZooKeeper` data synchronization process analysis is clear.\\n\\n\\nLet\'s series the data synchronization process on the gateway side through the sequence diagram:\\n\\n\\n![](/img/activities/code-analysis-etcd-data-sync/etcd-sync-sequence-gateway-en.png)\\n\\nThe data synchronization process has been analyzed. In order to prevent the synchronization process from being interrupted, other logic is ignored during the analysis. We also need to analyze the process of Admin synchronization data initialization and gateway synchronization operation initialization.\\n\\n\\n### 4. Admin Data Sync  initialization\\n\\nWhen `admin` starts, the current data will be fully synchronized to `etcd`, the implementation logic is as follows:\\n\\n\\n```java\\n\\n/**\\n * EtcdDataInit.\\n */\\n@Slf4j\\npublic class EtcdDataInit implements CommandLineRunner {\\n\\n  private final EtcdClient etcdClient;\\n\\n  private final SyncDataService syncDataService;\\n\\n  public EtcdDataInit(final EtcdClient client, final SyncDataService syncDataService) {\\n    this.etcdClient = client;\\n    this.syncDataService = syncDataService;\\n  }\\n\\n  @Override\\n  public void run(final String... args) throws Exception {\\n    final String pluginPath = DefaultPathConstants.PLUGIN_PARENT;\\n    final String authPath = DefaultPathConstants.APP_AUTH_PARENT;\\n    final String metaDataPath = DefaultPathConstants.META_DATA;\\n    if (!etcdClient.exists(pluginPath) && !etcdClient.exists(authPath) && !etcdClient.exists(metaDataPath)) {\\n      log.info(\\"Init all data from database\\");\\n      syncDataService.syncAll(DataEventTypeEnum.REFRESH);\\n    }\\n  }\\n}\\n\\n```\\n\\nCheck whether there is data in `etcd`, if not, then synchronize.\\n\\n`EtcdDataInit` implements the `CommandLineRunner` interface. It is an interface provided by `SpringBoot` that executes the `run()` method after all `Spring Beans` initializations and is often used for initialization operations in a project.\\n\\n\\n- SyncDataService.syncAll()\\n\\nQuery data from the database, and then perform full data synchronization, all authentication information, plugin information, selector information, rule information, and metadata information. Synchronous events are published primarily through `eventPublisher`. After publishing the event via `publishEvent()`, the `ApplicationListener` performs the event change operation. In `ShenYu` is mentioned in `DataChangedEventDispatcher`.\\n\\n```java\\n@Service\\npublic class SyncDataServiceImpl implements SyncDataService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n     /***\\n     * sync all data\\n     * @param type the type\\n     * @return\\n     */\\n    @Override\\n    public boolean syncAll(final DataEventTypeEnum type) {\\n        // app auth data\\n        appAuthService.syncData();\\n        // plugin data\\n        List<PluginData> pluginDataList = pluginService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));\\n        // selector data\\n        List<SelectorData> selectorDataList = selectorService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));\\n        // rule data\\n        List<RuleData> ruleDataList = ruleService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));\\n        // metadata\\n        metaDataService.syncData();\\n        return true;\\n    }\\n    \\n}\\n```\\n\\n### 5. Gateway Data Sync Init \\n\\nThe initial operation of data synchronization on the gateway side is mainly the node in the subscription `etcd`. When there is a data change, the changed data will be received. This relies on the `Watch` mechanism of `etcd`. In `ShenYu`, the one responsible for `etcd` data synchronization is `EtcdSyncDataService`, also mentioned earlier.\\n\\nThe function logic of `EtcdSyncDataService` is completed in the process of instantiation: the subscription to `Shenyu` data synchronization node in `etcd` is completed. Subscription here is divided into two kinds, one kind is existing node data updated above, through this `etcdClient.subscribeDataChanges()` method; Another kind is under the current node, add or delete nodes change namely child nodes, it through `etcdClient.subscribeChildChanges()` method.\\n\\n`EtcdSyncDataService` code is a bit too much, here we use plugin data read and subscribe to track, other types of data operation principle is the same.\\n\\n\\n```java\\n/**\\n * Data synchronize of etcd.\\n */\\n@Slf4j\\npublic class EtcdSyncDataService implements SyncDataService, AutoCloseable {\\n    /**\\n     * Instantiates a new Zookeeper cache manager.\\n     *\\n     * @param etcdClient             the etcd client\\n     * @param pluginDataSubscriber the plugin data subscriber\\n     * @param metaDataSubscribers  the meta data subscribers\\n     * @param authDataSubscribers  the auth data subscribers\\n     */\\n    public EtcdSyncDataService(final EtcdClient etcdClient, final PluginDataSubscriber pluginDataSubscriber,\\n                                    final List<MetaDataSubscriber> metaDataSubscribers, final List<AuthDataSubscriber> authDataSubscribers) {\\n        this.etcdClient = etcdClient;\\n        this.pluginDataSubscriber = pluginDataSubscriber;\\n        this.metaDataSubscribers = metaDataSubscribers;\\n        this.authDataSubscribers = authDataSubscribers;\\n        watcherData();\\n        watchAppAuth();\\n        watchMetaData();\\n    }\\n\\n    private void watcherData() {\\n        final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;\\n        List<String> pluginZKs = etcdClientGetChildren(pluginParent);\\n        for (String pluginName : pluginZKs) {\\n            watcherAll(pluginName);\\n        }\\n\\n        etcdClient.watchChildChange(pluginParent, (updateNode, updateValue) -> {\\n            if (!updateNode.isEmpty()) {\\n                watcherAll(updateNode);\\n            }\\n        }, null);\\n    }\\n\\n    private void watcherAll(final String pluginName) {\\n        watcherPlugin(pluginName);\\n        watcherSelector(pluginName);\\n        watcherRule(pluginName);\\n    }\\n\\n    private void watcherPlugin(final String pluginName) {\\n        String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);\\n        cachePluginData(etcdClient.get(pluginPath));\\n        subscribePluginDataChanges(pluginPath, pluginName);\\n    }\\n\\n    private void cachePluginData(final String dataString) {\\n        final PluginData pluginData = GsonUtils.getInstance().fromJson(dataString, PluginData.class);\\n        Optional.ofNullable(pluginData)\\n                .flatMap(data -> Optional.ofNullable(pluginDataSubscriber)).ifPresent(e -> e.onSubscribe(pluginData));\\n    }\\n\\n    private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {\\n    etcdClient.watchDataChange(pluginPath, (updatePath, updateValue) -> {\\n      final String dataPath = buildRealPath(pluginPath, updatePath);\\n      final String dataStr = etcdClient.get(dataPath);\\n      final PluginData data = GsonUtils.getInstance().fromJson(dataStr, PluginData.class);\\n      Optional.ofNullable(data)\\n              .ifPresent(d -> Optional.ofNullable(pluginDataSubscriber).ifPresent(e -> e.onSubscribe(d)));\\n    }, deleteNode -> deletePlugin(pluginName));\\n  }\\n  \\n}\\n\\n```\\n\\nThe above source code is given comments, I believe you can understand. The main logic for subscribing to plug-in data is as follows:\\n\\n> 1. Create the current plugin path\\n> 3. Read the current node data on etcd and deserialize it\\n> 4. The plugin data is cached in the gateway memory\\n> 5. Subscribe to the plug-in node\\n\\n\\n### 6. Summary\\n\\nThis paper through a practical case, `etcd` data synchronization principle source code analysis. The main knowledge points involved are as follows:\\n\\n- Data synchronization based on `etcd` is mainly implemented through `watch` mechanism;\\n\\n- Complete event publishing and listening via `Spring`;\\n\\n- Support multiple synchronization strategies through abstract `DataChangedListener` interface, interface oriented programming;\\n\\n- Use singleton design pattern to cache data class `BaseDataCache`;\\n\\n- Loading of configuration classes via conditional assembly of `SpringBoot` and `starter` loading mechanism."},{"id":"/DataSync-SourceCode-Analysis-Http-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-Http-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Http-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-Http-Data-Sync.md","title":"Http Long Polling Data Synchronization Source Code Analysis","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"http","permalink":"/blog/tags/http"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":30.365,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"Http Long Polling Data Synchronization Source Code Analysis","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["http","data sync","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Etcd Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync"},"nextItem":{"title":"Nacos Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\nIn `ShenYu` gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for `ZooKeeper`, `WebSocket`, `http long poll`, `Nacos`, `etcd` and `Consul`. The main content of this article is based on `http long poll` data synchronization source code analysis.\\n\\n> This paper based on `shenyu-2.5.0` version of the source code analysis, the official website of the introduction of please refer to the [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/) .\\n\\n### 1. Http Long Polling\\n\\nHere is a direct quote from the official website with the relevant description.\\n\\n> The mechanism of `Zookeeper` and `WebSocket` data synchronization is relatively simple, while `Http long polling` is more complex. `Apache ShenYu` borrowed the design ideas of `Apollo` and `Nacos`, took their essence, and implemented `Http long polling` data synchronization function by itself. Note that this is not the traditional `ajax` long polling!\\n\\n![](/img/shenyu/dataSync/http-long-polling-en.png)\\n\\n`Http Long Polling` mechanism as shown above, `Apache ShenYu` gateway active request `shenyu-admin` configuration service, read timeout time is `90s`, means that the gateway layer request configuration service will wait at most `90s`, so as to facilitate `shenyu-admin` configuration service timely response to change data, so as to achieve quasi real-time push.\\n\\nThe `Http long polling` mechanism is initiated by the gateway requesting `shenyu-admin`, so for this source code analysis, we start from the gateway side.\\n\\n### 2. Gateway Data Sync\\n\\n#### 2.1 Load Configuration\\n\\nThe `Http long polling` data synchronization configuration is loaded through `spring boot starter` mechanism when we introduce the relevant dependencies and have the following configuration in the configuration file.\\n\\nIntroduce dependencies in the `pom` file.\\n\\n```xml\\n\x3c!--shenyu data sync start use http--\x3e\\n<dependency>\\n    <groupId>org.apache.shenyu</groupId>\\n    <artifactId>shenyu-spring-boot-starter-sync-data-http</artifactId>\\n    <version>${project.version}</version>\\n</dependency>\\n```\\n\\nAdd the following configuration to the `application.yml` configuration file.\\n\\n```yaml\\nshenyu:\\n    sync:\\n       http:\\n          url : http://localhost:9095\\n```\\n\\nWhen the gateway is started, the configuration class `HttpSyncDataConfiguration` is executed, loading the corresponding `Bean`.\\n\\n```java\\n\\n/**\\n * Http sync data configuration for spring boot.\\n */\\n@Configuration\\n@ConditionalOnClass(HttpSyncDataService.class)\\n@ConditionalOnProperty(prefix = \\"shenyu.sync.http\\", name = \\"url\\")\\n@EnableConfigurationProperties(value = HttpConfig.class)\\npublic class HttpSyncDataConfiguration {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpSyncDataConfiguration.class);\\n\\n    /**\\n     * Rest template.\\n     *\\n     * @param httpConfig the http config\\n     * @return the rest template\\n     */\\n    @Bean\\n    public RestTemplate restTemplate(final HttpConfig httpConfig) {\\n        OkHttp3ClientHttpRequestFactory factory = new OkHttp3ClientHttpRequestFactory();\\n        factory.setConnectTimeout(Objects.isNull(httpConfig.getConnectionTimeout()) ? (int) HttpConstants.CLIENT_POLLING_CONNECT_TIMEOUT : httpConfig.getConnectionTimeout());\\n        factory.setReadTimeout(Objects.isNull(httpConfig.getReadTimeout()) ? (int) HttpConstants.CLIENT_POLLING_READ_TIMEOUT : httpConfig.getReadTimeout());\\n        factory.setWriteTimeout(Objects.isNull(httpConfig.getWriteTimeout()) ? (int) HttpConstants.CLIENT_POLLING_WRITE_TIMEOUT : httpConfig.getWriteTimeout());\\n        return new RestTemplate(factory);\\n    }\\n\\n    /**\\n     * AccessTokenManager.\\n     *\\n     * @param httpConfig   the http config.\\n     * @param restTemplate the rest template.\\n     * @return the access token manager.\\n     */\\n    @Bean\\n    public AccessTokenManager accessTokenManager(final HttpConfig httpConfig, final RestTemplate restTemplate) {\\n        return new AccessTokenManager(restTemplate, httpConfig);\\n    }\\n\\n    /**\\n     * Http sync data service.\\n     *\\n     * @param httpConfig         the http config\\n     * @param pluginSubscriber   the plugin subscriber\\n     * @param restTemplate       the rest template\\n     * @param metaSubscribers    the meta subscribers\\n     * @param authSubscribers    the auth subscribers\\n     * @param accessTokenManager the access token manager\\n     * @return the sync data service\\n     */\\n    @Bean\\n    public SyncDataService httpSyncDataService(final ObjectProvider<HttpConfig> httpConfig,\\n                                               final ObjectProvider<PluginDataSubscriber> pluginSubscriber,\\n                                               final ObjectProvider<RestTemplate> restTemplate,\\n                                               final ObjectProvider<List<MetaDataSubscriber>> metaSubscribers,\\n                                               final ObjectProvider<List<AuthDataSubscriber>> authSubscribers,\\n                                               final ObjectProvider<AccessTokenManager> accessTokenManager) {\\n        LOGGER.info(\\"you use http long pull sync shenyu data\\");\\n        return new HttpSyncDataService(\\n                Objects.requireNonNull(httpConfig.getIfAvailable()),\\n                Objects.requireNonNull(pluginSubscriber.getIfAvailable()),\\n                Objects.requireNonNull(restTemplate.getIfAvailable()),\\n                metaSubscribers.getIfAvailable(Collections::emptyList),\\n                authSubscribers.getIfAvailable(Collections::emptyList),\\n                Objects.requireNonNull(accessTokenManager.getIfAvailable())\\n        );\\n    }\\n}\\n```\\n\\n`HttpSyncDataConfiguration` is the configuration class for `Http long polling` data synchronization, responsible for creating `HttpSyncDataService` (responsible for the concrete implementation of `http` data synchronization) \u3001 `RestTemplate` and `AccessTokenManager` (responsible for the access token processing). It is annotated as follows.\\n\\n- `@Configuration`: indicates that this is a configuration class.\\n- `@ConditionalOnClass(HttpSyncDataService.class)`: conditional annotation indicating that the class `HttpSyncDataService` is to be present.\\n- `@ConditionalOnProperty(prefix = \\"shenyu.sync.http\\", name = \\"url\\")`: conditional annotation to have the property `shenyu.sync.http.url` configured.\\n- `@EnableConfigurationProperties(value = HttpConfig.class)`: indicates that the annotation `@ConfigurationProperties(prefix = \\"shenyu.sync.http\\")` on `HttpConfig` will take effect, and the configuration class `HttpConfig` will be injected into the Ioc container.\\n\\n\\n#### 2.2 Property initialization\\n\\n- HttpSyncDataService\\n\\nIn the constructor of `HttpSyncDataService`, complete the property initialization.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // omitted attribute field ......\\n\\n    public HttpSyncDataService(final HttpConfig httpConfig,\\n                               final PluginDataSubscriber pluginDataSubscriber,\\n                               final RestTemplate restTemplate,\\n                               final List<MetaDataSubscriber> metaDataSubscribers,\\n                               final List<AuthDataSubscriber> authDataSubscribers,\\n                               final AccessTokenManager accessTokenManager) {\\n          // 1. accessTokenManager\\n          this.accessTokenManager = accessTokenManager;\\n          // 2. create data refresh factory\\n          this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\\n          // 3. shenyu-admin url\\n          this.serverList = Lists.newArrayList(Splitter.on(\\",\\").split(httpConfig.getUrl()));\\n          // 4. restTemplate\\n          this.restTemplate = restTemplate;\\n          // 5. start a long polling task\\n          this.start();\\n    }\\n\\n    //......\\n}\\n```\\n\\nOther functions and related fields are omitted from the above code, and the initialization of the properties is done in the constructor, mainly.\\n\\n- the role of `accessTokenManager` is to request `admin` and update the `access token` regularly.\\n\\n- creating data processors for subsequent caching of various types of data (plugins, selectors, rules, metadata and authentication data).\\n\\n- obtaining the `admin` property configuration, mainly to obtain the `url` of the `admin`, `admin` with possible clusters, multiple split by a comma `(,)`.\\n\\n- using `RestTemplate`, for launching requests to `admin`.\\n\\n- Start the long polling task.\\n\\n#### 2.3 Start the long polling task.\\n\\n- HttpSyncDataService#start()\\n\\nIn the `start()` method, two things are done, one is to get the full amount of data, that is, to request the `admin` side to get all the data that needs to be synchronized, and then cache the acquired data into the gateway memory. The other is to open a multi-threaded execution of a long polling task.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // ......\\n\\n    private void start() {\\n        // It could be initialized multiple times, so you need to control that.\\n        if (RUNNING.compareAndSet(false, true)) {\\n            // fetch all group configs.\\n            // Initial startup, get full data\\n            this.fetchGroupConfig(ConfigGroupEnum.values());\\n            // one backend service, one thread\\n            int threadSize = serverList.size();\\n            // ThreadPoolExecutor\\n            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,\\n                    new LinkedBlockingQueue<>(),\\n                    ShenyuThreadFactory.create(\\"http-long-polling\\", true));\\n            // start long polling, each server creates a thread to listen for changes.\\n            this.serverList.forEach(server -> this.executor.execute(new HttpLongPollingTask(server)));\\n        } else {\\n            LOG.info(\\"shenyu http long polling was started, executor=[{}]\\", executor);\\n        }\\n    }\\n\\n    // ......\\n}\\n```\\n\\n##### 2.3.1 Fetch Data\\n\\n- HttpSyncDataService#fetchGroupConfig()\\n\\n`ShenYu` groups all the data that needs to be synchronized, there are 5 data types, namely plugins, selectors, rules, metadata and authentication data.\\n\\n```java\\npublic enum ConfigGroupEnum {\\n    APP_AUTH, // app auth data\\n    PLUGIN, // plugin data\\n    RULE, // rule data\\n    SELECTOR, // selector data\\n    META_DATA; // meta data\\n}\\n```\\n\\nThe `admin` may be a cluster, and here a request is made to each `admin` in a round-robin fashion, and if one succeeds, then the operation to get the full amount of data from the `admin` and cache it to the gateway is executed successfully. If there is an exception, the request is launched to the next `admin`.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // ......\\n\\n    private void fetchGroupConfig(final ConfigGroupEnum... groups) throws ShenyuException {\\n        // It is possible that admins are clustered, and here requests are made to each admin by means of a loop.\\n        for (int index = 0; index < this.serverList.size(); index++) {\\n            String server = serverList.get(index);\\n            try {\\n                // do execute\\n                this.doFetchGroupConfig(server, groups);\\n                // If you have a success, you are successful and can exit the loop\\n                break;\\n            } catch (ShenyuException e) {\\n                // An exception occurs, try executing the next\\n                // The last one also failed to execute, throwing an exception\\n                // no available server, throw exception.\\n                if (index >= serverList.size() - 1) {\\n                    throw e;\\n                }\\n                LOG.warn(\\"fetch config fail, try another one: {}\\", serverList.get(index + 1));\\n            }\\n        }\\n    }\\n\\n    // ......\\n}\\n```\\n\\n- HttpSyncDataService#doFetchGroupConfig()\\n\\nIn this method, the request parameters are first assembled, then the request is launched through `httpClient` to `admin` to get the data, and finally the obtained data is updated to the gateway memory.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // ......\\n\\n    // Launch a request to the admin backend management system to get all synchronized data\\n    private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {\\n        // 1. build request parameters, all grouped enumeration types\\n        StringBuilder params = new StringBuilder();\\n        for (ConfigGroupEnum groupKey : groups) {\\n            params.append(\\"groupKeys\\").append(\\"=\\").append(groupKey.name()).append(\\"&\\");\\n        }\\n        // admin url:  /configs/fetch\\n        String url = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_FETCH + \\"?\\" + StringUtils.removeEnd(params.toString(), \\"&\\");\\n        LOG.info(\\"request configs: [{}]\\", url);\\n        String json;\\n        try {\\n            HttpHeaders headers = new HttpHeaders();\\n            // set accessToken\\n            headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());\\n            HttpEntity<String> httpEntity = new HttpEntity<>(headers);\\n            // 2. get a request for change data\\n            json = this.restTemplate.exchange(url, HttpMethod.GET, httpEntity, String.class).getBody();\\n        } catch (RestClientException e) {\\n            String message = String.format(\\"fetch config fail from server[%s], %s\\", url, e.getMessage());\\n            LOG.warn(message);\\n            throw new ShenyuException(message, e);\\n        }\\n        // update local cache\\n        // 3. Update data in gateway memory\\n        boolean updated = this.updateCacheWithJson(json);\\n        if (updated) {\\n            LOG.debug(\\"get latest configs: [{}]\\", json);\\n            return;\\n        }\\n        // not updated. it is likely that the current config server has not been updated yet. wait a moment.\\n        LOG.info(\\"The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.\\", server);\\n        // No data update on the server side, just wait 30s\\n        ThreadUtils.sleep(TimeUnit.SECONDS, 30);\\n    }\\n\\n    // ......\\n}\\n```\\n\\nFrom the code, we can see that the `admin` side provides the interface to get the full amount of data is `/configs/fetch`, so we will not go further here and put it in the later analysis.\\n\\nIf you get the result data from `admin` and update it successfully, then this method is finished. If there is no successful update, then it is possible that there is no data update on the server side, so wait `30s`.\\n\\nHere you need to explain in advance, the gateway in determining whether the update is successful, there is a comparison of the data operation, immediately mentioned.\\n\\n\\n- HttpSyncDataService#updateCacheWithJson()\\n\\nUpdate the data in the gateway memory. Use `GSON` for deserialization, take the real data from the property `data` and give it to `DataRefreshFactory` to do the update.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // ......\\n\\n    private boolean updateCacheWithJson(final String json) {\\n        // Using GSON for deserialization\\n        JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);\\n        // if the config cache will be updated?\\n        return factory.executor(jsonObject.getAsJsonObject(\\"data\\"));\\n    }\\n\\n    // ......\\n}\\n```\\n\\n- DataRefreshFactory#executor()\\n\\nUpdate the data according to different data types and return the updated result. The specific update logic is given to the `dataRefresh.refresh()` method. In the update result, one of the data types is updated, which means that the operation has been updated.\\n\\n```java\\npublic final class DataRefreshFactory {\\n    \\n    // ......\\n    \\n    public boolean executor(final JsonObject data) {\\n        // update data\\n        List<Boolean> result = ENUM_MAP.values().parallelStream()\\n                .map(dataRefresh -> dataRefresh.refresh(data))\\n                .collect(Collectors.toList());\\n        // one of the data types is updated, which means that the operation has been updated.\\n        return result.stream().anyMatch(Boolean.TRUE::equals);\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n- AbstractDataRefresh#refresh()\\n\\nThe data update logic uses the template method design pattern, where the generic operation is done in the abstract method and the different implementation logic is done by subclasses. 5 data types have some differences in the specific update logic, but there is also a common update logic, and the class diagram relationship is as follows.\\n\\n![](/img/activities/code-analysis-http-data-sync/data-refresh.png)\\n\\nIn the generic `refresh()` method, it is responsible for data type conversion, determining whether an update is needed, and the actual data refresh operation.\\n\\n```java\\npublic abstract class AbstractDataRefresh<T> implements DataRefresh {\\n\\n    // ......\\n\\n    @Override\\n    public Boolean refresh(final JsonObject data) {\\n        // convert data\\n        JsonObject jsonObject = convert(data);\\n        if (Objects.isNull(jsonObject)) {\\n            return false;\\n        }\\n\\n        boolean updated = false;\\n        // get data\\n        ConfigData<T> result = fromJson(jsonObject);\\n        // does it need to be updated\\n        if (this.updateCacheIfNeed(result)) {\\n            updated = true;\\n            // real update logic, data refresh operation\\n            refresh(result.getData());\\n        }\\n\\n        return updated;\\n    }\\n\\n    // ......\\n}\\n```\\n\\n- AbstractDataRefresh#updateCacheIfNeed()\\n\\nThe process of data conversion, which is based on different data types, we will not trace further to see if the data needs to be updated logically. The method name is `updateCacheIfNeed()`, which is implemented by method overloading.\\n\\n```java\\npublic abstract class AbstractDataRefresh<T> implements DataRefresh {\\n\\n    // ......\\n\\n    // result is data\\n    protected abstract boolean updateCacheIfNeed(ConfigData<T> result);\\n\\n    // newVal is the latest value obtained\\n    // What kind of data type is groupEnum\\n    protected boolean updateCacheIfNeed(final ConfigData<T> newVal, final ConfigGroupEnum groupEnum) {\\n        // If it is the first time, then it is put directly into the cache and returns true, indicating that the update was made this time\\n        if (GROUP_CACHE.putIfAbsent(groupEnum, newVal) == null) {\\n            return true;\\n        }\\n        ResultHolder holder = new ResultHolder(false);\\n        GROUP_CACHE.merge(groupEnum, newVal, (oldVal, value) -> {\\n            // md5 value is the same, no need to update\\n            if (StringUtils.equals(oldVal.getMd5(), newVal.getMd5())) {\\n                LOG.info(\\"Get the same config, the [{}] config cache will not be updated, md5:{}\\", groupEnum, oldVal.getMd5());\\n                return oldVal;\\n            }\\n\\n            // The current cached data has been modified for a longer period than the new data and does not need to be updated.\\n            // must compare the last update time\\n            if (oldVal.getLastModifyTime() >= newVal.getLastModifyTime()) {\\n                LOG.info(\\"Last update time earlier than the current configuration, the [{}] config cache will not be updated\\", groupEnum);\\n                return oldVal;\\n            }\\n            LOG.info(\\"update {} config: {}\\", groupEnum, newVal);\\n            holder.result = true;\\n            return newVal;\\n        });\\n        return holder.result;\\n    }\\n\\n    // ......\\n}\\n```\\n\\nAs you can see from the source code above, there are two cases where updates are not required.\\n\\n- The `md5` values of both data are the same, so no update is needed;\\n- The current cached data has been modified longer than the new data, so no update is needed.\\n\\nIn other cases, the data needs to be updated.\\n\\nAt this point, we have finished analyzing the logic of the `start()` method to get the full amount of data for the first time, followed by the long polling operation. For convenience, I will paste the `start()` method once more.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n\\n    // ......\\n\\n    private void start() {\\n        // It could be initialized multiple times, so you need to control that.\\n        if (RUNNING.compareAndSet(false, true)) {\\n            // fetch all group configs.\\n            // Initial startup, get full data\\n            this.fetchGroupConfig(ConfigGroupEnum.values());\\n            // one backend service, one thread\\n            int threadSize = serverList.size();\\n            // ThreadPoolExecutor\\n            this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,\\n                    new LinkedBlockingQueue<>(),\\n                    ShenyuThreadFactory.create(\\"http-long-polling\\", true));\\n            // start long polling, each server creates a thread to listen for changes.\\n            this.serverList.forEach(server -> this.executor.execute(new HttpLongPollingTask(server)));\\n        } else {\\n            LOG.info(\\"shenyu http long polling was started, executor=[{}]\\", executor);\\n        }\\n    }\\n\\n    // ......\\n}\\n```\\n\\n##### 2.3.2 Execute Long Polling Task\\n\\n- HttpLongPollingTask#run()\\n\\nThe long polling task is `HttpLongPollingTask`, which implements the `Runnable` interface and the task logic is in the `run()` method. The task is executed continuously through a `while()` loop, i.e., long polling. There are three retries in each polling logic, one polling task fails, wait `5s` and continue, `3` times all fail, wait `5` minutes and try again.\\n\\nStart long polling, an `admin` service, and create a thread for data synchronization.\\n\\n```java\\nclass HttpLongPollingTask implements Runnable {\\n\\n    private final String server;\\n\\n    HttpLongPollingTask(final String server) {\\n        this.server = server;\\n    }\\n\\n    @Override\\n    public void run() {\\n        // long polling\\n        while (RUNNING.get()) {\\n            // Default retry 3 times\\n            int retryTimes = 3;\\n            for (int time = 1; time <= retryTimes; time++) {\\n                try {\\n                    doLongPolling(server);\\n                } catch (Exception e) {\\n                    if (time < retryTimes) {\\n                        LOG.warn(\\"Long polling failed, tried {} times, {} times left, will be suspended for a while! {}\\",\\n                                time, retryTimes - time, e.getMessage());\\n                        // long polling failed, wait 5s and continue\\n                        ThreadUtils.sleep(TimeUnit.SECONDS, 5);\\n                        continue;\\n                    }\\n                    // print error, then suspended for a while.\\n                    LOG.error(\\"Long polling failed, try again after 5 minutes!\\", e);\\n                    // 3 \u6b21\u90fd\u5931\u8d25\u4e86\uff0c\u7b49 5 \u5206\u949f\u518d\u8bd5\\n                    ThreadUtils.sleep(TimeUnit.MINUTES, 5);\\n                }\\n            }\\n        }\\n        LOG.warn(\\"Stop http long polling.\\");\\n    }\\n}\\n```\\n\\n- HttpSyncDataService#doLongPolling()\\n\\nCore logic for performing long polling tasks.\\n\\n- Assembling request parameters based on data types: `md5` and `lastModifyTime`.\\n- Assembling the request header and request body.\\n- Launching a request to `admin` to determine if the group data has changed.\\n- Based on the group that has changed, go back and get the data.\\n\\n```java\\npublic class HttpSyncDataService implements SyncDataService {\\n    private void doLongPolling(final String server) {\\n        // build request params: md5 and lastModifyTime\\n        MultiValueMap<String, String> params = new LinkedMultiValueMap<>(8);\\n        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {\\n            ConfigData<?> cacheConfig = factory.cacheConfigData(group);\\n            if (cacheConfig != null) {\\n                String value = String.join(\\",\\", cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));\\n                params.put(group.name(), Lists.newArrayList(value));\\n            }\\n        }\\n        // build request head and body\\n        HttpHeaders headers = new HttpHeaders();\\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\\n        // set accessToken\\n        headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());\\n        HttpEntity<MultiValueMap<String, String>> httpEntity = new HttpEntity<>(params, headers);\\n        String listenerUrl = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_LISTENER;\\n\\n        JsonArray groupJson;\\n        //Initiate a request to admin to determine if the group data has changed\\n        //Here it just determines whether a group has changed or not\\n        try {\\n            String json = this.restTemplate.postForEntity(listenerUrl, httpEntity, String.class).getBody();\\n            LOG.info(\\"listener result: [{}]\\", json);\\n            JsonObject responseFromServer = GsonUtils.getGson().fromJson(json, JsonObject.class);\\n            groupJson = responseFromServer.getAsJsonArray(\\"data\\");\\n        } catch (RestClientException e) {\\n            String message = String.format(\\"listener configs fail, server:[%s], %s\\", server, e.getMessage());\\n            throw new ShenyuException(message, e);\\n        }\\n        // Depending on the group where the change occurred, go back and get the data\\n        /**\\n         * The official website explains here.\\n         * After the gateway receives the response message, it only knows which Group has made the configuration change, and it still needs to request the configuration data of that Group again.\\n         * There may be a question here: why not write out the changed data directly?\\n         * We also discussed this issue in depth during development, because the http long polling mechanism can only guarantee quasi-real time, if the processing at the gateway layer is not timely, * or the administrator frequently updates the configuration, it is very difficult to get the information from the gateway layer.\\n         * If it is not processed in time at the gateway level, or if the administrator updates the configuration frequently, it is very likely to miss the push of a configuration change, so for security reasons, we only inform a group that the information has changed.\\n         *For security reasons, we only notify a group of changes.\\n         * Personal understanding.\\n         * If the change data is written out directly, when the administrator frequently updates the configuration, the first update will remove the client from the blocking queue and return the response information to the gateway.\\n         * If a second update is made at this time, the current client is not in the blocking queue, so this time the change is missed.\\n         * The same is true for untimely processing by the gateway layer.\\n         * This is a long polling, one gateway one synchronization thread, there may be time consuming process.\\n         * If the admin has data changes, the current gateway client is not in the blocking queue and will not get the data.\\n         */\\n        if (groupJson != null) {\\n            // fetch group configuration async.\\n            ConfigGroupEnum[] changedGroups = GSON.fromJson(groupJson, ConfigGroupEnum[].class);\\n            if (ArrayUtils.isNotEmpty(changedGroups)) {\\n                log.info(\\"Group config changed: {}\\", Arrays.toString(changedGroups));\\n                // Proactively get the changed data from admin, depending on the grouping, and take the data in full\\n                this.doFetchGroupConfig(server, changedGroups);\\n            }\\n        }\\n        if (Objects.nonNull(groupJson) && groupJson.size() > 0) {\\n            // fetch group configuration async.\\n            ConfigGroupEnum[] changedGroups = GsonUtils.getGson().fromJson(groupJson, ConfigGroupEnum[].class);\\n            LOG.info(\\"Group config changed: {}\\", Arrays.toString(changedGroups));\\n            // Proactively get the changed data from admin, depending on the grouping, and take the data in full\\n            this.doFetchGroupConfig(server, changedGroups);\\n        }\\n    }\\n}\\n```\\n\\nOne special point needs to be explained here: In the long polling task, why don\'t you get the changed data directly? Instead, we determine which group data has been changed, and then request `admin` again to get the changed data?\\n\\nThe official explanation here is.\\n\\n> After the gateway receives the response information, it only knows which Group has changed its configuration, and it needs to request the configuration data of that Group again.\\n> There may be a question here: Why not write out the changed data directly?\\n> We have discussed this issue in depth during development, because the `http` long polling mechanism can only guarantee quasi-real time, and if it is not processed in time at the gateway layer, it will be very difficult to update the configuration data.\\nIf the gateway layer is not processed in time, or the administrator updates the configuration frequently, it is likely to miss the push of a configuration change, so for security reasons, we only inform a group that the information has changed.\\n\\nMy personal understanding is that.\\n\\n> If the change data is written out directly, when the administrator updates the configuration frequently, the first update will remove the `client` from blocking queue and return the response information to the gateway. If a second update is made at this time, then the current `client` is not in the blocking queue, so this time the change is missed. The same is true for the gateway layer\'s untimely processing. This is a long polling, one gateway one synchronization thread, there may be a time-consuming process. If `admin` has data changes, the current gateway client is not in the blocking queue and will not get the data.\\n\\nWe have not yet analyzed the processing logic of the `admin` side, so let\'s talk about it roughly. At the `admin` end, the gateway `client` will be put into the blocking queue, and when there is a data change, the gateway `client` will come out of the queue and send the change data. So, if the gateway `client` is not in the blocking queue when there is a data change, then the current changed data is not available.\\n\\nWhen we know which grouping data has changed, we actively get the changed data from `admin` again, and get the data in full depending on the grouping. The call method is `doFetchGroupConfig()`, which has been analyzed in the previous section.\\n\\nAt this point of analysis, the data synchronization operation on the gateway side is complete. The long polling task is to keep making requests to `admin` to see if the data has changed, and if any group data has changed, then initiate another request to `admin` to get the changed data, and then update the data in the gateway\'s memory.\\n\\nLong polling task flow at the gateway side.\\n\\n![](/img/activities/code-analysis-http-data-sync/http-long-polling-sequence-en.png)\\n\\n### 3. Admin Data Sync\\n\\nFrom the previous analysis, it can be seen that the gateway side mainly calls two interfaces of `admin`.\\n\\n- `/configs/listener`: determine whether the group data has changed.\\n- `/configs/fetch`: get the changed group data.\\n\\nIf we analyze directly from these two interfaces, some parts may not be well understood, so let\'s start analyzing the data synchronization process from the `admin` startup process.\\n\\n#### 3.1 Load Configuration\\n\\nIf the following configuration is done in the configuration file `application.yml`, it means that the data synchronization is done by `http long polling`.\\n\\n```yaml\\nshenyu:\\n  sync:\\n      http:\\n        enabled: true\\n```\\n\\nWhen the program starts, the configuration of the data synchronization class is loaded through `springboot` conditional assembly. In this process, `HttpLongPollingDataChangedListener` is created to handle the implementation logic related to long polling.\\n\\n```java\\n/**\\n * Data synchronization configuration class\\n * Conditional assembly via springboot\\n * The type Data sync configuration.\\n */\\n@Configuration\\npublic class DataSyncConfiguration {\\n\\n    /**\\n     * http long polling.\\n     */\\n    @Configuration\\n    @ConditionalOnProperty(name = \\"shenyu.sync.http.enabled\\", havingValue = \\"true\\")\\n    @EnableConfigurationProperties(HttpSyncProperties.class)\\n    static class HttpLongPollingListener {\\n\\n        @Bean\\n        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)\\n        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {\\n            return new HttpLongPollingDataChangedListener(httpSyncProperties);\\n        }\\n    }\\n}\\n```\\n\\n#### 3.2 Data change listener instantiation\\n\\n- HttpLongPollingDataChangedListener\\n\\nThe data change listener is instantiated and initialized by means of a constructor. In the constructor, a blocking queue is created to hold clients, a thread pool is created to execute deferred tasks and periodic tasks, and information about the properties of long polling is stored.\\n\\n```java\\n    public HttpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {\\n        // default client (here is the gateway) 1024\\n        this.clients = new ArrayBlockingQueue<>(1024);\\n        // create thread pool\\n        // ScheduledThreadPoolExecutor can perform delayed tasks, periodic tasks, and normal tasks\\n        this.scheduler = new ScheduledThreadPoolExecutor(1,\\n                ShenyuThreadFactory.create(\\"long-polling\\", true));\\n        // http sync properties\\n        this.httpSyncProperties = httpSyncProperties;\\n    }\\n```\\n\\nIn addition, it has the following class diagram relationships.\\n\\n![](/img/activities/code-analysis-http-data-sync/data-changed-listener.png)\\n\\nThe `InitializingBean` interface is implemented, so the `afterInitialize()` method is executed during the initialization of the `bean`. Execute periodic tasks via thread pool: updating the data in memory `(CACHE)` is executed every `5` minutes and starts after `5` minutes. Refreshing the local cache is reading data from the database to the local cache (in this case the memory), done by `refreshLocalCache()`.\\n\\n```java\\npublic class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {\\n\\n    // ......\\n\\n    /**\\n     * is called in the afterPropertiesSet() method of the InitializingBean interface, which is executed during the initialization of the bean\\n     */\\n    @Override\\n    protected void afterInitialize() {\\n        long syncInterval = httpSyncProperties.getRefreshInterval().toMillis();\\n        // Periodically check the data for changes and update the cache\\n\\n        // Execution cycle task: Update data in memory (CACHE) is executed every 5 minutes and starts after 5 minutes\\n        // Prevent the admin from starting up first for a while and then generating data; then the gateway doesn\'t get the full amount of data when it first connects\\n        scheduler.scheduleWithFixedDelay(() -> {\\n            LOG.info(\\"http sync strategy refresh config start.\\");\\n            try {\\n                // Read data from database to local cache (in this case, memory)\\n                this.refreshLocalCache();\\n                LOG.info(\\"http sync strategy refresh config success.\\");\\n            } catch (Exception e) {\\n                LOG.error(\\"http sync strategy refresh config error!\\", e);\\n            }\\n        }, syncInterval, syncInterval, TimeUnit.MILLISECONDS);\\n        LOG.info(\\"http sync strategy refresh interval: {}ms\\", syncInterval);\\n    }\\n\\n    // ......\\n}\\n```\\n\\n- refreshLocalCache()\\n\\nUpdate for each of the 5 data types.\\n\\n```java\\npublic abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\\n\\n    // ......\\n\\n    // Read data from database to local cache (in this case, memory)\\n    private void refreshLocalCache() {\\n        //update app auth data\\n        this.updateAppAuthCache();\\n        //update plugin data\\n        this.updatePluginCache();\\n        //update rule data\\n        this.updateRuleCache();\\n        //update selector data\\n        this.updateSelectorCache();\\n        //update meta data\\n        this.updateMetaDataCache();\\n    }\\n\\n    // ......\\n}\\n```\\n\\nThe logic of the 5 update methods is similar, call the `service` method to get the data and put it into the memory `CACHE`. Take the updateRuleData method `updateRuleCache()` for example, pass in the rule enumeration type and call `ruleService.listAll()` to get all the rule data from the database.\\n\\n```java\\n    /**\\n     * Update rule cache.\\n     */\\n    protected void updateRuleCache() {\\n        this.updateCache(ConfigGroupEnum.RULE, ruleService.listAll());\\n    }\\n```\\n\\n\\n- updateCache()\\n\\nUpdate the data in memory using the data in the database.\\n\\n```java\\npublic abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\\n\\n    // ......\\n\\n    // cache Map\\n    protected static final ConcurrentMap<String, ConfigDataCache> CACHE = new ConcurrentHashMap<>();\\n\\n    /**\\n     * if md5 is not the same as the original, then update lcoal cache.\\n     * @param group ConfigGroupEnum\\n     * @param <T> the type of class\\n     * @param data the new config data\\n     */\\n    protected <T> void updateCache(final ConfigGroupEnum group, final List<T> data) {\\n        // data serialization\\n        String json = GsonUtils.getInstance().toJson(data);\\n        // pass in md5 value and modification time\\n        ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());\\n        // update group data\\n        ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);\\n        log.info(\\"update config cache[{}], old: {}, updated: {}\\", group, oldVal, newVal);\\n    }\\n\\n    // ......\\n}\\n```\\n\\nThe initialization process is to start periodic tasks to update the memory data by fetching data from the database at regular intervals.\\n\\nNext, we start the analysis of two interfaces.\\n\\n- `/configs/listener`: determines if the group data has changed.\\n- `/configs/fetch`: fetching the changed group data.\\n\\n#### 3.3  Data change polling interface\\n\\n- `/configs/listener`: determines if the group data has changed.\\n\\nThe interface class is `ConfigController`, which only takes effect when using `http long polling` for data synchronization. The interface method `listener()` has no other logic and calls the `doLongPolling()` method directly.\\n\\n```java\\n   \\n/**\\n * This Controller only when HttpLongPollingDataChangedListener exist, will take effect.\\n */\\n@ConditionalOnBean(HttpLongPollingDataChangedListener.class)\\n@RestController\\n@RequestMapping(\\"/configs\\")\\npublic class ConfigController {\\n\\n    private final HttpLongPollingDataChangedListener longPollingListener;\\n\\n    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {\\n        this.longPollingListener = longPollingListener;\\n    }\\n    \\n    // Omit other logic\\n\\n    /**\\n     * Listener.\\n     * Listen for data changes and perform long polling\\n     * @param request  the request\\n     * @param response the response\\n     */\\n    @PostMapping(value = \\"/listener\\")\\n    public void listener(final HttpServletRequest request, final HttpServletResponse response) {\\n        longPollingListener.doLongPolling(request, response);\\n    }\\n\\n}\\n```\\n\\n- HttpLongPollingDataChangedListener#doLongPolling()\\n\\nPerform long polling tasks: If there are data changes, they will be responded to the client (in this case, the gateway side) immediately. Otherwise, the client will be blocked until there is a data change or a timeout.\\n\\n```java\\npublic class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {\\n\\n    // ......\\n\\n    /**\\n     * Execute long polling: If there is a data change, it will be responded to the client (here is the gateway side) immediately.\\n     * Otherwise, the client will otherwise remain blocked until there is a data change or a timeout.\\n     * @param request\\n     * @param response\\n     */\\n    public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {\\n        // compare group md5\\n        // Compare the md5, determine whether the data of the gateway and the data of the admin side are consistent, and get the data group that has changed\\n        List<ConfigGroupEnum> changedGroup = compareChangedGroup(request);\\n        String clientIp = getRemoteIp(request);\\n        // response immediately.\\n        // Immediate response to the gateway if there is changed data\\n        if (CollectionUtils.isNotEmpty(changedGroup)) {\\n            this.generateResponse(response, changedGroup);\\n            Log.info(\\"send response with the changed group, ip={}, group={}\\", clientIp, changedGroup);\\n            return;\\n        }\\n\\n        // No change, then the client (in this case the gateway) is put into the blocking queue\\n        // listen for configuration changed.\\n        final AsyncContext asyncContext = request.startAsync();\\n        // AsyncContext.settimeout() does not timeout properly, so you have to control it yourself\\n        asyncContext.setTimeout(0L);\\n        // block client\'s thread.\\n        scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));\\n    }\\n}\\n```\\n\\n- HttpLongPollingDataChangedListener#compareChangedGroup()\\n\\nTo determine whether the group data has changed, the judgment logic is to compare the `md5` value and `lastModifyTime` at the gateway side and the `admin` side.\\n\\n- If the `md5` value is different, then it needs to be updated.\\n- If the `lastModifyTime` on the `admin` side is greater than the `lastModifyTime` on the gateway side, then it needs to be updated.\\n\\n```java\\n /**\\n     * Determine if the group data has changed\\n     * @param request\\n     * @return\\n     */\\n    private List<ConfigGroupEnum> compareChangedGroup(final HttpServletRequest request) {\\n        List<ConfigGroupEnum> changedGroup = new ArrayList<>(ConfigGroupEnum.values().length);\\n        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {\\n            // The md5 value and lastModifyTime of the data on the gateway side\\n            String[] params = StringUtils.split(request.getParameter(group.name()), \',\');\\n            if (params == null || params.length != 2) {\\n                throw new ShenyuException(\\"group param invalid:\\" + request.getParameter(group.name()));\\n            }\\n            String clientMd5 = params[0];\\n            long clientModifyTime = NumberUtils.toLong(params[1]);\\n            ConfigDataCache serverCache = CACHE.get(group.name());\\n            // do check. determine if the group data has changed\\n            if (this.checkCacheDelayAndUpdate(serverCache, clientMd5, clientModifyTime)) {\\n                changedGroup.add(group);\\n            }\\n        }\\n        return changedGroup;\\n    }\\n```\\n\\n- LongPollingClient\\n\\nNo change data, then the client (in this case the gateway) is put into the blocking queue. The blocking time is 60 seconds, i.e. after 60 seconds remove and respond to the client.\\n\\n```java\\nclass LongPollingClient implements Runnable {\\n      // omitted other logic\\n    \\n        @Override\\n        public void run() {\\n            try {\\n                // Removal after 60 seconds and response to the client\\n                this.asyncTimeoutFuture = scheduler.schedule(() -> {\\n                    clients.remove(LongPollingClient.this);\\n                    List<ConfigGroupEnum> changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());\\n                    sendResponse(changedGroups);\\n                }, timeoutTime, TimeUnit.MILLISECONDS);\\n\\n                // Add to blocking queue\\n                clients.add(this);\\n\\n            } catch (Exception ex) {\\n                log.error(\\"add long polling client error\\", ex);\\n            }\\n        }\\n\\n        /**\\n         * Send response.\\n         *\\n         * @param changedGroups the changed groups\\n         */\\n        void sendResponse(final List<ConfigGroupEnum> changedGroups) {\\n            // cancel scheduler\\n            if (null != asyncTimeoutFuture) {\\n                asyncTimeoutFuture.cancel(false);\\n            }\\n            // Groups responding to changes\\n            generateResponse((HttpServletResponse) asyncContext.getResponse(), changedGroups);\\n            asyncContext.complete();\\n        }\\n    }\\n```\\n\\n\\n#### 3.4  Get Change Data Interface\\n\\n- `/configs/fetch`: get change data;\\n\\nGet the grouped data and return the result according to the parameters passed in by the gateway. The main implementation method is `longPollingListener.fetchConfig()`.\\n\\n```java\\n\\n@ConditionalOnBean(HttpLongPollingDataChangedListener.class)\\n@RestController\\n@RequestMapping(\\"/configs\\")\\npublic class ConfigController {\\n\\n    private final HttpLongPollingDataChangedListener longPollingListener;\\n\\n    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {\\n        this.longPollingListener = longPollingListener;\\n    }\\n\\n    /**\\n     * Fetch configs shenyu result.\\n     * @param groupKeys the group keys\\n     * @return the shenyu result\\n     */\\n    @GetMapping(\\"/fetch\\")\\n    public ShenyuAdminResult fetchConfigs(@NotNull final String[] groupKeys) {\\n        Map<String, ConfigData<?>> result = Maps.newHashMap();\\n        for (String groupKey : groupKeys) {\\n            ConfigData<?> data = longPollingListener.fetchConfig(ConfigGroupEnum.valueOf(groupKey));\\n            result.put(groupKey, data);\\n        }\\n        return ShenyuAdminResult.success(ShenyuResultMessage.SUCCESS, result);\\n    }\\n    \\n  // Other interfaces are omitted\\n\\n}\\n```\\n\\n- AbstractDataChangedListener#fetchConfig()\\n\\nData fetching is taken directly from `CACHE`, and then matched and encapsulated according to different grouping types.\\n\\n```java\\npublic abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {\\n    \\n    // ......\\n    \\n    /**\\n     * fetch configuration from cache.\\n     * @param groupKey the group key\\n     * @return the configuration data\\n     */\\n    public ConfigData<?> fetchConfig(final ConfigGroupEnum groupKey) {\\n        // get data from CACHE\\n        ConfigDataCache config = CACHE.get(groupKey.name());\\n        switch (groupKey) {\\n            case APP_AUTH: // app auth data\\n                return buildConfigData(config, AppAuthData.class);\\n            case PLUGIN: // plugin data\\n                return buildConfigData(config, PluginData.class);\\n            case RULE:   // rule data\\n                return buildConfigData(config, RuleData.class);\\n            case SELECTOR:  // selector data\\n                return buildConfigData(config, SelectorData.class);\\n            case META_DATA: // meta data \\n                return buildConfigData(config, MetaData.class);\\n            default:  // other data type, throw exception\\n                throw new IllegalStateException(\\"Unexpected groupKey: \\" + groupKey);\\n        }\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n#### 3.5 Data Change\\n\\nIn the previous `websocket` data synchronization and `zookeeper` data synchronization source code analysis article, we know that the `admin` side data synchronization design structure is as follows.\\n\\n![](/img/activities/code-analysis-http-data-sync/data-changed-listener-admin.png)\\n\\nVarious data change listeners are subclasses of `DataChangedListener`.\\n\\nWhen the data is modified on the `admin` side, event notifications are sent through the `Spring` event handling mechanism. The sending logic is as follows.\\n\\n```java\\n\\n/**\\n * Event forwarders, which forward the changed events to each ConfigEventListener.\\n * Data change event distributor: synchronize the change data to ShenYu gateway when there is a data change in admin side\\n * Data changes rely on Spring\'s event-listening mechanism: ApplicationEventPublisher --\x3e ApplicationEvent --\x3e ApplicationListener\\n *\\n */\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  // other logic omitted\\n\\n    /**\\n     * Call this method when there are data changes\\n     * @param event\\n     */\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listeners (it\'s generally good to use a kind of data synchronization)\\n        for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n            switch (event.getGroupKey()) {\\n                case APP_AUTH: // app auth data\\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n                    break;\\n                case PLUGIN:  // plugin data\\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n                    break;\\n                case RULE:    // rule data\\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n                    break;\\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    // pull and save API document on seletor changed\\n                    applicationContext.getBean(LoadServiceDocEntry.class).loadDocOnSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    break;\\n                case META_DATA:  // meta data\\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n                    break;\\n                default:  // other data type, throw exception\\n                    throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSuppose, the plugin information is modified and the data is synchronized by `http long polling`, then the actual call to `listener.onPluginChanged()` is `org.apache.shenyu.admin.listener. AbstractDataChangedListener#onPluginChanged`.\\n\\n```java\\n    /**\\n     * In the operation of the admin, there is an update of the plugin occurred\\n     * @param changed   the changed\\n     * @param eventType the event type\\n     */\\n    @Override\\n    public void onPluginChanged(final List<PluginData> changed, final DataEventTypeEnum eventType) {\\n        if (CollectionUtils.isEmpty(changed)) {\\n            return;\\n        }\\n        // update CACHE\\n        this.updatePluginCache();\\n        // execute change task\\n        this.afterPluginChanged(changed, eventType);\\n    }\\n```\\n\\nThere are two processing operations, one is to update the memory `CACHE`, which was analyzed earlier, and the other is to execute the change task, which is executed in the thread pool.\\n\\n- HttpLongPollingDataChangedListener#afterPluginChanged()\\n\\n```java\\n    @Override\\n    protected void afterPluginChanged(final List<PluginData> changed, final DataEventTypeEnum eventType) {\\n        // execute by thread pool\\n        scheduler.execute(new DataChangeTask(ConfigGroupEnum.PLUGIN));\\n    }\\n```\\n\\n- DataChangeTask\\n\\nData change task: remove the clients in the blocking queue in turn and send a response to notify the gateway that a group of data has changed.\\n\\n```java\\nclass DataChangeTask implements Runnable {\\n\\t\\t//other logic omitted\\n  \\n        @Override\\n        public void run() {\\n            // If the client in the blocking queue exceeds the given value of 100, it is executed in batches\\n            if (clients.size() > httpSyncProperties.getNotifyBatchSize()) {\\n                List<LongPollingClient> targetClients = new ArrayList<>(clients.size());\\n                clients.drainTo(targetClients);\\n                List<List<LongPollingClient>> partitionClients = Lists.partition(targetClients, httpSyncProperties.getNotifyBatchSize());\\n               // batch execution\\n                partitionClients.forEach(item -> scheduler.execute(() -> doRun(item)));\\n            } else {\\n                // execute task\\n                doRun(clients);\\n            }\\n        }\\n\\n        private void doRun(final Collection<LongPollingClient> clients) {\\n            // Notify all clients that a data change has occurred\\n            for (Iterator<LongPollingClient> iter = clients.iterator(); iter.hasNext();) {\\n                LongPollingClient client = iter.next();\\n                iter.remove();\\n                // send response to client\\n                client.sendResponse(Collections.singletonList(groupKey));\\n                Log.info(\\"send response with the changed group,ip={}, group={}, changeTime={}\\", client.ip, groupKey, changeTime);\\n            }\\n        }\\n    }\\n```\\n\\nAt this point, the data synchronization logic on the `admin` side is analyzed. In the `http long polling` based data synchronization is, it has three main functions.\\n\\n- providing a data change listening interface.\\n- providing the interface to get the changed data.\\n- When there is a data change, remove the client in the blocking queue and respond to the result.\\n\\nFinally, three diagrams describe the long polling task flow on the `admin` side.\\n\\n- `/configs/listener` data change listener interface.\\n\\n![](/img/activities/code-analysis-http-data-sync/http-long-polling-listener-en.png)\\n\\n- `/configs/fetch` fetch change data interface.\\n\\n![](/img/activities/code-analysis-http-data-sync/http-long-polling-fetch-en.png)\\n\\n- Update data in the admin backend management system for data synchronization.\\n\\n![](/img/activities/code-analysis-http-data-sync/http-long-polling-admin-update-en.png)\\n\\n\\n### 4. Summary\\n\\nThis article focuses on the source code analysis of `http long polling` data synchronization in the `ShenYu` gateway. The main knowledge points involved are as follows.\\n\\n- `http long polling` is initiated by the gateway side, which constantly requests the `admin` side.\\n- change data at group granularity (authentication information, plugins, selectors, rules, metadata).\\n- `http long polling` results in getting only the change group, and another request needs to be initiated to get the group data.\\n- Whether the data is updated or not is determined by the `md5` value and the modification time `lastModifyTime`."},{"id":"/DataSync-SourceCode-Analysis-Nacos-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync.md","title":"Nacos Data Synchronization Source Code Analysis","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"nacos","permalink":"/blog/tags/nacos"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":21.945,"hasTruncateMarker":false,"authors":[{"name":"4zd","title":"Apache ShenYu Contributor","url":"https://github.com/4zd"}],"frontMatter":{"title":"Nacos Data Synchronization Source Code Analysis","author":"4zd","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/4zd","tags":["nacos","data sync","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Http Long Polling Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Http-Data-Sync"},"nextItem":{"title":"WebSocket Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\nIn `ShenYu` gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for `ZooKeeper`, `WebSocket`, `http long poll`, `Nacos`, `etcd` and `Consul`. The main content of this article is based on `Nacos` data synchronization source code analysis.\\n\\n> This paper based on `shenyu-2.4.0` version of the source code analysis, the official website of the introduction of please refer to the [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/) .\\n\\n### 1. About Nacos\\n\\n[`Nacos`](https://github.com/alibaba/nacos)  can be used for dynamic service discovery and configuration and service management. `Shenyu` use `Nacos` as an option to sync data.\\n\\n### 2. Admin Data Sync\\n\\nWe traced the source code from a real case, such as updating a selector data in the `Divide` plugin to a weight of 90 in a background administration system:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/update-selector-en.png)\\n\\n#### 2.1 Accept Data\\n\\n- SelectorController.createSelector()\\n\\nEnter the createSelector() method of the `SelectorController` class, which validates data, adds or updates data, and returns results.\\n\\n```java\\n@Validated\\n@RequiredArgsConstructor\\n@RestController\\n@RequestMapping(\\"/selector\\")\\npublic class SelectorController {\\n    \\n    @PutMapping(\\"/{id}\\")\\n    public ShenyuAdminResult updateSelector(@PathVariable(\\"id\\") final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {\\n        // set the current selector data ID\\n        selectorDTO.setId(id);\\n        // create or update operation\\n        Integer updateCount = selectorService.createOrUpdate(selectorDTO);\\n        // return result \\n        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n#### 2.2 Handle Data\\n\\n- SelectorServiceImpl.createOrUpdate()\\n\\nConvert data in the `SelectorServiceImpl` class using the `createOrUpdate()` method, save it to the database, publish the event, update `upstream`.\\n\\n```java\\n@RequiredArgsConstructor\\n@Service\\npublic class SelectorServiceImpl implements SelectorService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n    @Override\\n    @Transactional(rollbackFor = Exception.class)\\n    public int createOrUpdate(final SelectorDTO selectorDTO) {\\n        int selectorCount;\\n        // build data DTO --\x3e DO\\n        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n        List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n        // insert or update ?\\n        if (StringUtils.isEmpty(selectorDTO.getId())) {\\n            //  insert into data\\n            selectorCount = selectorMapper.insertSelective(selectorDO);\\n            // insert into condition data\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n            });\\n            // check selector add\\n            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() > 0) {\\n                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();\\n                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());\\n                dataPermissionDTO.setDataId(selectorDO.getId());\\n                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);\\n                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));\\n            }\\n\\n        } else {\\n            // update data, delete and then insert\\n            selectorCount = selectorMapper.updateSelective(selectorDO);\\n            //delete rule condition then add\\n            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);\\n                selectorConditionMapper.insertSelective(selectorConditionDO);\\n            });\\n        }\\n        // publish event\\n        publishEvent(selectorDO, selectorConditionDTOs);\\n\\n        // update upstream\\n        updateDivideUpstream(selectorDO);\\n        return selectorCount;\\n    }\\n    \\n    // ......\\n    \\n}\\n```\\n\\nIn the `Service` class to persist data, i.e. to the database, this should be familiar, not expand. The update upstream operation is analyzed in the corresponding section below, focusing on the publish event operation, which performs data synchronization.\\n\\nThe logic of the `publishEvent()`  method is to find the plugin corresponding to the selector, build the conditional data, and publish the change data.\\n\\n```java\\n       private void publishEvent(final SelectorDO selectorDO, final List<SelectorConditionDTO> selectorConditionDTOs) {\\n        // find plugin of selector\\n        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\\n        // build condition data\\n        List<ConditionData> conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());\\n        // publish event\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\\n                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));\\n    }\\n```\\n\\nChange data released by `eventPublisher.PublishEvent()` is complete, the `eventPublisher` object is a `ApplicationEventPublisher` class, The fully qualified class name is `org.springframework.context.ApplicationEventPublisher`. Here we see that publishing data is done through `Spring` related functionality.\\n\\n> `ApplicationEventPublisher`\uff1a\\n>\\n> When a state change, the publisher calls `ApplicationEventPublisher` of `publishEvent` method to release an event, `Spring` container broadcast event for all observers, The observer\'s `onApplicationEvent` method is called to pass the event object to the observer. There are two ways to call `publishEvent` method, one is to implement the interface by the container injection `ApplicationEventPublisher` object and then call the method, the other is a direct call container, the method of two methods of publishing events not too big difference.\\n>\\n> - `ApplicationEventPublisher`: publish event;\\n> - `ApplicationEvent`: `Spring` event, record the event source, time, and data;\\n> - `ApplicationListener`: event listener, observer.\\n\\nIn Spring event publishing mechanism, there are three objects,\\n\\nAn object is a publish event `ApplicationEventPublisher`, in `ShenYu` through the constructor in the injected a `eventPublisher`.\\n\\nThe other object is `ApplicationEvent` , inherited from `ShenYu` through `DataChangedEvent`, representing the event object.\\n\\n```java\\npublic class DataChangedEvent extends ApplicationEvent {\\n//......\\n}\\n```\\n\\nThe last object is `ApplicationListener` in `ShenYu` in through `DataChangedEventDispatcher` class implements this interface, as the event listener, responsible for handling the event object.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n    //......\\n    \\n}\\n```\\n\\n#### 2.3 Dispatch Data\\n\\n- DataChangedEventDispatcher.onApplicationEvent()\\n\\nReleased when the event is completed, will automatically enter the `DataChangedEventDispatcher` class `onApplicationEvent()` method of handling events.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  /**\\n     * This method is called when there are data changes\\n   * @param event\\n     */\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n      for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n        switch (event.getGroupKey()) {\\n                case APP_AUTH: // app auth data\\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n                    break;\\n                case PLUGIN:  // plugin data\\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n                    break;\\n                case RULE:    // rule data\\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n                    break;\\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    break;\\n                case META_DATA:  // metadata\\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n                    break;\\n                default:  // other types throw exception\\n                  throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n            }\\n        }\\n    }\\n    \\n}\\n```\\n\\nWhen there is a data change, the `onApplicationEvent` method is called and all the data change listeners are iterated to determine the data type and handed over to the appropriate data listener for processing.\\n\\nShenYu groups all the data into five categories: `APP_AUTH`, `PLUGIN`, `RULE`, `SELECTOR` and `META_DATA`.\\n\\nHere the data change listener (`DataChangedListener`) is an abstraction of the data synchronization policy. Its concrete implementation is:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/data-changed-listener.png)\\n\\nThese implementation classes are the synchronization strategies currently supported by ShenYu:\\n\\n- `WebsocketDataChangedListener`: data synchronization based on Websocket;\\n- `ZookeeperDataChangedListener`:data synchronization based on Zookeeper;\\n- `ConsulDataChangedListener`: data synchronization based on Consul;\\n- `EtcdDataDataChangedListener`\uff1adata synchronization based on etcd;\\n- `HttpLongPollingDataChangedListener`\uff1adata synchronization based on http long polling;\\n- `NacosDataChangedListener`\uff1adata synchronization based on nacos;\\n\\nGiven that there are so many implementation strategies, how do you decide which to use?\\n\\nBecause this paper is based on `nacos` data synchronization source code analysis, so here to `NacosDataChangedListener` as an example, the analysis of how it is loaded and implemented.\\n\\nA global search in the source code project shows that its implementation is done in the `DataSyncConfiguration` class.\\n\\n```java\\n/**\\n * The type Data sync configuration.\\n */\\n@Configuration\\npublic class DataSyncConfiguration {\\n\\t// some codes omitted here\\n  \\n    /**\\n     * The type Nacos listener.\\n     */\\n    @Configuration\\n    @ConditionalOnProperty(prefix = \\"shenyu.sync.nacos\\", name = \\"url\\")\\n    @Import(NacosConfiguration.class)\\n    static class NacosListener {\\n\\n        /**\\n         * Data changed listener data changed listener.\\n         *\\n         * @param configService the config service\\n         * @return the data changed listener\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(NacosDataChangedListener.class)\\n        public DataChangedListener nacosDataChangedListener(final ConfigService configService) {\\n            return new NacosDataChangedListener(configService);\\n        }\\n\\n        /**\\n         * Nacos data init zookeeper data init.\\n         *\\n         * @param configService the config service\\n         * @param syncDataService the sync data service\\n         * @return the nacos data init\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(NacosDataInit.class)\\n        public NacosDataInit nacosDataInit(final ConfigService configService, final SyncDataService syncDataService) {\\n            return new NacosDataInit(configService, syncDataService);\\n        }\\n    }  \\n  \\n  // some codes omitted here\\n}\\n\\n```\\n\\nThis configuration class is implemented through the SpringBoot conditional assembly class. The `NacosListener` class has several annotations:\\n\\n- `@Configuration`: Configuration file, application context;\\n\\n- `@ConditionalOnProperty(prefix = \\"shenyu.sync.nacos\\", name = \\"url\\")`: attribute condition. The configuration class takes effect only when the condition is met. That is, when we have the following configuration, `nacos` is used for data synchronization.\\n\\n  ```properties\\n  shenyu:  \\n    sync:\\n       nacos:\\n            url: localhost:8848\\n  ```\\n  \\n- `@Import(NacosConfiguration.class)`\uff1aimport  a configration class `NacosConfiguration`, which provides a method `ConfigService nacosConfigService(final NacosProperties nacosProp)` to convert the nacos properties to a bean with the `ConfigService` type. We would take a look at how to generate the bean and then analyze the property configuration class and the property configuration file.  \\n\\n```java\\n/**\\n * Nacos configuration.\\n */\\n@EnableConfigurationProperties(NacosProperties.class)\\npublic class NacosConfiguration {\\n\\n    /**\\n     * register configService in spring ioc.\\n     *\\n     * @param nacosProp the nacos configuration\\n     * @return ConfigService {@linkplain ConfigService}\\n     * @throws Exception the exception\\n     */\\n    @Bean\\n    @ConditionalOnMissingBean(ConfigService.class)\\n    public ConfigService nacosConfigService(final NacosProperties nacosProp) throws Exception {\\n        Properties properties = new Properties();\\n        if (nacosProp.getAcm() != null && nacosProp.getAcm().isEnabled()) {\\n            // Use aliyun ACM service\\n            properties.put(PropertyKeyConst.ENDPOINT, nacosProp.getAcm().getEndpoint());\\n            properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getAcm().getNamespace());\\n            // Use subaccount ACM administrative authority\\n            properties.put(PropertyKeyConst.ACCESS_KEY, nacosProp.getAcm().getAccessKey());\\n            properties.put(PropertyKeyConst.SECRET_KEY, nacosProp.getAcm().getSecretKey());\\n        } else {\\n            properties.put(PropertyKeyConst.SERVER_ADDR, nacosProp.getUrl());\\n            if (StringUtils.isNotBlank(nacosProp.getNamespace())) {\\n                properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getNamespace());\\n            }\\n            if (StringUtils.isNotBlank(nacosProp.getUsername())) {\\n                properties.put(PropertyKeyConst.USERNAME, nacosProp.getUsername());\\n            }\\n            if (StringUtils.isNotBlank(nacosProp.getPassword())) {\\n                properties.put(PropertyKeyConst.PASSWORD, nacosProp.getPassword());\\n            }\\n        }\\n        return NacosFactory.createConfigService(properties);\\n    }\\n}\\n```\\n\\nThere are two steps in this method. Firstly, `Properties` object is generated and populated with the specified nacos path value and authority values on whether the alyun ACM service is used. Secondly, the nacos factory class would use its static factory method to create a `configService` object via reflect methods and then populate the object with the `Properties` object generated in the first step.\\n\\nNow, let\'s analyze the `NacosProperties` class and its counterpart property file.\\n\\n```java\\n/**\\n * The type Nacos config.\\n */\\n@ConfigurationProperties(prefix = \\"shenyu.sync.nacos\\")\\npublic class NacosProperties {\\n\\n    private String url;\\n\\n    private String namespace;\\n\\n    private String username;\\n\\n    private String password;\\n\\n    private NacosACMProperties acm;\\n\\n    /**\\n     * Gets the value of url.\\n     *\\n     * @return the value of url\\n     */\\n    public String getUrl() {\\n        return url;\\n    }\\n\\n    /**\\n     * Sets the url.\\n     *\\n     * @param url url\\n     */\\n    public void setUrl(final String url) {\\n        this.url = url;\\n    }\\n\\n    /**\\n     * Gets the value of namespace.\\n     *\\n     * @return the value of namespace\\n     */\\n    public String getNamespace() {\\n        return namespace;\\n    }\\n\\n    /**\\n     * Sets the namespace.\\n     *\\n     * @param namespace namespace\\n     */\\n    public void setNamespace(final String namespace) {\\n        this.namespace = namespace;\\n    }\\n\\n    /**\\n     * Gets the value of username.\\n     *\\n     * @return the value of username\\n     */\\n    public String getUsername() {\\n        return username;\\n    }\\n\\n    /**\\n     * Sets the username.\\n     *\\n     * @param username username\\n     */\\n    public void setUsername(final String username) {\\n        this.username = username;\\n    }\\n\\n    /**\\n     * Gets the value of password.\\n     *\\n     * @return the value of password\\n     */\\n    public String getPassword() {\\n        return password;\\n    }\\n\\n    /**\\n     * Sets the password.\\n     *\\n     * @param password password\\n     */\\n    public void setPassword(final String password) {\\n        this.password = password;\\n    }\\n\\n    /**\\n     * Gets the value of acm.\\n     *\\n     * @return the value of acm\\n     */\\n    public NacosACMProperties getAcm() {\\n        return acm;\\n    }\\n\\n    /**\\n     * Sets the acm.\\n     *\\n     * @param acm acm\\n     */\\n    public void setAcm(final NacosACMProperties acm) {\\n        this.acm = acm;\\n    }\\n\\n    public static class NacosACMProperties {\\n\\n        private boolean enabled;\\n\\n        private String endpoint;\\n\\n        private String namespace;\\n\\n        private String accessKey;\\n\\n        private String secretKey;\\n\\n        /**\\n         * Gets the value of enabled.\\n         *\\n         * @return the value of enabled\\n         */\\n        public boolean isEnabled() {\\n            return enabled;\\n        }\\n\\n        /**\\n         * Sets the enabled.\\n         *\\n         * @param enabled enabled\\n         */\\n        public void setEnabled(final boolean enabled) {\\n            this.enabled = enabled;\\n        }\\n\\n        /**\\n         * Gets the value of endpoint.\\n         *\\n         * @return the value of endpoint\\n         */\\n        public String getEndpoint() {\\n            return endpoint;\\n        }\\n\\n        /**\\n         * Sets the endpoint.\\n         *\\n         * @param endpoint endpoint\\n         */\\n        public void setEndpoint(final String endpoint) {\\n            this.endpoint = endpoint;\\n        }\\n\\n        /**\\n         * Gets the value of namespace.\\n         *\\n         * @return the value of namespace\\n         */\\n        public String getNamespace() {\\n            return namespace;\\n        }\\n\\n        /**\\n         * Sets the namespace.\\n         *\\n         * @param namespace namespace\\n         */\\n        public void setNamespace(final String namespace) {\\n            this.namespace = namespace;\\n        }\\n\\n        /**\\n         * Gets the value of accessKey.\\n         *\\n         * @return the value of accessKey\\n         */\\n        public String getAccessKey() {\\n            return accessKey;\\n        }\\n\\n        /**\\n         * Sets the accessKey.\\n         *\\n         * @param accessKey accessKey\\n         */\\n        public void setAccessKey(final String accessKey) {\\n            this.accessKey = accessKey;\\n        }\\n\\n        /**\\n         * Gets the value of secretKey.\\n         *\\n         * @return the value of secretKey\\n         */\\n        public String getSecretKey() {\\n            return secretKey;\\n        }\\n\\n        /**\\n         * Sets the secretKey.\\n         *\\n         * @param secretKey secretKey\\n         */\\n        public void setSecretKey(final String secretKey) {\\n            this.secretKey = secretKey;\\n        }\\n    }\\n\\n}\\n```\\n\\nWhen the property `shenyu.sync.nacos.url` is set in the property file, the `shenyu` admin would choose the `nacos` to sync data. At this time, the configuration class `NacosListener` would take effect and a bean with the type `NacosDataChangedListener` and another bean with the type `NacosDataInit` would both be generated.\\n\\n* `nacosDataChangedListener`, the bean with the type `NacosDataChangedListener` , takes the bean with the type `ConfigService` as a member variable. `ConfigService` is an api provided by `nacos` and can be used to send request to nacos server to modify configurations once the `nacosDataChangedListener` has accepted an event and trigger the callback method.\\n\\n* `nacosDataInit`, the bean with the type `NacosDataInit`, takes the bean `configService` and the bean `syncDataService` as memeber variables. It use `configService` to call the `Nacos` api to judge whether the configurations have been initialized, and would use `syncDataService` to refresh them if the answer is no. \\n\\n  As mentioned above, some operations of the  `listener` would be triggered in the event handle method `onApplicationEvent()`. In this example, we update selector data and choose `nacos` to sync data, so the code about logic of the selector data changes in the `NacosDataChangedListener` class would be called.\\n\\n```java\\n    //DataChangedEventDispatcher.java\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n          // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n        for (DataChangedListener listener : listeners) {\\n          // What kind of data has changed\\n          switch (event.getGroupKey()) {\\n                 // some codes omitted\\n                  case SELECTOR:   // selector data\\n                      listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                      break;\\n              }\\n          }\\n      }\\n```\\n\\n\\n#### 2.4 Nacos Data Changed Listener\\n\\n- NacosDataChangedListener.onSelectorChanged()\\n\\nIn the `onSelectorChanged()` method, determine the type of action, whether to refresh synchronization or update or create synchronization. Determine whether the node is in `etcd` based on the current selector data.\\n\\n```java\\n/**\\n * Use nacos to push data changes.\\n */\\npublic class NacosDataChangedListener implements DataChangedListener {\\n    @Override\\n    public void onSelectorChanged(final List<SelectorData> changed, final DataEventTypeEnum eventType) {\\n        updateSelectorMap(getConfig(NacosPathConstants.SELECTOR_DATA_ID));\\n        switch (eventType) {\\n            case DELETE:\\n                changed.forEach(selector -> {\\n                    List<SelectorData> ls = SELECTOR_MAP\\n                            .getOrDefault(selector.getPluginName(), new ArrayList<>())\\n                            .stream()\\n                            .filter(s -> !s.getId().equals(selector.getId()))\\n                            .sorted(SELECTOR_DATA_COMPARATOR)\\n                            .collect(Collectors.toList());\\n                    SELECTOR_MAP.put(selector.getPluginName(), ls);\\n                });\\n                break;\\n            case REFRESH:\\n            case MYSELF:\\n                SELECTOR_MAP.keySet().removeAll(SELECTOR_MAP.keySet());\\n                changed.forEach(selector -> {\\n                    List<SelectorData> ls = SELECTOR_MAP\\n                            .getOrDefault(selector.getPluginName(), new ArrayList<>())\\n                            .stream()\\n                            .sorted(SELECTOR_DATA_COMPARATOR)\\n                            .collect(Collectors.toList());\\n                    ls.add(selector);\\n                    SELECTOR_MAP.put(selector.getPluginName(), ls);\\n                });\\n                break;\\n            default:\\n                changed.forEach(selector -> {\\n                    List<SelectorData> ls = SELECTOR_MAP\\n                            .getOrDefault(selector.getPluginName(), new ArrayList<>())\\n                            .stream()\\n                            .filter(s -> !s.getId().equals(selector.getId()))\\n                            .sorted(SELECTOR_DATA_COMPARATOR)\\n                            .collect(Collectors.toList());\\n                    ls.add(selector);\\n                    SELECTOR_MAP.put(selector.getPluginName(), ls);\\n                });\\n                break;\\n        }\\n        publishConfig(NacosPathConstants.SELECTOR_DATA_ID, SELECTOR_MAP);\\n    }\\n  }\\n```\\n\\nThis is the core part. The variable `changed` represents the list , which needs to be updated, with the elements of the `SelectorData` type. The variable `eventType` represents the event type. The variable `SELECTOR_MAP` is with the type `ConcurrentMap<String, List<SelectorData>>`, so the key of the map is with the `String` type and the value is the selector list of this plugin.  The value of the constant `NacosPathConstants.SELECTOR_DATA_ID` is `shenyu.selector.json`. The steps are as follows, firstly, use the method `getConfig` to call the api of `Nacos` to fetch the config with the `group` value of `shenyu.selector.json` from `Nacos` and call the `updateSelectorMap` method to use the config fetched above to update the `SELECTOR_MAP` so that the we refresh the selector config from `Nacos`. Secondly, we can update `SELECTOR_MAP` according to the event type and then use the `publishConfig` method to call the `Nacos` api to update all the config with the `group` value of `shenyu.selector.json`.\\n\\nAs long as the changed data is correctly written to the `Nacos` node, the `admin` side of the operation is complete. \\n\\nIn our current case, updating one of the selector data in the `Divide` plugin with a weight of 90 updates specific nodes in the graph.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/zookeeper-node.png)\\n\\n\\nWe series the above update flow with a sequence diagram.\\n\\n\\n![](/img/activities/code-analysis-nacos-data-sync/nacos-sync-sequence-admin-en.png)\\n\\n\\n### 3. Gateway Data Sync\\n\\nAssume that the ShenYu gateway is already running properly, and the data synchronization mode is also `nacos`. How does the gateway receive and process the selector data after updating it on the `admin` side and sending the changed data to `nacos`? Let\'s continue our source code analysis to find out.\\n\\n#### 3.1 NacosSyncDataService Accept Data\\n\\nThe gateway side use `NacosSyncDataService` to watch `nacos` and fetch the data update, but before we dive into this part, let us take a look on how the bean with the type `NacosSyncDataService` is generated. The answer is it\'s defined in the Spring config class `NacosSyncDataConfiguration`. Let\'s focus on the annotation `@ConditionalOnProperty(prefix = \\"shenyu.sync.nacos\\", name = \\"url\\")` on the class `NacosSyncDataConfiguration` again. We have met this annotation when we  analyzed the `NacosListener` class on the `Admin` side before, this config class would take effect only and if only the condition on this annotation is matched. In other words, when we have the config as below on the gateway side, the gateway would use `nacos` to sync data and the config class `NacosSyncDataConfiguration` would take effect.\\n\\n```properties\\nshenyu:  \\n  sync:\\n     nacos:\\n          url: localhost:8848\\n```\\n\\n```java\\n/**\\n * Nacos sync data configuration for spring boot.\\n */\\n@Configuration\\n@ConditionalOnClass(NacosSyncDataService.class)\\n@ConditionalOnProperty(prefix = \\"shenyu.sync.nacos\\", name = \\"url\\")\\npublic class NacosSyncDataConfiguration {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(NacosSyncDataConfiguration.class);\\n\\n    /**\\n     * Nacos sync data service.\\n     *\\n     * @param configService     the config service\\n     * @param pluginSubscriber the plugin subscriber\\n     * @param metaSubscribers   the meta subscribers\\n     * @param authSubscribers   the auth subscribers\\n     * @return the sync data service\\n     */\\n    @Bean\\n    public SyncDataService nacosSyncDataService(final ObjectProvider<ConfigService> configService, final ObjectProvider<PluginDataSubscriber> pluginSubscriber,\\n                                           final ObjectProvider<List<MetaDataSubscriber>> metaSubscribers, final ObjectProvider<List<AuthDataSubscriber>> authSubscribers) {\\n        LOGGER.info(\\"you use nacos sync shenyu data.......\\");\\n        return new NacosSyncDataService(configService.getIfAvailable(), pluginSubscriber.getIfAvailable(),\\n                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));\\n    }\\n\\n    /**\\n     * Nacos config service config service.\\n     *\\n     * @param nacosConfig the nacos config\\n     * @return the config service\\n     * @throws Exception the exception\\n     */\\n    @Bean\\n    public ConfigService nacosConfigService(final NacosConfig nacosConfig) throws Exception {\\n        Properties properties = new Properties();\\n        if (nacosConfig.getAcm() != null && nacosConfig.getAcm().isEnabled()) {\\n            properties.put(PropertyKeyConst.ENDPOINT, nacosConfig.getAcm().getEndpoint());\\n            properties.put(PropertyKeyConst.NAMESPACE, nacosConfig.getAcm().getNamespace());\\n            properties.put(PropertyKeyConst.ACCESS_KEY, nacosConfig.getAcm().getAccessKey());\\n            properties.put(PropertyKeyConst.SECRET_KEY, nacosConfig.getAcm().getSecretKey());\\n        } else {\\n            properties.put(PropertyKeyConst.SERVER_ADDR, nacosConfig.getUrl());\\n            if (StringUtils.isNotBlank(nacosConfig.getNamespace())) {\\n                properties.put(PropertyKeyConst.NAMESPACE, nacosConfig.getNamespace());\\n            }\\n            if (nacosConfig.getUsername() != null) {\\n                properties.put(PropertyKeyConst.USERNAME, nacosConfig.getUsername());\\n            }\\n            if (nacosConfig.getPassword() != null) {\\n                properties.put(PropertyKeyConst.PASSWORD, nacosConfig.getPassword());\\n            }\\n        }\\n        return NacosFactory.createConfigService(properties);\\n    }\\n\\n    /**\\n     * Http config http config.\\n     *\\n     * @return the http config\\n     */\\n    @Bean\\n    @ConfigurationProperties(prefix = \\"shenyu.sync.nacos\\")\\n    public NacosConfig nacosConfig() {\\n        return new NacosConfig();\\n    }\\n}\\n```\\n\\nLet\'s focus on the part of code above which is about the  generation of the bean `nacosSyncDataService`:\\n\\n```java\\n@Bean\\npublic SyncDataService nacosSyncDataService(final ObjectProvider<ConfigService> configService, final ObjectProvider<PluginDataSubscriber> pluginSubscriber,\\n                                           final ObjectProvider<List<MetaDataSubscriber>> metaSubscribers, final ObjectProvider<List<AuthDataSubscriber>> authSubscribers) {\\n        LOGGER.info(\\"you use nacos sync shenyu data.......\\");\\n        return new NacosSyncDataService(configService.getIfAvailable(), pluginSubscriber.getIfAvailable(),\\n                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));\\n}\\n```\\n\\nAs we can see, the bean is generated by the construction method of the Class `NacosSyncDataService`. Let\'s dive into the construction method.\\n\\n```java\\npublic NacosSyncDataService(final ConfigService configService, final PluginDataSubscriber pluginDataSubscriber,\\n                                final List<MetaDataSubscriber> metaDataSubscribers, final List<AuthDataSubscriber> authDataSubscribers) {\\n\\n        super(configService, pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\\n        start();\\n}\\n```\\n\\n```java\\n    public void start() {\\n        watcherData(NacosPathConstants.PLUGIN_DATA_ID, this::updatePluginMap);\\n        watcherData(NacosPathConstants.SELECTOR_DATA_ID, this::updateSelectorMap);\\n        watcherData(NacosPathConstants.RULE_DATA_ID, this::updateRuleMap);\\n        watcherData(NacosPathConstants.META_DATA_ID, this::updateMetaDataMap);\\n        watcherData(NacosPathConstants.AUTH_DATA_ID, this::updateAuthMap);\\n    }\\n```\\n\\n```java\\n    protected void watcherData(final String dataId, final OnChange oc) {\\n        Listener listener = new Listener() {\\n            @Override\\n            public void receiveConfigInfo(final String configInfo) {\\n                oc.change(configInfo);\\n            }\\n\\n            @Override\\n            public Executor getExecutor() {\\n                return null;\\n            }\\n        };\\n        oc.change(getConfigAndSignListener(dataId, listener));\\n        LISTENERS.computeIfAbsent(dataId, key -> new ArrayList<>()).add(listener);\\n    }\\n```\\n\\nAs we can see, the construction method calls the `start` method and calls the `watcherData` method to create a listener which relates itself to a callback method `oc`, since we\'re analyzing the changes on the component with the `selector` type, the relative callback method is `updateSelectorMap`. This callback method is used to handle data.\\n\\n\\n#### 3.2 Handle Data\\n\\n- NacosCacheHandler.updateSelectorMap()\\n\\nThe data is not null, and caching the selector data is again handled by `PluginDataSubscriber`.\\n\\n```java\\n    protected void updateSelectorMap(final String configInfo) {\\n        try {\\n            List<SelectorData> selectorDataList = GsonUtils.getInstance().toObjectMapList(configInfo, SelectorData.class).values().stream().flatMap(Collection::stream).collect(Collectors.toList());\\n            selectorDataList.forEach(selectorData -> Optional.ofNullable(pluginDataSubscriber).ifPresent(subscriber -> {\\n                subscriber.unSelectorSubscribe(selectorData);\\n                subscriber.onSelectorSubscribe(selectorData);\\n            }));\\n        } catch (JsonParseException e) {\\n            LOG.error(\\"sync selector data have error:\\", e);\\n        }\\n    }\\n```\\n\\n`PluginDataSubscriber` is an interface, it is only a `CommonPluginDataSubscriber` implementation class, responsible for data processing plugin, selector and rules.\\n\\n\\n\\n#### 3.3 Common Plugin Data Subscriber\\n\\n- PluginDataSubscriber.unSelectorSubscribe()\\n- PluginDataSubscriber.onSelectorSubscribe()\\n\\nIt has no additional logic and calls the `unSelectorSubscribe()`and`subscribeDataHandler()` method directly. Within methods, there are data types (plugins, selectors, or rules) and action types (update or delete) to perform different logic.\\n\\n\\n```java\\n/**\\n * The common plugin data subscriber, responsible for handling all plug-in, selector, and rule information\\n */\\npublic class CommonPluginDataSubscriber implements PluginDataSubscriber {\\n    //......\\n     // handle selector data\\n    @Override\\n    public void onSelectorSubscribe(final SelectoData selectorData) {\\n        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);\\n    }   \\n  \\n    @Override\\n    public void unSelectorSubscribe(final SelectorData selectorData) {\\n        subscribeDataHandler(selectorData, DataEventTypeEnum.DELETE);\\n    } \\n    \\n    // A subscription data handler that handles updates or deletions of data\\n    private <T> void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {\\n        Optional.ofNullable(classData).ifPresent(data -> {\\n            // plugin data\\n            if (data instanceof PluginData) {\\n                PluginData pluginData = (PluginData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                     BaseDataCache.getInstance().cachePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.handlerPlugin(pluginData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.removePlugin(pluginData));\\n                }\\n            } else if (data instanceof SelectorData) {  // selector data\\n                SelectorData selectorData = (SelectorData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it \\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.removeSelector(selectorData));\\n                }\\n            } else if (data instanceof RuleData) {  // rule data\\n                RuleData ruleData = (RuleData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.handlerRule(ruleData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) { // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.removeRule(ruleData));\\n                }\\n            }\\n        });\\n    }\\n    \\n}\\n```\\n\\n#### 3.4 Data cached to Memory\\n\\n\\nAdding a selector will enter the following logic:\\n\\n```java\\n// save the data to gateway memory\\nBaseDataCache.getInstance().cacheSelectData(selectorData);\\n// If each plugin has its own processing logic, then do it\\nOptional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n```\\n\\nOne is to save the data to the gateway\'s memory. BaseDataCache is the class that ultimately caches data, implemented in a singleton pattern. The selector data is stored in the `SELECTOR_MAP` Map. In the subsequent use, also from this data.\\n\\n\\n```java\\npublic final class BaseDataCache {\\n    // private instance\\n    private static final BaseDataCache INSTANCE = new BaseDataCache();\\n  \\t// private constructor\\n    private BaseDataCache() {\\n    }\\n    \\n    /**\\n     * Gets instance.\\n     *  public method\\n     * @return the instance\\n     */\\n    public static BaseDataCache getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n    /**\\n      * A Map of the cache selector data\\n     * pluginName -> SelectorData.\\n     */\\n    private static final ConcurrentMap<String, List<SelectorData>> SELECTOR_MAP = Maps.newConcurrentMap();\\n    \\n    public void cacheSelectData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);\\n    }\\n        \\n   /**\\n     * cache selector data.\\n     * @param data the selector data\\n     */\\n    private void selectorAccept(final SelectorData data) {\\n        String key = data.getPluginName();\\n        if (SELECTOR_MAP.containsKey(key)) { // Update operation, delete before insert\\n            List<SelectorData> existList = SELECTOR_MAP.get(key);\\n            final List<SelectorData> resultList = existList.stream().filter(r -> !r.getId().equals(data.getId())).collect(Collectors.toList());\\n            resultList.add(data);\\n            final List<SelectorData> collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());\\n            SELECTOR_MAP.put(key, collect);\\n        } else {  // Add new operations directly to Map\\n            SELECTOR_MAP.put(key, Lists.newArrayList(data));\\n        }\\n    }\\n    \\n}\\n```\\n\\nSecond, if each plugin has its own processing logic, then do it. Through the `IDEA` editor, you can see that after adding a selector, there are the following plugins and processing. We\'re not going to expand it here.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/handler-selector.png)\\n\\nAfter the above source tracking, and through a practical case, in the `admin` end to update a selector data, the `ZooKeeper` data synchronization process analysis is clear.\\n\\n\\nLet\'s series the data synchronization process on the gateway side through the sequence diagram:\\n\\n\\n![](/img/activities/code-analysis-nacos-data-sync/nacos-sync-sequence-gateway-en.png)\\n\\nThe data synchronization process has been analyzed. In order to prevent the synchronization process from being interrupted, other logic is ignored during the analysis. We have analyzed the process of  gateway synchronization operation initialization in the `start` method of `NacosSyncDataService` class. We also need to analyze the process of Admin synchronization data initialization.\\n\\n\\n### 4. Admin Data Sync  initialization\\n\\nOn the `admin` side, the bean with the type `NacosDataInit`, is defined and generated in the `NacosListener`, if the configuration of the admin side decides to use `nacos` to sync data, when `admin` starts, the current data will be fully synchronized to `nacos`, the implementation logic is as follows:\\n\\n\\n```java\\n\\n/**\\n * The type Nacos data init.\\n */\\npublic class NacosDataInit implements CommandLineRunner {\\n\\n    private static final Logger LOG = LoggerFactory.getLogger(NacosDataInit.class);\\n\\n    private final ConfigService configService;\\n\\n    private final SyncDataService syncDataService;\\n\\n    /**\\n     * Instantiates a new Nacos data init.\\n     * @param configService the nacos config service\\n     * @param syncDataService the sync data service\\n     */\\n    public NacosDataInit(final ConfigService configService, final SyncDataService syncDataService) {\\n        this.configService = configService;\\n        this.syncDataService = syncDataService;\\n    }\\n\\n    @Override\\n    public void run(final String... args) {\\n        String pluginDataId = NacosPathConstants.PLUGIN_DATA_ID;\\n        String authDataId = NacosPathConstants.AUTH_DATA_ID;\\n        String metaDataId = NacosPathConstants.META_DATA_ID;\\n        if (dataIdNotExist(pluginDataId) && dataIdNotExist(authDataId) && dataIdNotExist(metaDataId)) {\\n            syncDataService.syncAll(DataEventTypeEnum.REFRESH);\\n        }\\n    }\\n\\n    private boolean dataIdNotExist(final String pluginDataId) {\\n        try {\\n            String group = NacosPathConstants.GROUP;\\n            long timeout = NacosPathConstants.DEFAULT_TIME_OUT;\\n            return configService.getConfig(pluginDataId, group, timeout) == null;\\n        } catch (NacosException e) {\\n            LOG.error(\\"Get data from nacos error.\\", e);\\n            throw new ShenyuException(e.getMessage());\\n        }\\n    }\\n}\\n```\\n\\nCheck whether there is data in `nacos`, if not, then synchronize.\\n\\n`NacosDataInit` implements the `CommandLineRunner` interface. It is an interface provided by `SpringBoot` that executes the `run()` method after all `Spring Beans` initializations and is often used for initialization operations in a project.\\n\\n\\n- SyncDataService.syncAll()\\n\\nQuery data from the database, and then perform full data synchronization, all authentication information, plugin information, selector information, rule information, and metadata information. Synchronous events are published primarily through `eventPublisher`. After publishing the event via `publishEvent()`, the `ApplicationListener` performs the event change operation. In `ShenYu` is mentioned in `DataChangedEventDispatcher`.\\n\\n```java\\n@Service\\npublic class SyncDataServiceImpl implements SyncDataService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n     /***\\n     * sync all data\\n     * @param type the type\\n     * @return\\n     */\\n    @Override\\n    public boolean syncAll(final DataEventTypeEnum type) {\\n        // app auth data\\n        appAuthService.syncData();\\n        // plugin data\\n        List<PluginData> pluginDataList = pluginService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));\\n        // selector data\\n        List<SelectorData> selectorDataList = selectorService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));\\n        // rule data\\n        List<RuleData> ruleDataList = ruleService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));\\n        // metadata\\n        metaDataService.syncData();\\n        return true;\\n    }\\n    \\n}\\n```\\n\\n\\n### 5. Summary\\n\\nThis paper through a practical case, `nacos` data synchronization principle source code analysis. The main knowledge points involved are as follows:\\n\\n- Data synchronization based on `nacos` is mainly implemented through `watch` mechanism;\\n\\n- Complete event publishing and listening via `Spring`;\\n\\n- Support multiple synchronization strategies through abstract `DataChangedListener` interface, interface oriented programming;\\n\\n- Use singleton design pattern to cache data class `BaseDataCache`;\\n\\n- Loading of configuration classes via conditional assembly of `SpringBoot` and `starter` loading mechanism."},{"id":"/DataSync-SourceCode-Analysis-WebSocket-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync.md","title":"WebSocket Data Synchronization Source Code Analysis","description":"In ShenYu gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for ZooKeeper, WebSocket, http long poll, Nacos, etcd and Consul. The main content of this article is based on WebSocket data synchronization source code analysis.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"websocket","permalink":"/blog/tags/websocket"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":21.235,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"WebSocket Data Synchronization Source Code Analysis","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["websocket","data sync","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Nacos Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync"},"nextItem":{"title":"ZooKeeper Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync"}},"content":"In `ShenYu` gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for `ZooKeeper`, `WebSocket`, `http long poll`, `Nacos`, `etcd` and `Consul`. The main content of this article is based on `WebSocket` data synchronization source code analysis.\\n\\n\\n> This paper based on `shenyu-2.4.0` version of the source code analysis, the official website of the introduction of please refer to the [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/) .\\n\\n\\n### 1. About WebSocket Communication\\n\\nThe WebSocket protocol was born in 2008 and became an international standard in 2011. It can be two-way communication, the server can take the initiative to push information to the client, the client can also take the initiative to send information to the server. The WebSocket protocol is based on the TCP protocol and belongs to the application layer, with low performance overhead and high communication efficiency. The protocol identifier is `ws`.\\n\\n\\n### 2. Admin Data Sync\\n\\nLet\'s trace the source code from a real case, such as adding a selector data in the background management system:\\n\\n![](/img/activities/code-analysis-websocket-data-sync/add-selector.png)\\n\\n#### 2.1 Accept Changed Data\\n\\n- SelectorController.createSelector()\\n\\nEnter the createSelector() method of the `SelectorController` class, which validates data, adds or updates data, and returns results.\\n\\n\\n```java\\n@Validated\\n@RequiredArgsConstructor\\n@RestController\\n@RequestMapping(\\"/selector\\")\\npublic class SelectorController {\\n    \\n    @PostMapping(\\"\\")\\n    public ShenyuAdminResult createSelector(@Valid @RequestBody final SelectorDTO selectorDTO) { // @Valid \u6570\u6821\u9a8c\\n        // create or update data\\n        Integer createCount = selectorService.createOrUpdate(selectorDTO);\\n        // return result\\n        return ShenyuAdminResult.success(ShenyuResultMessage.CREATE_SUCCESS, createCount);\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n\\n\\n#### 2.2 Handle Data\\n\\n- SelectorServiceImpl.createOrUpdate()\\n\\nConvert data in the `SelectorServiceImpl` class using the `createOrUpdate()` method, save it to the database, publish the event, update `upstream`.\\n\\n\\n```java\\n@RequiredArgsConstructor\\n@Service\\npublic class SelectorServiceImpl implements SelectorService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n    @Override\\n    @Transactional(rollbackFor = Exception.class)\\n    public int createOrUpdate(final SelectorDTO selectorDTO) {\\n        int selectorCount;\\n        // build data DTO --\x3e DO\\n        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n        List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n        // insert or update ?\\n        if (StringUtils.isEmpty(selectorDTO.getId())) {\\n            //  insert into data\\n            selectorCount = selectorMapper.insertSelective(selectorDO);\\n            // insert into condition data\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n            });\\n            // check selector add\\n            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() > 0) {\\n                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();\\n                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());\\n                dataPermissionDTO.setDataId(selectorDO.getId());\\n                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);\\n                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));\\n            }\\n\\n        } else {\\n            // update data, delete and then insert\\n            selectorCount = selectorMapper.updateSelective(selectorDO);\\n            //delete rule condition then add\\n            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);\\n                selectorConditionMapper.insertSelective(selectorConditionDO);\\n            });\\n        }\\n        // publish event\\n        publishEvent(selectorDO, selectorConditionDTOs);\\n\\n        // update upstream\\n        updateDivideUpstream(selectorDO);\\n        return selectorCount;\\n    }\\n    \\n    \\n    // ......\\n    \\n}\\n\\n```\\n\\nIn the `Service` class to persist data, i.e. to the database, this should be familiar, not expand. The update upstream operation is analyzed in the corresponding section below, focusing on the publish event operation, which performs data synchronization.\\n\\n\\n\\nThe logic of the `publishEvent()`  method is to find the plugin corresponding to the selector, build the conditional data, and publish the change data.\\n\\n\\n```java\\n       private void publishEvent(final SelectorDO selectorDO, final List<SelectorConditionDTO> selectorConditionDTOs) {\\n        // find plugin of selector\\n        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\\n        // build condition data\\n        List<ConditionData> conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());\\n        // publish event\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\\n                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));\\n    }\\n```\\n\\nChange data released by `eventPublisher.PublishEvent()` is complete, the `eventPublisher` object is a `ApplicationEventPublisher` class, The fully qualified class name is `org.springframework.context.ApplicationEventPublisher`. Here we see that publishing data is done through `Spring` related functionality.\\n\\n\\n> `ApplicationEventPublisher`\uff1a\\n>\\n> When a state change, the publisher calls `ApplicationEventPublisher` of `publishEvent` method to release an event, `Spring` container broadcast event for all observers, The observer\'s `onApplicationEvent` method is called to pass the event object to the observer. There are two ways to call `publishEvent` method, one is to implement the interface by the container injection `ApplicationEventPublisher` object and then call the method, the other is a direct call container, the method of two methods of publishing events not too big difference.\\n> \\n> - `ApplicationEventPublisher`: publish event;\\n> - `ApplicationEvent`: `Spring` event, record the event source, time, and data;\\n> - `ApplicationListener`: event listener, observer.\\n\\nIn Spring event publishing mechanism, there are three objects,\\n\\n\\nAn object is a publish event `ApplicationEventPublisher`, in `ShenYu` through the constructor in the injected a `eventPublisher`.\\n\\n\\nThe other object is `ApplicationEvent` , inherited from `ShenYu` through `DataChangedEvent`, representing the event object.\\n\\n\\n```java\\npublic class DataChangedEvent extends ApplicationEvent {\\n//......\\n}\\n```\\n\\nThe last object is `ApplicationListener` in `ShenYu` in through `DataChangedEventDispatcher` class implements this interface, as the event listener, responsible for handling the event object.\\n\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n    //......\\n    \\n}\\n```\\n\\n\\n\\n#### 2.3 Dispatch Data\\n\\n- DataChangedEventDispatcher.onApplicationEvent()\\n\\nReleased when the event is completed, will automatically enter the `DataChangedEventDispatcher` class `onApplicationEvent()` method of handling events.\\n\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  /**\\n     * This method is called when there are data changes\\n   * @param event\\n     */\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n      for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n        switch (event.getGroupKey()) {\\n                case APP_AUTH: // app auth data\\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n                    break;\\n                case PLUGIN:  // plugin data\\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n                    break;\\n                case RULE:    // rule data\\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n                    break;\\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    break;\\n                case META_DATA:  // metadata\\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n                    break;\\n                default:  // Other types throw exception\\n                  throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n            }\\n        }\\n    }\\n    \\n}\\n```\\n\\nWhen there is a data change, the `onApplicationEvent` method is called and all the data change listeners are iterated to determine the data type and handed over to the appropriate data listener for processing.\\n\\nShenYu groups all the data into five categories: APP_AUTH, PLUGIN, RULE, SELECTOR and META_DATA.\\n\\nHere the data change listener (`DataChangedListener`) is an abstraction of the data synchronization policy. Its concrete implementation is:\\n\\n\\n![](/img/activities/code-analysis-websocket-data-sync/data-changed-listener.png)\\n\\nThese implementation classes are the synchronization strategies currently supported by ShenYu:\\n\\n- `WebsocketDataChangedListener`: data synchronization based on Websocket; \\n- `ZookeeperDataChangedListener`:data synchronization based on Zookeeper; \\n- `ConsulDataChangedListener`: data synchronization based on Consul;\\n- `EtcdDataDataChangedListener`\uff1adata synchronization based on etcd;\\n- `HttpLongPollingDataChangedListener`\uff1adata synchronization based on http long polling;\\n- `NacosDataChangedListener`\uff1adata synchronization based on nacos;\\n\\nGiven that there are so many implementation strategies, how do you decide which to use?\\n\\nBecause this paper is based on `websocket` data synchronization source code analysis, so here to `WebsocketDataChangedListener` as an example, the analysis of how it is loaded and implemented.\\n\\nA global search in the source code project shows that its implementation is done in the `DataSyncConfiguration` class.\\n\\n```java\\n/**\\n * Data Sync Configuration\\n * By springboot conditional assembly\\n * The type Data sync configuration.\\n */\\n@Configuration\\npublic class DataSyncConfiguration {\\n    \\n /**\\n     * The WebsocketListener(default strategy).\\n     */\\n    @Configuration\\n    @ConditionalOnProperty(name = \\"shenyu.sync.websocket.enabled\\", havingValue = \\"true\\", matchIfMissing = true)\\n    @EnableConfigurationProperties(WebsocketSyncProperties.class)\\n    static class WebsocketListener {\\n\\n        /**\\n         * Config event listener data changed listener.\\n         * @return the data changed listener\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(WebsocketDataChangedListener.class)\\n        public DataChangedListener websocketDataChangedListener() {\\n            return new WebsocketDataChangedListener();\\n        }\\n\\n        /**\\n         * Websocket collector.\\n         * Websocket collector class: establish a connection, send a message, close the connection and other operations\\n         * @return the websocket collector\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(WebsocketCollector.class)\\n        public WebsocketCollector websocketCollector() {\\n            return new WebsocketCollector();\\n        }\\n\\n        /**\\n         * Server endpoint exporter \\n         *\\n         * @return the server endpoint exporter\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(ServerEndpointExporter.class)\\n        public ServerEndpointExporter serverEndpointExporter() {\\n            return new ServerEndpointExporter();\\n        }\\n    }\\n    \\n    //......\\n}\\n\\n```\\n\\nThis configuration class is implemented through the `SpringBoot` conditional assembly class. The `WebsocketListener` class has several annotations:\\n\\n\\n- `@Configuration`: Configuration file, application context;\\n\\n- `@ConditionalOnProperty(name = \\"shenyu.sync.websocket.enabled\\", havingValue = \\"true\\", matchIfMissing = true)`: attribute condition. The configuration class takes effect only when the condition is met. That is, when we have the following configuration, `websocket` is used for data synchronization. Note, however, the `matchIfMissing = true` attribute, which means that this configuration class will work if you don\'t have the following configuration. Data synchronization based on `webSocket` is officially recommended and the default.\\n\\n  ```properties\\n  shenyu:  \\n    sync:\\n      websocket:\\n        enabled: true\\n  ```\\n\\n- `@EnableConfigurationProperties`\uff1aenable configuration properties;\\n\\n\\nWhen we take the initiative to configuration, use the `websocket` data synchronization, `WebsocketDataChangedListener` is generated. So in the event handler `onApplicationEvent()`, it goes to the corresponding `listener`. In our case, a selector is to increase the new data, the data by adopting the `websocket`, so, the code will enter the `WebsocketDataChangedListener` selector data change process.\\n\\n\\n```java\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n        for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n             switch (event.getGroupKey()) {\\n                    \\n                // other logic is omitted\\n              case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());   // WebsocketDataChangedListener handle selector data\\n                    break;\\n         }\\n    }\\n```\\n\\n\\n\\n#### 2.4 Websocket Data Changed Listener\\n\\n- WebsocketDataChangedListener.onSelectorChanged()\\n\\nIn the `onSelectorChanged()` method, the data is encapsulated into `WebsocketData` and then sent via `webSocketCollector.send()`.\\n\\n\\n```java\\n    // selector data has been updated\\n    @Override\\n    public void onSelectorChanged(final List<SelectorData> selectorDataList, final DataEventTypeEnum eventType) {\\n        // build WebsocketData \\n        WebsocketData<SelectorData> websocketData =\\n                new WebsocketData<>(ConfigGroupEnum.SELECTOR.name(), eventType.name(), selectorDataList);\\n        // websocket send data\\n        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);\\n    }\\n```\\n\\n\\n\\n#### 2.5 Websocket Send Data\\n\\n- WebsocketCollector.send()\\n\\nIn the `send()` method, the type of synchronization is determined and processed according to the different types.\\n\\n```java\\n@Slf4j\\n@ServerEndpoint(value = \\"/websocket\\", configurator = WebsocketConfigurator.class)\\npublic class WebsocketCollector {\\n    \\n/**\\n     * Send.\\n     *\\n     * @param message the message\\n     * @param type    the type\\n     */\\n    public static void send(final String message, final DataEventTypeEnum type) {\\n        if (StringUtils.isNotBlank(message)) {\\n            // If it\'s MYSELF (first full synchronization)\\n          if (DataEventTypeEnum.MYSELF == type) {\\n                // get the session from ThreadLocal\\n            Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);\\n                if (session != null) {\\n                    // send full data to the session\\n                   sendMessageBySession(session, message);\\n                }\\n            } else {\\n                // subsequent incremental synchronization\\n                // synchronize change data to all sessions\\n               SESSION_SET.forEach(session -> sendMessageBySession(session, message));\\n            }\\n        }\\n    }\\n\\n    private static void sendMessageBySession(final Session session, final String message) {\\n        try {\\n            // The message is sent through the Websocket session\\n           session.getBasicRemote().sendText(message);\\n        } catch (IOException e) {\\n            log.error(\\"websocket send result is exception: \\", e);\\n        }\\n    }\\n}\\n```\\n\\n\\n\\nThe example we give is a new operation, an incremental synchronization, so it goes\\n\\n`SESSION_SET.forEach(session -> sendMessageBySession(session, message));`\\n\\n\\nthen through\\n\\n`session.getBasicRemote().sendText(message);`\\n\\nthe data was sent out.\\n\\nAt this point, when data changes occur on the admin side, the changed data is increments sent to the gateway through the `WebSocket`.\\n\\nAt this point, do you have any questions? For example, where does session come from? How does the gateway establish a connection with admin?\\n\\nDon\'t worry, let\'s do the synchronization analysis on the gateway side.\\n\\nHowever, before continuing with the source code analysis, let\'s use a diagram to string together the above analysis process.\\n\\n![](/img/activities/code-analysis-websocket-data-sync/websocket-data-sync-admin-en.png)\\n\\n\\n\\n### 3. Gateway Data Sync\\n\\nAssume `ShenYu` gateway is already in normal operation, using the data synchronization mode is also `websocket`. How does the gateway receive and process new selector data from admin and send it to the gateway via WebSocket? Let\'s continue our source code analysis to find out.\\n\\n\\n#### 3.1 WebsocketClient Accept Data\\n\\n- ShenyuWebsocketClient.onMessage()\\n\\nThere is a `ShenyuWebsocketClient` class on the gateway, which inherits from `WebSocketClient` and can establish a connection and communicate with `WebSocket`.\\n\\n```java\\npublic final class ShenyuWebsocketClient extends WebSocketClient {\\n  // ......\\n}\\n```\\n\\nAfter sending data via `websocket` on the admin side, `ShenyuWebsocketClient` can receive data via `onMessage()` and then process it itself.\\n\\n\\n```java\\npublic final class ShenyuWebsocketClient extends WebSocketClient {\\n      // execute after receiving the message\\n    @Override\\n    public void onMessage(final String result) {\\n        // handle accept data\\n        handleResult(result);\\n    }\\n    \\n    private void handleResult(final String result) {\\n        // data deserialization\\n        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);\\n        // which data types, plug-ins, selectors, rules...\\n        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());\\n        // which operation type, update, delete...      \\n        String eventType = websocketData.getEventType();\\n        String json = GsonUtils.getInstance().toJson(websocketData.getData());\\n\\n        // handle data\\n        websocketDataHandler.executor(groupEnum, json, eventType);\\n    }\\n}\\n```\\n\\nAfter receiving the data, first has carried on the deserialization operation, read the data type and operation type, then hand over to `websocketDataHandler.executor()` for processing.\\n\\n#### 3.2 Execute Websocket Data Handler\\n\\n- WebsocketDataHandler.executor()\\n\\nA `Websocket` data handler is created in factory mode, providing one handler for each data type:\\n\\n\\n> plugin --\x3e PluginDataHandler;\\n>\\n> selector --\x3e SelectorDataHandler;\\n>\\n> rule --\x3e RuleDataHandler;\\n>\\n> auth --\x3e AuthDataHandler;\\n>\\n> metadata --\x3e MetaDataHandler.\\n\\n```java\\n\\n/**\\n * Create Websocket data handlers through factory mode\\n * The type Websocket cache handler.\\n */\\npublic class WebsocketDataHandler {\\n\\n    private static final EnumMap<ConfigGroupEnum, DataHandler> ENUM_MAP = new EnumMap<>(ConfigGroupEnum.class);\\n\\n    /**\\n     * Instantiates a new Websocket data handler.\\n     * @param pluginDataSubscriber the plugin data subscriber\\n     * @param metaDataSubscribers  the meta data subscribers\\n     * @param authDataSubscribers  the auth data subscribers\\n     */\\n    public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,\\n                                final List<MetaDataSubscriber> metaDataSubscribers,\\n                                final List<AuthDataSubscriber> authDataSubscribers) {\\n        // plugin --\x3e PluginDataHandler\\n        ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));\\n        // selector --\x3e SelectorDataHandler\\n        ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));\\n        // rule --\x3e RuleDataHandler\\n        ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));\\n        // auth --\x3e AuthDataHandler\\n        ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));\\n        // metadata --\x3e MetaDataHandler\\n        ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));\\n    }\\n\\n    /**\\n     * Executor.\\n     *\\n     * @param type      the type\\n     * @param json      the json\\n     * @param eventType the event type\\n     */\\n    public void executor(final ConfigGroupEnum type, final String json, final String eventType) {\\n        // find the corresponding data handler based on the data type\\n        ENUM_MAP.get(type).handle(json, eventType);\\n    }\\n}\\n\\n```\\n\\nDifferent data types have different ways of handling data, so there are different implementation classes. But they also have the same processing logic between them, so they can be implemented through the template approach to design patterns. The same logic is placed in the `handle()` method of the abstract class, and the different logic is handed over to the respective implementation class.\\n\\n\\n![](/img/activities/code-analysis-websocket-data-sync/data-handler.png)\\n\\nIn our case, a new selector is added, so it will be passed to the `SelectorDataHandler` for data processing.\\n\\n\\n#### 3.3 Determine the Event Type\\n\\n- AbstractDataHandler.handle()\\n\\nImplement common logical handling of data changes: invoke different methods based on different operation types.\\n\\n```java\\n\\npublic abstract class AbstractDataHandler<T> implements DataHandler {\\n\\n    /**\\n     * Convert list.\\n     * The different logic is implemented by the respective implementation classes\\n     * @param json the json\\n     * @return the list\\n     */\\n    protected abstract List<T> convert(String json);\\n\\n    /**\\n     * Do refresh.\\n     * The different logic is implemented by the respective implementation classes\\n     * @param dataList the data list\\n     */\\n    protected abstract void doRefresh(List<T> dataList);\\n\\n    /**\\n     * Do update.\\n     * The different logic is implemented by the respective implementation classes\\n     * @param dataList the data list\\n     */\\n    protected abstract void doUpdate(List<T> dataList);\\n\\n    /**\\n     * Do delete.\\n     * The different logic is implemented by the respective implementation classes\\n     * @param dataList the data list\\n     */\\n    protected abstract void doDelete(List<T> dataList);\\n\\n    // General purpose logic, abstract class implementation\\n    @Override\\n    public void handle(final String json, final String eventType) {\\n        List<T> dataList = convert(json);\\n        if (CollectionUtils.isNotEmpty(dataList)) {\\n            DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);\\n            switch (eventTypeEnum) {\\n                case REFRESH:\\n                case MYSELF:\\n                    doRefresh(dataList);  //Refreshes data and synchronizes all data\\n                    break;\\n                case UPDATE:\\n                case CREATE:\\n                    doUpdate(dataList); // Update or create data, incremental synchronization\\n                    break;\\n                case DELETE:\\n                    doDelete(dataList);  // delete data\\n                    break;\\n                default:\\n                    break;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nNew selector data, new operation, through `switch-case` into `doUpdate()` method.\\n\\n#### 3.4 Enter the Specific Data Handler\\n\\n- SelectorDataHandler.doUpdate()\\n\\n```java\\n\\n/**\\n * The type Selector data handler.\\n */\\n@RequiredArgsConstructor\\npublic class SelectorDataHandler extends AbstractDataHandler<SelectorData> {\\n\\n    private final PluginDataSubscriber pluginDataSubscriber;\\n\\n    //......\\n\\n    // update data\\n    @Override\\n    protected void doUpdate(final List<SelectorData> dataList) {\\n        dataList.forEach(pluginDataSubscriber::onSelectorSubscribe);\\n    }\\n}\\n```\\n\\nIterate over the data and enter the `onSelectorSubscribe()` method.\\n\\n- PluginDataSubscriber.onSelectorSubscribe()\\n\\nIt has no additional logic and calls the `subscribeDataHandler()` method directly. Within methods, there are data types (plugins, selectors, or rules) and action types (update or delete) to perform different logic.\\n\\n```java\\n/**\\n * The common plugin data subscriber, responsible for handling all plug-in, selector, and rule information\\n */\\npublic class CommonPluginDataSubscriber implements PluginDataSubscriber {\\n    //......\\n     // handle selector data\\n    @Override\\n    public void onSelectorSubscribe(final SelectoData selectorData) {\\n        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);\\n    }    \\n    \\n    // A subscription data handler that handles updates or deletions of data\\n    private <T> void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {\\n        Optional.ofNullable(classData).ifPresent(data -> {\\n            // plugin data\\n            if (data instanceof PluginData) {\\n                PluginData pluginData = (PluginData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                     BaseDataCache.getInstance().cachePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.handlerPlugin(pluginData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.removePlugin(pluginData));\\n                }\\n            } else if (data instanceof SelectorData) {  // selector data\\n                SelectorData selectorData = (SelectorData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it \\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.removeSelector(selectorData));\\n                }\\n            } else if (data instanceof RuleData) {  // rule data\\n                RuleData ruleData = (RuleData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.handlerRule(ruleData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) { // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.removeRule(ruleData));\\n                }\\n            }\\n        });\\n    }\\n    \\n}\\n```\\n\\nAdding a selector will enter the following logic:\\n\\n```java\\n// save the data to gateway memory\\nBaseDataCache.getInstance().cacheSelectData(selectorData);\\n// If each plugin has its own processing logic, then do it\\nOptional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n```\\n\\nOne is to save the data to the gateway\'s memory. BaseDataCache is the class that ultimately caches data, implemented in a singleton pattern. The selector data is stored in the `SELECTOR_MAP` Map. In the subsequent use, also from this data.\\n\\n\\n```java\\npublic final class BaseDataCache {\\n    // private instance\\n    private static final BaseDataCache INSTANCE = new BaseDataCache();\\n  \\t// private constructor\\n    private BaseDataCache() {\\n    }\\n    \\n    /**\\n     * Gets instance.\\n     *  public method\\n     * @return the instance\\n     */\\n    public static BaseDataCache getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n    /**\\n      * A Map of the cache selector data\\n     * pluginName -> SelectorData.\\n     */\\n    private static final ConcurrentMap<String, List<SelectorData>> SELECTOR_MAP = Maps.newConcurrentMap();\\n    \\n    public void cacheSelectData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);\\n    }\\n        \\n   /**\\n     * cache selector data.\\n     * @param data the selector data\\n     */\\n    private void selectorAccept(final SelectorData data) {\\n        String key = data.getPluginName();\\n        if (SELECTOR_MAP.containsKey(key)) { // Update operation, delete before insert\\n            List<SelectorData> existList = SELECTOR_MAP.get(key);\\n            final List<SelectorData> resultList = existList.stream().filter(r -> !r.getId().equals(data.getId())).collect(Collectors.toList());\\n            resultList.add(data);\\n            final List<SelectorData> collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());\\n            SELECTOR_MAP.put(key, collect);\\n        } else {  // Add new operations directly to Map\\n            SELECTOR_MAP.put(key, Lists.newArrayList(data));\\n        }\\n    }\\n    \\n}\\n```\\n\\nSecond, if each plugin has its own processing logic, then do it. Through the `IDEA` editor, you can see that after adding a selector, there are the following plugins and processing. We\'re not going to expand it here.\\n\\n\\n![](/img/activities/code-analysis-websocket-data-sync/handler-selector.png)\\n\\nAfter the above source tracing, and through a practical case, in the `admin` side to add a selector data, will `websocket` data synchronization process analysis cleared.\\n\\nLet\'s use the following figure to concatenate the data synchronization process on the gateway side:\\n\\n![](/img/activities/code-analysis-websocket-data-sync/websocket-data-sync-gateway-en.png)\\n\\n\\nThe data synchronization process has been analyzed, but there are still some problems that have not been analyzed, that is, how does the gateway establish a connection with admin?\\n\\n### 4. The Gateway Establishes a Websocket Connection with Admin\\n\\n- websocket config\\n\\nWith the following configuration in the gateway configuration file and the dependency introduced, the `websocket` related service is started.\\n\\n\\n```yaml\\nshenyu:\\n    file:\\n      enabled: true\\n    cross:\\n      enabled: true\\n    dubbo :\\n      parameter: multi\\n    sync:\\n      websocket :  # Use websocket for data synchronization\\n        urls: ws://localhost:9095/websocket   # websocket address of admin\\n        allowOrigin: ws://localhost:9195\\n```\\n\\nAdd a dependency on websocket in the gateway.\\n\\n\\n```xml\\n\x3c!--shenyu data sync start use websocket--\x3e\\n<dependency>\\n    <groupId>org.apache.shenyu</groupId>\\n    <artifactId>shenyu-spring-boot-starter-sync-data-websocket</artifactId>\\n    <version>${project.version}</version>\\n</dependency>\\n```\\n\\n- Websocket Data Sync Config\\n\\nThe associated bean is created by conditional assembly of springboot. In the gateway started, if we configure the `shenyu.sync.websocket.urls`, then `websocket` data synchronization configuration will be loaded. The dependency loading is done through the `springboot starter`.\\n\\n\\n```java\\n\\n/**\\n * WebsocketSyncDataService\\n * Conditional injection is implemented through SpringBoot\\n * Websocket sync data configuration for spring boot.\\n */\\n@Configuration\\n@ConditionalOnClass(WebsocketSyncDataService.class)\\n@ConditionalOnProperty(prefix = \\"shenyu.sync.websocket\\", name = \\"urls\\")\\n@Slf4j\\npublic class WebsocketSyncDataConfiguration {\\n\\n    /**\\n     * Websocket sync data service.\\n     * @param websocketConfig   the websocket config\\n     * @param pluginSubscriber the plugin subscriber\\n     * @param metaSubscribers   the meta subscribers\\n     * @param authSubscribers   the auth subscribers\\n     * @return the sync data service\\n     */\\n    @Bean\\n    public SyncDataService websocketSyncDataService(final ObjectProvider<WebsocketConfig> websocketConfig, final ObjectProvider<PluginDataSubscriber> pluginSubscriber,\\n                                           final ObjectProvider<List<MetaDataSubscriber>> metaSubscribers, final ObjectProvider<List<AuthDataSubscriber>> authSubscribers) {\\n        log.info(\\"you use websocket sync shenyu data.......\\");\\n        return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(),\\n                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));\\n    }\\n\\n    /**\\n     * Config websocket config.\\n     *\\n     * @return the websocket config\\n     */\\n    @Bean\\n    @ConfigurationProperties(prefix = \\"shenyu.sync.websocket\\")\\n    public WebsocketConfig websocketConfig() {\\n        return new WebsocketConfig();  \\n    }\\n}\\n```\\n\\nStart a new `spring.factories` file in the `resources/META-INF` directory of your project and specify the configuration classes in the file.\\n\\n![](/img/activities/code-analysis-websocket-data-sync/websocket-springboot-starter.png)\\n\\n\\n- WebsocketSyncDataService\\n\\nThe following things are done in \'WebsocketSyncDataService\' :\\n\\n- Read configuration `urls`, which represent the admin side of the synchronization address, if there are more than one, use \\",\\" split;\\n\\n- Create a scheduling thread pool, with each `admin` assigned one to perform scheduled tasks;\\n\\n- Create `ShenyuWebsocketClient`, assign one to each `admin`, set up `websocket` communication with `admin`;\\n\\n- Start connection with admin end `websocket`;\\n\\n- Executes a scheduled task every 10 seconds. The main function is to determine whether the `websocket` connection has been disconnected, if so, try to reconnect. If not, a `ping-pong` test is performed.\\n\\n```java\\n\\n/**\\n * Websocket sync data service.\\n */\\n@Slf4j\\npublic class WebsocketSyncDataService implements SyncDataService, AutoCloseable {\\n\\n    private final List<WebSocketClient> clients = new ArrayList<>();\\n\\n    private final ScheduledThreadPoolExecutor executor;\\n\\n    /**\\n     * Instantiates a new Websocket sync cache.\\n     * @param websocketConfig      the websocket config\\n     * @param pluginDataSubscriber the plugin data subscriber\\n     * @param metaDataSubscribers  the meta data subscribers\\n     * @param authDataSubscribers  the auth data subscribers\\n     */\\n    public WebsocketSyncDataService(final WebsocketConfig websocketConfig,\\n                                    final PluginDataSubscriber pluginDataSubscriber,\\n                                    final List<MetaDataSubscriber> metaDataSubscribers,\\n                                    final List<AuthDataSubscriber> authDataSubscribers) {\\n        // If there are multiple synchronization addresses on the admin side, use commas (,) to separate them\\n        String[] urls = StringUtils.split(websocketConfig.getUrls(), \\",\\");\\n        // Create a scheduling thread pool, one for each admin\\n        executor = new ScheduledThreadPoolExecutor(urls.length, ShenyuThreadFactory.create(\\"websocket-connect\\", true));\\n        for (String url : urls) {\\n            try {\\n                //Create a WebsocketClient and assign one to each admin\\n                clients.add(new ShenyuWebsocketClient(new URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));\\n            } catch (URISyntaxException e) {\\n                log.error(\\"websocket url({}) is error\\", url, e);\\n            }\\n        }\\n        try {\\n            for (WebSocketClient client : clients) {\\n                // Establish a connection with the WebSocket Server\\n                boolean success = client.connectBlocking(3000, TimeUnit.MILLISECONDS);\\n                if (success) {\\n                    log.info(\\"websocket connection is successful.....\\");\\n                } else {\\n                    log.error(\\"websocket connection is error.....\\");\\n                }\\n\\n                // Run a scheduled task every 10 seconds\\n                // The main function is to check whether the WebSocket connection is disconnected. If the connection is disconnected, retry the connection.\\n                // If it is not disconnected, the ping-pong test is performed\\n                executor.scheduleAtFixedRate(() -> {\\n                    try {\\n                        if (client.isClosed()) {\\n                            boolean reconnectSuccess = client.reconnectBlocking();\\n                            if (reconnectSuccess) {\\n                                log.info(\\"websocket reconnect server[{}] is successful.....\\", client.getURI().toString());\\n                            } else {\\n                                log.error(\\"websocket reconnection server[{}] is error.....\\", client.getURI().toString());\\n                            }\\n                        } else {\\n                            client.sendPing();\\n                            log.debug(\\"websocket send to [{}] ping message successful\\", client.getURI().toString());\\n                        }\\n                    } catch (InterruptedException e) {\\n                        log.error(\\"websocket connect is error :{}\\", e.getMessage());\\n                    }\\n                }, 10, 10, TimeUnit.SECONDS);\\n            }\\n            /* client.setProxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(\\"proxyaddress\\", 80)));*/\\n        } catch (InterruptedException e) {\\n            log.info(\\"websocket connection...exception....\\", e);\\n        }\\n\\n    }\\n\\n    @Override\\n    public void close() {\\n        // close websocket client\\n        for (WebSocketClient client : clients) {\\n            if (!client.isClosed()) {\\n                client.close();\\n            }\\n        }\\n        // close threadpool\\n        if (Objects.nonNull(executor)) {\\n            executor.shutdown();\\n        }\\n    }\\n}\\n```\\n\\n- ShenyuWebsocketClient\\n\\nThe `WebSocket` client created in `ShenYu` to communicate with the `admin` side. After the connection is successfully established for the first time, full data is synchronized and incremental data is subsequently synchronized.\\n\\n```java\\n\\n/**\\n * The type shenyu websocket client.\\n */\\n@Slf4j\\npublic final class ShenyuWebsocketClient extends WebSocketClient {\\n    \\n    private volatile boolean alreadySync = Boolean.FALSE;\\n    \\n    private final WebsocketDataHandler websocketDataHandler;\\n    \\n    /**\\n     * Instantiates a new shenyu websocket client.\\n     * @param serverUri             the server uri  \\n     * @param pluginDataSubscriber the plugin data subscriber \\n     * @param metaDataSubscribers   the meta data subscribers \\n     * @param authDataSubscribers   the auth data subscribers \\n     */\\n    public ShenyuWebsocketClient(final URI serverUri, final PluginDataSubscriber pluginDataSubscriber,final List<MetaDataSubscriber> metaDataSubscribers, final List<AuthDataSubscriber> authDataSubscribers) {\\n        super(serverUri);\\n        this.websocketDataHandler = new WebsocketDataHandler(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);\\n    }\\n\\n    // Execute after the connection is successfully established\\n    @Override\\n    public void onOpen(final ServerHandshake serverHandshake) {\\n        // To prevent re-execution when reconnecting, use alreadySync to determine\\n        if (!alreadySync) {\\n            // Synchronize all data, type MYSELF\\n            send(DataEventTypeEnum.MYSELF.name());\\n            alreadySync = true;\\n        }\\n    }\\n\\n    // Execute after receiving the message\\n    @Override\\n    public void onMessage(final String result) {\\n        // handle data\\n        handleResult(result);\\n    }\\n    \\n    // Execute after shutdown\\n    @Override\\n    public void onClose(final int i, final String s, final boolean b) {\\n        this.close();\\n    }\\n    \\n    // Execute after error\\n    @Override\\n    public void onError(final Exception e) {\\n        this.close();\\n    }\\n    \\n    @SuppressWarnings(\\"ALL\\")\\n    private void handleResult(final String result) {\\n        // Data deserialization\\n        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);\\n        // Which data types, plugins, selectors, rules...\\n        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());\\n        // Which operation type, update, delete...\\n        String eventType = websocketData.getEventType();\\n        String json = GsonUtils.getInstance().toJson(websocketData.getData());\\n\\n        // handle data\\n        websocketDataHandler.executor(groupEnum, json, eventType);\\n    }\\n}\\n\\n```\\n\\n### 5. Summary\\n\\nThis paper through a practical case, the data synchronization principle of websocket source code analysis. The main knowledge points involved are as follows:\\n\\n- `WebSocket` supports bidirectional communication and has good performance. It is recommended.\\n\\n- Complete event publishing and listening via `Spring`;\\n\\n- Support multiple synchronization strategies through abstract `DataChangedListener` interface, interface oriented programming;\\n\\n- Use factory mode to create `WebsocketDataHandler` to handle different data types;\\n\\n- Implement `AbstractDataHandler` using template method design patterns to handle general operation types;\\n\\n- Use singleton design pattern to cache data class `BaseDataCache`;\\n\\n- Loading of configuration classes via conditional assembly of SpringBoot and starter loading mechanism."},{"id":"/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync","metadata":{"permalink":"/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync.md","source":"@site/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync.md","title":"ZooKeeper Data Synchronization Source Code Analysis","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"zookeeper","permalink":"/blog/tags/zookeeper"},{"label":"data sync","permalink":"/blog/tags/data-sync"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":17.96,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"ZooKeeper Data Synchronization Source Code Analysis","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["zookeeper","data sync","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"WebSocket Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync"},"nextItem":{"title":"E2e Test Analysis","permalink":"/blog/E2eTest-Analysis"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\nIn `ShenYu` gateway, data synchronization refers to how to synchronize the updated data to the gateway after the data is sent in the background management system. The Apache ShenYu gateway currently supports data synchronization for `ZooKeeper`, `WebSocket`, `http long poll`, `Nacos`, `etcd` and `Consul`. The main content of this article is based on `WebSocket` data synchronization source code analysis.\\n\\n> This paper based on `shenyu-2.4.0` version of the source code analysis, the official website of the introduction of please refer to the [Data Synchronization Design](https://shenyu.apache.org/docs/design/data-sync/) .\\n\\n### 1. About ZooKeeper\\n\\nApache ZooKeeper is a software project of the Apache Software Foundation that provides open source distributed configuration services, synchronization services, and naming registries for large-scale distributed computing. ZooKeeper nodes store their data in a hierarchical namespace, much like a file system or a prefix tree structure. Clients can read and write on nodes and thus have a shared configuration service in this way.\\n\\n### 2. Admin Data Sync\\n\\nWe traced the source code from a real case, such as updating a selector data in the `Divide` plugin to a weight of 90 in a background administration system:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/update-selector-en.png)\\n\\n#### 2.1 Accept Data\\n\\n- SelectorController.createSelector()\\n\\nEnter the createSelector() method of the `SelectorController` class, which validates data, adds or updates data, and returns results.\\n\\n```java\\n@Validated\\n@RequiredArgsConstructor\\n@RestController\\n@RequestMapping(\\"/selector\\")\\npublic class SelectorController {\\n    \\n    @PutMapping(\\"/{id}\\")\\n    public ShenyuAdminResult updateSelector(@PathVariable(\\"id\\") final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {\\n        // set the current selector data ID\\n        selectorDTO.setId(id);\\n        // create or update operation\\n        Integer updateCount = selectorService.createOrUpdate(selectorDTO);\\n        // return result \\n        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);\\n    }\\n    \\n    // ......\\n}\\n```\\n\\n#### 2.2 Handle Data\\n\\n- SelectorServiceImpl.createOrUpdate()\\n\\nConvert data in the `SelectorServiceImpl` class using the `createOrUpdate()` method, save it to the database, publish the event, update `upstream`.\\n\\n```java\\n@RequiredArgsConstructor\\n@Service\\npublic class SelectorServiceImpl implements SelectorService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n    @Override\\n    @Transactional(rollbackFor = Exception.class)\\n    public int createOrUpdate(final SelectorDTO selectorDTO) {\\n        int selectorCount;\\n        // build data DTO --\x3e DO\\n        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n        List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n        // insert or update ?\\n        if (StringUtils.isEmpty(selectorDTO.getId())) {\\n            //  insert into data\\n            selectorCount = selectorMapper.insertSelective(selectorDO);\\n            // insert into condition data\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n            });\\n            // check selector add\\n            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() > 0) {\\n                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();\\n                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());\\n                dataPermissionDTO.setDataId(selectorDO.getId());\\n                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);\\n                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));\\n            }\\n\\n        } else {\\n            // update data, delete and then insert\\n            selectorCount = selectorMapper.updateSelective(selectorDO);\\n            //delete rule condition then add\\n            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));\\n            selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n                selectorConditionDTO.setSelectorId(selectorDO.getId());\\n                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);\\n                selectorConditionMapper.insertSelective(selectorConditionDO);\\n            });\\n        }\\n        // publish event\\n        publishEvent(selectorDO, selectorConditionDTOs);\\n\\n        // update upstream\\n        updateDivideUpstream(selectorDO);\\n        return selectorCount;\\n    }\\n    \\n    // ......\\n    \\n}\\n```\\n\\nIn the `Service` class to persist data, i.e. to the database, this should be familiar, not expand. The update upstream operation is analyzed in the corresponding section below, focusing on the publish event operation, which performs data synchronization.\\n\\nThe logic of the `publishEvent()`  method is to find the plugin corresponding to the selector, build the conditional data, and publish the change data.\\n\\n```java\\n       private void publishEvent(final SelectorDO selectorDO, final List<SelectorConditionDTO> selectorConditionDTOs) {\\n        // find plugin of selector\\n        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());\\n        // build condition data\\n        List<ConditionData> conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());\\n        // publish event\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,\\n                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));\\n    }\\n```\\n\\nChange data released by `eventPublisher.PublishEvent()` is complete, the `eventPublisher` object is a `ApplicationEventPublisher` class, The fully qualified class name is `org.springframework.context.ApplicationEventPublisher`. Here we see that publishing data is done through `Spring` related functionality.\\n\\n> `ApplicationEventPublisher`\uff1a\\n>\\n> When a state change, the publisher calls `ApplicationEventPublisher` of `publishEvent` method to release an event, `Spring` container broadcast event for all observers, The observer\'s `onApplicationEvent` method is called to pass the event object to the observer. There are two ways to call `publishEvent` method, one is to implement the interface by the container injection `ApplicationEventPublisher` object and then call the method, the other is a direct call container, the method of two methods of publishing events not too big difference.\\n>\\n> - `ApplicationEventPublisher`: publish event;\\n> - `ApplicationEvent`: `Spring` event, record the event source, time, and data;\\n> - `ApplicationListener`: event listener, observer.\\n\\nIn Spring event publishing mechanism, there are three objects,\\n\\nAn object is a publish event `ApplicationEventPublisher`, in `ShenYu` through the constructor in the injected a `eventPublisher`.\\n\\nThe other object is `ApplicationEvent` , inherited from `ShenYu` through `DataChangedEvent`, representing the event object.\\n\\n```java\\npublic class DataChangedEvent extends ApplicationEvent {\\n//......\\n}\\n```\\n\\nThe last object is `ApplicationListener` in `ShenYu` in through `DataChangedEventDispatcher` class implements this interface, as the event listener, responsible for handling the event object.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n    //......\\n    \\n}\\n```\\n\\n#### 2.3 Dispatch Data\\n\\n- DataChangedEventDispatcher.onApplicationEvent()\\n\\nReleased when the event is completed, will automatically enter the `DataChangedEventDispatcher` class `onApplicationEvent()` method of handling events.\\n\\n```java\\n@Component\\npublic class DataChangedEventDispatcher implements ApplicationListener<DataChangedEvent>, InitializingBean {\\n\\n  /**\\n     * This method is called when there are data changes\\n   * @param event\\n     */\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n      for (DataChangedListener listener : listeners) {\\n            // What kind of data has changed\\n        switch (event.getGroupKey()) {\\n                case APP_AUTH: // app auth data\\n                    listener.onAppAuthChanged((List<AppAuthData>) event.getSource(), event.getEventType());\\n                    break;\\n                case PLUGIN:  // plugin data\\n                    listener.onPluginChanged((List<PluginData>) event.getSource(), event.getEventType());\\n                    break;\\n                case RULE:    // rule data\\n                    listener.onRuleChanged((List<RuleData>) event.getSource(), event.getEventType());\\n                    break;\\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());\\n                    break;\\n                case META_DATA:  // metadata\\n                    listener.onMetaDataChanged((List<MetaData>) event.getSource(), event.getEventType());\\n                    break;\\n                default:  // other types throw exception\\n                  throw new IllegalStateException(\\"Unexpected value: \\" + event.getGroupKey());\\n            }\\n        }\\n    }\\n    \\n}\\n```\\n\\nWhen there is a data change, the `onApplicationEvent` method is called and all the data change listeners are iterated to determine the data type and handed over to the appropriate data listener for processing.\\n\\nShenYu groups all the data into five categories: `APP_AUTH`, `PLUGIN`, `RULE`, `SELECTOR` and `META_DATA`.\\n\\nHere the data change listener (`DataChangedListener`) is an abstraction of the data synchronization policy. Its concrete implementation is:\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/data-changed-listener.png)\\n\\nThese implementation classes are the synchronization strategies currently supported by ShenYu:\\n\\n- `WebsocketDataChangedListener`: data synchronization based on Websocket;\\n- `ZookeeperDataChangedListener`:data synchronization based on Zookeeper;\\n- `ConsulDataChangedListener`: data synchronization based on Consul;\\n- `EtcdDataDataChangedListener`\uff1adata synchronization based on etcd;\\n- `HttpLongPollingDataChangedListener`\uff1adata synchronization based on http long polling;\\n- `NacosDataChangedListener`\uff1adata synchronization based on nacos;\\n\\nGiven that there are so many implementation strategies, how do you decide which to use?\\n\\nBecause this paper is based on `zookeeper` data synchronization source code analysis, so here to `ZookeeperDataChangedListener` as an example, the analysis of how it is loaded and implemented.\\n\\nA global search in the source code project shows that its implementation is done in the `DataSyncConfiguration` class.\\n\\n```java\\n/**\\n * Data Sync Configuration\\n * By springboot conditional assembly\\n * The type Data sync configuration.\\n */\\n@Configuration\\npublic class DataSyncConfiguration {\\n    \\n    \\n    /**\\n     * zookeeper data sunc\\n     * The type Zookeeper listener.\\n     */\\n    @Configuration\\n    @ConditionalOnProperty(prefix = \\"shenyu.sync.zookeeper\\", name = \\"url\\")  // The condition property is loaded only when it is met\\n    @Import(ZookeeperConfiguration.class)\\n    static class ZookeeperListener {\\n\\n        /**\\n         * Config event listener data changed listener.\\n         * @param zkClient the zk client\\n         * @return the data changed listener\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(ZookeeperDataChangedListener.class)\\n        public DataChangedListener zookeeperDataChangedListener(final ZkClient zkClient) {\\n            return new ZookeeperDataChangedListener(zkClient);\\n        }\\n\\n        /**\\n         * Zookeeper data init zookeeper data init.\\n         * @param zkClient        the zk client\\n         * @param syncDataService the sync data service\\n         * @return the zookeeper data init\\n         */\\n        @Bean\\n        @ConditionalOnMissingBean(ZookeeperDataInit.class)\\n        public ZookeeperDataInit zookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {\\n            return new ZookeeperDataInit(zkClient, syncDataService);\\n        }\\n    }\\n    \\n    // other code is omitted......\\n}\\n\\n```\\n\\nThis configuration class is implemented through the SpringBoot conditional assembly class. The ZookeeperListener class has several annotations:\\n\\n- `@Configuration`: Configuration file, application context;\\n\\n- `@ConditionalOnProperty(prefix = \\"shenyu.sync.zookeeper\\", name = \\"url\\")`: attribute condition. The configuration class takes effect only when the condition is met. That is, when we have the following configuration, `ZooKeeper` is used for data synchronization.\\n\\n  ```properties\\n  shenyu:  \\n    sync:\\n       zookeeper:\\n            url: localhost:2181\\n            sessionTimeout: 5000\\n            connectionTimeout: 2000\\n  ```\\n\\n- `@Import(ZookeeperConfiguration.class)`\uff1aimport `ZookeeperConfiguration`;\\n\\n```java\\n  @EnableConfigurationProperties(ZookeeperProperties.class)  // enable zookeeper properties\\n  public class ZookeeperConfiguration {\\n\\n    /**\\n     * register zkClient in spring ioc.\\n     * @param zookeeperProp the zookeeper configuration\\n     * @return ZkClient {@linkplain ZkClient}\\n        */\\n      @Bean\\n      @ConditionalOnMissingBean(ZkClient.class)\\n      public ZkClient zkClient(final ZookeeperProperties zookeeperProp) {\\n        return new ZkClient(zookeeperProp.getUrl(), zookeeperProp.getSessionTimeout(), zookeeperProp.getConnectionTimeout()); // \u8bfb\u53d6zk\u914d\u7f6e\u4fe1\u606f\uff0c\u5e76\u521b\u5efazkClient\\n      }\\n  }\\n```\\n\\n```java\\n@Data\\n@ConfigurationProperties(prefix = \\"shenyu.sync.zookeeper\\") // zookeeper properties\\npublic class ZookeeperProperties {\\n\\n    private String url;\\n\\n    private Integer sessionTimeout;\\n\\n    private Integer connectionTimeout;\\n\\n    private String serializer;\\n}\\n```\\n\\nWhen we take the initiative to configuration, use the `zookeeper` data synchronization, `zookeeperDataChangedListener` is generated. So in the event handler `onApplicationEvent()`, it goes to the corresponding `listener`. In our case, it is a selector data update, data synchronization is `zookeeper`, so, the code will enter the `ZookeeperDataChangedListener` selector data change process.\\n\\n```java\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void onApplicationEvent(final DataChangedEvent event) {\\n        // Iterate through the data change listener (usually using a data synchronization approach is fine)\\n        for (DataChangedListener listener : listeners) {\\n            // what kind of data has changed\\n         switch (event.getGroupKey()) {\\n                    \\n                // other code logic is omitted\\n                    \\n                case SELECTOR:   // selector data\\n                    listener.onSelectorChanged((List<SelectorData>) event.getSource(), event.getEventType());   // In our case, will enter the ZookeeperDataChangedListener selector data change process\\n                    break;\\n         }\\n    }\\n```\\n\\n#### 2.4 Zookeeper Data Changed Listener\\n\\n- ZookeeperDataChangedListener.onSelectorChanged()\\n\\nIn the `onSelectorChanged()` method, determine the type of action, whether to refresh synchronization or update or create synchronization. Determine whether the node is in `zk` based on the current selector data.\\n\\n```java\\n\\n/**\\n * use ZooKeeper to publish change data\\n */\\npublic class ZookeeperDataChangedListener implements DataChangedListener {\\n    \\n    // The selector information changed\\n    @Override\\n    public void onSelectorChanged(final List<SelectorData> changed, final DataEventTypeEnum eventType) {\\n        // refresh\\n        if (eventType == DataEventTypeEnum.REFRESH && !changed.isEmpty()) {\\n            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());\\n            deleteZkPathRecursive(selectorParentPath);\\n        }\\n        // changed data\\n        for (SelectorData data : changed) {\\n            // build selector real path\\n            String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());\\n            // delete\\n            if (eventType == DataEventTypeEnum.DELETE) {\\n                deleteZkPath(selectorRealPath);\\n                continue;\\n            }\\n            // selector parent path\\n            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(data.getPluginName());\\n            // create parent node\\n            createZkNode(selectorParentPath);\\n            // insert or update data\\n            insertZkNode(selectorRealPath, data);\\n        }\\n    }\\n\\n\\t// create zk node\\n    private void createZkNode(final String path) {\\n        // create only if it does not exist\\n        if (!zkClient.exists(path)) {\\n            zkClient.createPersistent(path, true);\\n        }\\n    }\\n\\n    // insert zk node\\n    private void insertZkNode(final String path, final Object data) {\\n        // create zk node\\n        createZkNode(path);\\n        // write data by zkClient \\n        zkClient.writeData(path, null == data ? \\"\\" : GsonUtils.getInstance().toJson(data));\\n    }\\n    \\n}\\n```\\n\\nAs long as the changed data is correctly written to the `zk` node, the `admin` side of the operation is complete. `ShenYu` uses `zk` for data synchronization, `zk` nodes are carefully designed.\\n\\nIn our current case, updating one of the selector data in the `Divide` plugin with a weight of 90 updates specific nodes in the graph.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/zookeeper-node.png)\\n\\n\\nWe series the above update flow with a sequence diagram.\\n\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/zk-sync-sequence-admin-en.png)\\n\\n\\n### 3. Gateway Data Sync\\n\\nAssume that the ShenYu gateway is already running properly, and the data synchronization mode is also `Zookeeper`. How does the gateway receive and process the selector data after updating it on the admin side and sending the changed data to ZK? Let\'s continue our source code analysis to find out.\\n\\n#### 3.1 ZkClient Accept Data\\n\\n- ZkClient.subscribeDataChanges()\\n\\nThere is a `ZookeeperSyncDataService` class on the gateway, which subscribing to the data node through `ZkClient` and can sense when the data changes.\\n\\n\\n```java\\n/**\\n * ZookeeperSyncDataService\\n */\\npublic class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {\\n    \\nprivate void subscribeSelectorDataChanges(final String path) {\\n       // zkClient subscribe data \\n        zkClient.subscribeDataChanges(path, new IZkDataListener() {\\n            @Override\\n            public void handleDataChange(final String dataPath, final Object data) {\\n                cacheSelectorData(GsonUtils.getInstance().fromJson(data.toString(), SelectorData.class)); // zk node data changed\\n            }\\n\\n            @Override\\n            public void handleDataDeleted(final String dataPath) {\\n                unCacheSelectorData(dataPath);  // zk node data deleted\\n            }\\n        });\\n    }\\n \\n    // ...\\n}\\n```\\n\\nZooKeeper\'s  `Watch` mechanism notifies subscribing clients of node changes. In our case, updating the selector information goes to the `handleDataChange()` method. `cacheSelectorData()` is used to process data.\\n\\n\\n#### 3.2 Handle Data\\n\\n- ZookeeperSyncDataService.cacheSelectorData()\\n\\nThe data is not null, and caching the selector data is again handled by `PluginDataSubscriber`.\\n\\n```java\\n    private void cacheSelectorData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData)\\n                .ifPresent(data -> Optional.ofNullable(pluginDataSubscriber).ifPresent(e -> e.onSelectorSubscribe(data)));\\n    }\\n```\\n\\n`PluginDataSubscriber` is an interface, it is only a `CommonPluginDataSubscriber` implementation class, responsible for data processing plugin, selector and rules.\\n\\n\\n\\n#### 3.3 Common Plugin Data Subscriber\\n\\n- PluginDataSubscriber.onSelectorSubscribe()\\n\\nIt has no additional logic and calls the `subscribeDataHandler()` method directly. Within methods, there are data types (plugins, selectors, or rules) and action types (update or delete) to perform different logic.\\n\\n\\n```java\\n/**\\n * The common plugin data subscriber, responsible for handling all plug-in, selector, and rule information\\n */\\npublic class CommonPluginDataSubscriber implements PluginDataSubscriber {\\n    //......\\n     // handle selector data\\n    @Override\\n    public void onSelectorSubscribe(final SelectoData selectorData) {\\n        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);\\n    }    \\n    \\n    // A subscription data handler that handles updates or deletions of data\\n    private <T> void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {\\n        Optional.ofNullable(classData).ifPresent(data -> {\\n            // plugin data\\n            if (data instanceof PluginData) {\\n                PluginData pluginData = (PluginData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                     BaseDataCache.getInstance().cachePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.handlerPlugin(pluginData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removePluginData(pluginData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -> handler.removePlugin(pluginData));\\n                }\\n            } else if (data instanceof SelectorData) {  // selector data\\n                SelectorData selectorData = (SelectorData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it \\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) {  // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeSelectData(selectorData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.removeSelector(selectorData));\\n                }\\n            } else if (data instanceof RuleData) {  // rule data\\n                RuleData ruleData = (RuleData) data;\\n                if (dataType == DataEventTypeEnum.UPDATE) { // update\\n                    // save the data to gateway memory\\n                    BaseDataCache.getInstance().cacheRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.handlerRule(ruleData));\\n                } else if (dataType == DataEventTypeEnum.DELETE) { // delete\\n                    // delete the data from gateway memory\\n                    BaseDataCache.getInstance().removeRuleData(ruleData);\\n                    // If each plugin has its own processing logic, then do it\\n                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -> handler.removeRule(ruleData));\\n                }\\n            }\\n        });\\n    }\\n    \\n}\\n```\\n\\n#### 3.4 Data cached to Memory\\n\\n\\nAdding a selector will enter the following logic:\\n\\n```java\\n// save the data to gateway memory\\nBaseDataCache.getInstance().cacheSelectData(selectorData);\\n// If each plugin has its own processing logic, then do it\\nOptional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -> handler.handlerSelector(selectorData));\\n```\\n\\nOne is to save the data to the gateway\'s memory. BaseDataCache is the class that ultimately caches data, implemented in a singleton pattern. The selector data is stored in the `SELECTOR_MAP` Map. In the subsequent use, also from this data.\\n\\n\\n```java\\npublic final class BaseDataCache {\\n    // private instance\\n    private static final BaseDataCache INSTANCE = new BaseDataCache();\\n  \\t// private constructor\\n    private BaseDataCache() {\\n    }\\n    \\n    /**\\n     * Gets instance.\\n     *  public method\\n     * @return the instance\\n     */\\n    public static BaseDataCache getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n    /**\\n      * A Map of the cache selector data\\n     * pluginName -> SelectorData.\\n     */\\n    private static final ConcurrentMap<String, List<SelectorData>> SELECTOR_MAP = Maps.newConcurrentMap();\\n    \\n    public void cacheSelectData(final SelectorData selectorData) {\\n        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);\\n    }\\n        \\n   /**\\n     * cache selector data.\\n     * @param data the selector data\\n     */\\n    private void selectorAccept(final SelectorData data) {\\n        String key = data.getPluginName();\\n        if (SELECTOR_MAP.containsKey(key)) { // Update operation, delete before insert\\n            List<SelectorData> existList = SELECTOR_MAP.get(key);\\n            final List<SelectorData> resultList = existList.stream().filter(r -> !r.getId().equals(data.getId())).collect(Collectors.toList());\\n            resultList.add(data);\\n            final List<SelectorData> collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());\\n            SELECTOR_MAP.put(key, collect);\\n        } else {  // Add new operations directly to Map\\n            SELECTOR_MAP.put(key, Lists.newArrayList(data));\\n        }\\n    }\\n    \\n}\\n```\\n\\nSecond, if each plugin has its own processing logic, then do it. Through the `IDEA` editor, you can see that after adding a selector, there are the following plugins and processing. We\'re not going to expand it here.\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/handler-selector.png)\\n\\nAfter the above source tracking, and through a practical case, in the `admin` end to update a selector data, the `ZooKeeper` data synchronization process analysis is clear.\\n\\n\\nLet\'s series the data synchronization process on the gateway side through the sequence diagram:\\n\\n\\n![](/img/activities/code-analysis-zookeeper-data-sync/zk-sync-sequence-gateway-en.png)\\n\\nThe data synchronization process has been analyzed. In order to prevent the synchronization process from being interrupted, other logic is ignored during the analysis. We also need to analyze the process of Admin synchronization data initialization and gateway synchronization operation initialization.\\n\\n\\n### 4. Admin Data Sync  initialization\\n\\nWhen `admin` starts, the current data will be fully synchronized to `zk`, the implementation logic is as follows:\\n\\n\\n```java\\n\\n/**\\n * Zookeeper data init\\n */\\npublic class ZookeeperDataInit implements CommandLineRunner {\\n\\n    private final ZkClient zkClient;\\n\\n    private final SyncDataService syncDataService;\\n\\n    /**\\n     * Instantiates a new Zookeeper data init.\\n     *\\n     * @param zkClient        the zk client\\n     * @param syncDataService the sync data service\\n     */\\n    public ZookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {\\n        this.zkClient = zkClient;\\n        this.syncDataService = syncDataService;\\n    }\\n\\n    @Override\\n    public void run(final String... args) {\\n        String pluginPath = DefaultPathConstants.PLUGIN_PARENT;\\n        String authPath = DefaultPathConstants.APP_AUTH_PARENT;\\n        String metaDataPath = DefaultPathConstants.META_DATA;\\n        // Determine whether data exists in zk\\n        if (!zkClient.exists(pluginPath) && !zkClient.exists(authPath) && !zkClient.exists(metaDataPath)) {\\n            syncDataService.syncAll(DataEventTypeEnum.REFRESH);\\n        }\\n    }\\n}\\n\\n```\\n\\nCheck whether there is data in `zk`, if not, then synchronize.\\n\\n\\n`ZookeeperDataInit` implements the `CommandLineRunner` interface. It is an interface provided by `SpringBoot` that executes the `run()` method after all `Spring Beans` initializations and is often used for initialization operations in a project.\\n\\n\\n- SyncDataService.syncAll()\\n\\nQuery data from the database, and then perform full data synchronization, all authentication information, plugin information, selector information, rule information, and metadata information. Synchronous events are published primarily through `eventPublisher`. After publishing the event via `publishEvent()`, the `ApplicationListener` performs the event change operation. In `ShenYu` is mentioned in `DataChangedEventDispatcher`.\\n\\n```java\\n@Service\\npublic class SyncDataServiceImpl implements SyncDataService {\\n    // eventPublisher\\n    private final ApplicationEventPublisher eventPublisher;\\n    \\n     /***\\n     * sync all data\\n     * @param type the type\\n     * @return\\n     */\\n    @Override\\n    public boolean syncAll(final DataEventTypeEnum type) {\\n        // app auth data\\n        appAuthService.syncData();\\n        // plugin data\\n        List<PluginData> pluginDataList = pluginService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));\\n        // selector data\\n        List<SelectorData> selectorDataList = selectorService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));\\n        // rule data\\n        List<RuleData> ruleDataList = ruleService.listAll();\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));\\n        // metadata\\n        metaDataService.syncData();\\n        return true;\\n    }\\n    \\n}\\n```\\n\\n### 5. Gateway Data Sync Init \\n\\nThe initial operation of data synchronization on the gateway side is mainly the node in the subscription `zk`. When there is a data change, the changed data will be received. This relies on the `Watch` mechanism of `ZooKeeper`. In `ShenYu`, the one responsible for `zk` data synchronization is `ZookeeperSyncDataService`, also mentioned earlier.\\n\\nThe function logic of `ZookeeperSyncDataService` is completed in the process of instantiation: the subscription to `Shenyu` data synchronization node in `zk` is completed. Subscription here is divided into two kinds, one kind is existing node data updated above, through this `zkClient.subscribeDataChanges()` method; Another kind is under the current node, add or delete nodes change namely child nodes, it through `zkClient.subscribeChildChanges()` method.\\n\\n`ZookeeperSyncDataService` code is a bit too much, here we use plugin data read and subscribe to track, other types of data operation principle is the same.\\n\\n\\n```java\\n\\n/**\\n *  zookeeper sync data service\\n */\\npublic class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {\\n    // At instantiation time, the data is read from the ZK and the node is subscribed\\n    public ZookeeperSyncDataService(/* omit the construction argument */ ) {\\n        this.zkClient = zkClient;\\n        this.pluginDataSubscriber = pluginDataSubscriber;\\n        this.metaDataSubscribers = metaDataSubscribers;\\n        this.authDataSubscribers = authDataSubscribers;\\n        // watch plugin, selector and rule data\\n        watcherData();\\n        // watch app auth data\\n        watchAppAuth();\\n        // watch metadata\\n        watchMetaData();\\n    }\\n    \\n    private void watcherData() {\\n        // plugin node path\\n        final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;\\n        // all plugin nodes\\n        List<String> pluginZKs = zkClientGetChildren(pluginParent);\\n        for (String pluginName : pluginZKs) {\\n            // watch plugin, selector, rule data node\\n            watcherAll(pluginName);\\n        }\\n        //subscribing to child nodes (adding or removing a plugin)\\n        zkClient.subscribeChildChanges(pluginParent, (parentPath, currentChildren) -> {\\n            if (CollectionUtils.isNotEmpty(currentChildren)) {\\n                for (String pluginName : currentChildren) {\\n                    // you need to subscribe to all plugin, selector, and rule data for the child node\\n                      watcherAll(pluginName);\\n                }\\n            }\\n        });\\n    }\\n    \\n    private void watcherAll(final String pluginName) {\\n        // watch plugin\\n        watcherPlugin(pluginName);\\n        // watch selector\\n        watcherSelector(pluginName);\\n        // watch rule\\n        watcherRule(pluginName);\\n    }\\n\\n    private void watcherPlugin(final String pluginName) {\\n        // plugin path\\n        String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);\\n        // create if not exist\\n        if (!zkClient.exists(pluginPath)) {\\n            zkClient.createPersistent(pluginPath, true);\\n        }\\n        // read the current node data on zk and deserialize it\\n        PluginData pluginData = null == zkClient.readData(pluginPath) ? null\\n                : GsonUtils.getInstance().fromJson((String) zkClient.readData(pluginPath), PluginData.class);\\n        // cached into gateway memory\\n        cachePluginData(pluginData);\\n        // subscribe plugin data\\n        subscribePluginDataChanges(pluginPath, pluginName);\\n    }\\n    \\n   private void cachePluginData(final PluginData pluginData) {\\n    //omit implementation logic, is actually the CommonPluginDataSubscriber operation, can connect with the front\\n    }\\n    \\n    private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {\\n        // subscribe data changes\\n        zkClient.subscribeDataChanges(pluginPath, new IZkDataListener() {\\n\\n            @Override\\n            public void handleDataChange(final String dataPath, final Object data) {  // update\\n                 //omit implementation logic, is actually the CommonPluginDataSubscriber operation, can connect with the front\\n            }\\n\\n            @Override\\n            public void handleDataDeleted(final String dataPath) {   // delete\\n                  // Omit implementation logic, is actually the CommonPluginDataSubscriber operation, can connect with the front\\n\\n            }\\n        });\\n    }\\n    \\n}    \\n```\\n\\nThe above source code is given comments, I believe you can understand. The main logic for subscribing to plug-in data is as follows:\\n\\n> 1. Create the current plugin path\\n> 2. Create a path if it does not exist\\n> 3. Read the current node data on zK and deserialize it\\n> 4. The plugin data is cached in the gateway memory\\n> 5. Subscribe to the plug-in node\\n\\n\\n### 6. Summary\\n\\nThis paper through a practical case, `Zookeeper` data synchronization principle source code analysis. The main knowledge points involved are as follows:\\n\\n- Data synchronization based on `ZooKeeper` is mainly implemented through `watch` mechanism;\\n\\n- Complete event publishing and listening via `Spring`;\\n\\n- Support multiple synchronization strategies through abstract `DataChangedListener` interface, interface oriented programming;\\n\\n- Use singleton design pattern to cache data class `BaseDataCache`;\\n\\n- Loading of configuration classes via conditional assembly of `SpringBoot` and `starter` loading mechanism."},{"id":"/E2eTest-Analysis","metadata":{"permalink":"/blog/E2eTest-Analysis","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/E2eTest-Analysis.md","source":"@site/blog/E2eTest-Analysis.md","title":"E2e Test Analysis","description":"This article will conduct an in-depth analysis of Apache ShenYu e2e module.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"E2e Test","permalink":"/blog/tags/e-2-e-test"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":7.27,"hasTruncateMarker":false,"authors":[{"name":"Haiqi Qin","title":"Apache ShenYu Committer","url":"https://github.com/HaiqiQin","imageURL":"https://avatars.githubusercontent.com/u/80969210?v=4"}],"frontMatter":{"title":"E2e Test Analysis","author":"Haiqi Qin","author_title":"Apache ShenYu Committer","author_url":"https://github.com/HaiqiQin","author_image_url":"https://avatars.githubusercontent.com/u/80969210?v=4","tags":["E2e Test","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"ZooKeeper Data Synchronization Source Code Analysis","permalink":"/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync"},"nextItem":{"title":"Integration Test Analysis","permalink":"/blog/IntegrationTest-Analysis"}},"content":"This article will conduct an in-depth analysis of Apache ShenYu e2e module.\\n\\n### what is e2e\\n\\ne2e (end to end), also known as end-to-end testing, is a method used to test whether the application flow performs as designed from the beginning to the end. The purpose of performing end-to-end testing is to identify system dependencies and ensure that the correct information is passed between various system components and systems. The purpose of end-to-end testing is to test the entire software for dependencies, data integrity, and communication with other systems, interfaces, and databases to simulate a complete production scenario.\\n\\n### Advantages of e2e\\n\\ne2e testing can test the integrity and accuracy of software systems in simulated real user scenarios, and can verify whether the entire system works as expected and whether different components can work together. There are several benefits of e2e testing:\\n\\n1. Help ensure the correctness of system functions.e2e testing can simulate the interaction and operation in real user scenarios, verify whether the entire system can work as expected, and help discover potential problems and defects in the system.\\n2. Improve test coverage.e2e testing can cover the entire system, including front-end, back-end, database and other different levels and components, thereby improving test coverage and ensuring comprehensiveness and accuracy of testing.\\n3. Ensure the stability of the system.e2e testing can check the stability and robustness of the system in various situations, including system response time, error handling capabilities, concurrency, etc., to help ensure that the system is in the face of high load and abnormal conditions Still able to maintain stable operation.\\n4. Reduce testing cost.e2e testing can improve testing efficiency and accuracy, reduce testing cost and time, and thus help enterprises release and deliver high-quality software products more quickly.\\n\\nIn short, e2e testing is a comprehensive testing method that can verify whether the entire system works as expected, improve test coverage and test efficiency, thereby ensuring the stability and correctness of the system, and reducing testing costs and time. And effective testing methods, so we need to improve e2e related codes.\\n\\n### How to implement automated e2e testing\\n\\nIn Apache ShenYu, the main steps of e2e testing are reflected in the script of the GitHub Action workflow, as shown below, the script is located at [~/.github/workflows](https://github.com/apache/shenyu/tree/master/.github/workflows) directory in the e2e file.\\n\\n```yaml\\nname: e2e\\n\\non:\\n  pull_request:\\n  push:\\n    branches:\\n      - master\\njobs:\\n  changes:\\n    ...\\n  build-docker-images:\\n    ...\\n  e2e-http:\\n    ...\\n  e2e-case:\\n    runs-on: ubuntu-latest\\n    needs:\\n      - changes\\n      - build-docker-images\\n    if: ${{ needs.changes.outputs.e2e == \'true\' }}\\n    strategy:\\n      matrix:\\n        case: [ \\"shenyu-e2e-case-spring-cloud\\", \\"shenyu-e2e-case-apache-dubbo\\", \\"shenyu-e2e-case-sofa\\" ]\\n    steps:\\n      - uses: actions/checkout@v3\\n        with:\\n          submodules: true\\n      - name: Load ShenYu Docker Images\\n        run: |\\n          docker load --input /tmp/apache-shenyu-admin.tar\\n          docker load --input /tmp/apache-shenyu-bootstrap.tar\\n          docker image ls -a\\n      - name: Build examples with Maven\\n        run: ./mvnw -B clean install -Pexample -Dmaven.javadoc.skip=true -Dmaven.test.skip=true -f ./shenyu-examples/pom.xml\\n      - name: Run ShenYu E2E Tests\\n        env:\\n          storage: mysql\\n        run: |\\n          bash ./shenyu-e2e/script/storage_init.sh\\n          ./mvnw -B -f ./shenyu-e2e/pom.xml -pl shenyu-e2e-case/${{ matrix.case }} -Dstorage=mysql test\\n```\\n\\nWhen the workflow is triggered, use the dockerfile under the shenyu-dist module to build and upload the images of the admin and bootstrap projects. When the e2e test module is running, the admin and bootstrap images can be loaded. Then build the modules in the examples, and finally execute the test method of the corresponding test module.\\n\\n### How to run e2e test locally\\n\\nIf you need to write e2e test cases, you first need to code and debug locally. Currently e2e supports two startup methods, one is docker startup and the other is host startup. These two modes can be switched in the @ShenYuTest annotation in the test class. The host startup method directly starts the services that need to be started locally to run the test code. Before using docker to start, you need to build the corresponding image first. Because ShenYu currently needs to support e2e testing in the github workflow, it is recommended to use the docker startup method.\\n\\n### Analysis of e2e startup process\\n\\nCurrently, the e2e module is mainly divided into four parts: case, client, common and engine.\\n\\n![e2e-modules](/img/activities/code-analysis-e2e/e2e-modules.png)\\n\\nThe case module stores the test cases of the plug-in, and the client module writes the clients of admin and gateway to request corresponding interfaces. Common stores some public classes, and the engine module is the core of the framework. Relying on the testcontainer framework, use java code to start the docker container and complete the configuration operations for admin and gatewat.\\n\\nNext, I will analyze the e2e startup process based on the source code.\\n\\nWhen we execute the test method in the case, the @ShenYuTest annotation will take effect and extend the test class. Through @ShenYuTest, we can choose the startup method, configure related parameters for admin and gateway, and choose the docker-compose file to be executed. For admin and gateway, you can configure the user name, password, data synchronization method and modify the content of yaml required for login.\\n\\n```java\\n@ShenYuTest(\\n        mode = ShenYuEngineConfigure.Mode.DOCKER,\\n        services = {\\n                @ShenYuTest.ServiceConfigure(\\n                        serviceName = \\"admin\\",\\n                        port = 9095,\\n                        baseUrl = \\"http://{hostname:localhost}:9095\\",\\n                        parameters = {\\n                                @ShenYuTest.Parameter(key = \\"username\\", value = \\"admin\\"),\\n                                @ShenYuTest.Parameter(key = \\"password\\", value = \\"123456\\"),\\n                                @ShenYuTest.Parameter(key = \\"dataSyn\\", value = \\"admin_websocket\\")\\n                        }\\n                ),\\n                @ShenYuTest.ServiceConfigure(\\n                        serviceName = \\"gateway\\",\\n                        port = 9195,\\n                        baseUrl = \\"http://{hostname:localhost}:9195\\", \\n                        type = ShenYuEngineConfigure.ServiceType.SHENYU_GATEWAY,\\n                        parameters = {\\n                          @ShenYuTest.Parameter(key = \\"application\\", value =  \\"spring.cloud.discovery.enabled:true,eureka.client.enabled:true\\"), \\n                          @ShenYuTest.Parameter(key = \\"dataSyn\\", value = \\"gateway_websocket\\")})},           \\n        dockerComposeFile = \\"classpath:./docker-compose.mysql.yml\\")\\n\\n```\\n\\n@ShenYuTest is extended through the ShenYuExtension class, and the configuration of admin and gateway takes effect in beforeAll in ShenYuExtension. The specific effective logic is implemented in the DockerServiceCompose class.\\n\\n![e2e-shenyutest](/img/activities/code-analysis-e2e/e2e-shenyutest.png)\\n\\n![e2e-beforeall](/img/activities/code-analysis-e2e/e2e-beforeall.png)\\n\\n@ShenYuTest configuration items take effect before docker starts, mainly by modifying the yaml file in the resource directory of the test module. Currently, e2e supports testing of different data synchronization methods. The principle is to use the chooseDataSyn method in the DockerServiceCompose class. In the DataSyncHandler, initialize the content that needs to be modified in various data synchronization methods, and finally start the container.\\n\\n![e2e-docer-service-compose](/img/activities/code-analysis-e2e/e2e-docer-service-compose.png)\\n\\n![e2e-datahandle-syn](/img/activities/code-analysis-e2e/e2e-datahandle-syn.png)\\n\\nWhen docker is started, start testing the plug-in function. In the PluginsTest class, there are pre- and post-operations for testing.\\n\\n```java\\n    @BeforeAll\\n    static void setup(final AdminClient adminClient, final GatewayClient gatewayClient) throws InterruptedException, JsonProcessingException {\\n        adminClient.login();\\n        Thread.sleep(10000);\\n        List<SelectorDTO> selectorDTOList = adminClient.listAllSelectors();\\n        List<MetaDataDTO> metaDataDTOList = adminClient.listAllMetaData();\\n        List<RuleDTO> ruleDTOList = adminClient.listAllRules();\\n        Assertions.assertEquals(2, selectorDTOList.size());\\n        Assertions.assertEquals(13, metaDataDTOList.size());\\n        Assertions.assertEquals(14, ruleDTOList.size());\\n        \\n        for (SelectorDTO selectorDTO : selectorDTOList) {\\n            if (selectorDTO.getHandle() != null && !\\"\\".equals(selectorDTO.getHandle())) {\\n                SpringCloudPluginCases.verifierUri(selectorDTO.getHandle());\\n            }\\n        }\\n        List<MetaData> metaDataCacheList = gatewayClient.getMetaDataCache();\\n        List<SelectorCacheData> selectorCacheList = gatewayClient.getSelectorCache();\\n        List<RuleCacheData> ruleCacheList = gatewayClient.getRuleCache();\\n        Assertions.assertEquals(2, selectorCacheList.size());\\n        Assertions.assertEquals(13, metaDataCacheList.size());\\n        Assertions.assertEquals(14, ruleCacheList.size());\\n\\n        MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();\\n        formData.add(\\"id\\", \\"8\\");\\n        formData.add(\\"name\\", \\"springCloud\\");\\n        formData.add(\\"enabled\\", \\"true\\");\\n        formData.add(\\"role\\", \\"Proxy\\");\\n        formData.add(\\"sort\\", \\"200\\");\\n        adminClient.changePluginStatus(\\"8\\", formData);\\n        String id = \\"\\";\\n        for (SelectorDTO selectorDTO : selectorDTOList) {\\n            if (!\\"\\".equals(selectorDTO.getHandle())) {\\n                id = selectorDTO.getId();\\n            }\\n        }\\n        adminClient.deleteSelectors(id);\\n        selectorDTOList = adminClient.listAllSelectors();\\n        Assertions.assertEquals(1, selectorDTOList.size());\\n    }\\n```\\n\\nTaking the springcloud plug-in as an example, you first need to test whether the registration center and data synchronization can work normally, then start the plug-in and delete the existing selector. To test whether the data is successfully registered into the registration center, you can call the interface of the admin client to test, and to test whether the data synchronization is successful, you can obtain the cache of the gateway for testing.\\n\\nThen run the test case in the case file and get the use case through @ShenYuScenario.\\n\\n```java\\n    @ShenYuScenario(provider = SpringCloudPluginCases.class)\\n    void testSpringCloud(GatewayClient gateway, CaseSpec spec) {\\n        spec.getVerifiers().forEach(verifier -> verifier.verify(gateway.getHttpRequesterSupplier().get()));\\n    }\\n```\\n\\nFor different plug-ins, we can build a Case class to store the rules to be tested. All test rules are stored in the list and tested in order. Build selectors and rules in beforeEachSpec, caseSpec stores test entities, if they meet the uri rules, they should exist, otherwise they don\u2019t exist. We need to simulate users to add selectors and rules, because the handler rules of the selectors of each plug-in are not necessarily the same, so we need to write its handle class according to the plug-in requirements. And verify that it complies with the rules with the request. Specific test cases are mainly divided into two categories, one is to match uri rules, such as euqal, path_pattern, start_with, end_with, and the other is request types, such as get, put, post, delete.\\n\\nWhen all eight matching conditions are tested, it can be judged that the plug-in function is normal. After the test, we need to restore the environment, delete all selectors, set the plug-in to unavailable, and finally close all containers.\\n\\n```java\\n    @Override\\n    public List<ScenarioSpec> get() {\\n        return Lists.newArrayList(\\n                testWithUriEquals(),\\n                testWithUriPathPattern(),\\n                testWithUriStartWith(),\\n                testWithEndWith(),\\n                testWithMethodGet(),\\n                testWithMethodPost(),\\n                testWithMethodPut(),\\n                testWithMethodDelete()\\n        );\\n    }\\n\\n    private ShenYuScenarioSpec testWithUriEquals() {\\n        return ShenYuScenarioSpec.builder()\\n                .name(\\"single-spring-cloud uri =]\\")\\n                .beforeEachSpec(\\n                        ShenYuBeforeEachSpec.builder()\\n                                .addSelectorAndRule(\\n                                        newSelectorBuilder(\\"selector\\", Plugin.SPRING_CLOUD)                                               .handle(SpringCloudSelectorHandle.builder().serviceId(\\"springCloud-test\\")\\n                                                        .gray(true)\\n                                                        .divideUpstreams(DIVIDE_UPSTREAMS).build())\\n                                                .conditionList(newConditions(Condition.ParamType.URI, Condition.Operator.EQUAL, TEST))\\n                                                .build(),\\n                                        newRuleBuilder(\\"rule\\")                               .handle(SpringCloudRuleHandle.builder().loadBalance(\\"hash\\").timeout(3000).build())\\n                                                .conditionList(newConditions(Condition.ParamType.URI, Condition.Operator.EQUAL, TEST))\\n                                                .build()\\n                                )\\n                                .checker(notExists(TEST))\\n                                .waiting(exists(TEST))\\n                                .build()\\n                )\\n                .caseSpec(\\n                        ShenYuCaseSpec.builder()\\n                                .addExists(TEST)\\n                                .addNotExists(\\"/springcloud/te\\")\\n                                .addNotExists(\\"/put\\")\\n                                .addNotExists(\\"/get\\")\\n                                .build()\\n                )\\n                .afterEachSpec(ShenYuAfterEachSpec.DEFAULT)\\n                .build();\\n    }\\n```"},{"id":"/IntegrationTest-Analysis","metadata":{"permalink":"/blog/IntegrationTest-Analysis","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/IntegrationTest-Analysis.md","source":"@site/blog/IntegrationTest-Analysis.md","title":"Integration Test Analysis","description":"This article will provide an in-depth analysis of Apache ShenYu\'s integration tests.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"Integration Test","permalink":"/blog/tags/integration-test"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":6.555,"hasTruncateMarker":false,"authors":[{"name":"Kunshuai Zhu","title":"Apache ShenYu Committer","url":"https://github.com/JooKS-me","imageURL":"https://avatars1.githubusercontent.com/u/62384022?v=4"}],"frontMatter":{"title":"Integration Test Analysis","author":"Kunshuai Zhu","author_title":"Apache ShenYu Committer","author_url":"https://github.com/JooKS-me","author_image_url":"https://avatars1.githubusercontent.com/u/62384022?v=4","tags":["Integration Test","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"E2e Test Analysis","permalink":"/blog/E2eTest-Analysis"},"nextItem":{"title":"Extension plugin loading logic","permalink":"/blog/Loader-SourceCode-Analysis-ExtLoader"}},"content":"This article will provide an in-depth analysis of Apache ShenYu\'s integration tests.\\n\\n### What are integration tests?\\n\\nIntegration testing is also called E2E (End To End) testing in some projects. It is mainly used to test whether each module can meet expectations after being assembled into a system.\\n\\nApache ShenYu puts integration tests in continuous integration, using GitHub Actions to trigger each time a Pull Request or Merge is submitted to the main branch. This can greatly reduce the maintenance cost of the project and improve the stability of Apache ShenYu.\\n\\n### How to automate integration testing?\\n\\nIn Apache ShenYu, the main steps of integration testing are embodied in the script of the GitHub Action workflow, as shown below, which is located at [~/.github/workflows](https://github.com/apache/shenyu/tree/master/.github/workflows) directory.\\n\\n```yaml\\nname: it\\non:\\n  pull_request:\\n  push:\\n    branches:\\n      - master\\njobs:\\n  build:\\n    strategy:\\n      matrix:\\n        case:\\n          - shenyu-integrated-test-alibaba-dubbo\\n          ...\\n    runs-on: ubuntu-latest\\n    steps:\\n      - uses: actions/checkout@v2\\n        with:\\n          submodules: true\\n      ...\\n```\\n\\nNext, I will start from this yaml file and take you to analyze the entire process of automated integration testing.\\n\\n### Triggering the workflow\\n\\nSince we specified `pull_request` and `push.branch: master` in `on`, this workflow will be triggered when we submit pull_request or merge branch to master (push).\\n\\nFor more usage of GitHub Action, you can refer to the documentation of [GitHub Action](https://docs.github.com/en/actions), which will not be introduced in detail here.\\n\\n### Initialize the environment\\n\\n- pull code\\n\\n```yaml\\n- uses: actions/checkout@v2\\n  with:\\n \\t    submodules: true\\n```\\n\\n- set skip flag\\n\\n```yaml\\n- name: Set Skip Env Var\\n      uses: ./.github/actions/skip-ci\\n```\\n\\nWhen something unrelated to functionality occurs (such as changing documentation), integration tests are skipped to save resources.\\n\\n- Cache maven repos, install Java\\n\\n```yaml\\n- name: Cache Maven Repos\\n...\\n- uses: actions/setup-java@v1\\n```\\n\\n### Build the entire project while building the docker image\\n\\n```shell\\n./mvnw -B clean install -Prelease,docker -Dmaven.javadoc.skip=true -Dmaven.test.skip=true\\n```\\n\\nIn the above command, -P is followed by `release,docker`, which means that the relevant profile configuration in the pom file will be activated.\\n\\nThe two profiles, release and docker, currently only exist in several submodules under `shenyu-dist`. The following will take the [shenyu-dist-admin](https://github.com/apache/shenyu/tree/master/shenyu-dist/shenyu-admin-dist) module as an example to introduce profiles as release and docker The specific content of the configuration. Also, integration tests only use the `shenyu-admin` image built in this step.\\n\\n- First is release\\n\\n  ```xml\\n  <profile>\\n      <id>release</id>\\n      <activation>\\n          <activeByDefault>false</activeByDefault>\\n      </activation>\\n      <build>\\n          <finalName>apache-shenyu-incubating-${project.version}</finalName>\\n          <plugins>\\n              <plugin>\\n                  <groupId>org.apache.maven.plugins</groupId>\\n                  <artifactId>maven-assembly-plugin</artifactId>\\n                  <executions>\\n                      <execution>\\n                          <id>admin-bin</id>\\n                          <phase>package</phase>\\n                          <goals>\\n                              <goal>single</goal>\\n                          </goals>\\n                      </execution>\\n                  </executions>\\n                  <configuration>\\n                      <descriptors>\\n                          <descriptor>${project.basedir}/src/main/assembly/binary.xml</descriptor>\\n                      </descriptors>\\n                      <tarLongFileMode>posix</tarLongFileMode>\\n                  </configuration>\\n              </plugin>\\n          </plugins>\\n      </build>\\n  </profile>\\n  ```\\n\\n  When -P is followed by release, the above `maven-assembly-plugin` plugin is activated. In executions, the execution timing of the plugin is bound to the maven life cycle package, which means that it will be triggered when we execute `mvn install`.\\n\\n  The `binary.xml` we wrote is specified in the configuration, and the `maven-assembly-plugin` plugin will copy the required files and package them according to this file. You can click the link to view the file: [shenyu-dist/shenyu-admin-dist/src/main/assembly/binary.xml](https://github.com/apache/shenyu/blob/master/shenyu- dist/shenyu-admin-dist/src/main/assembly/binary.xml)\\n\\n  According to this file, the plugin will \\"copy\\" the packaged jar packages, configuration files, startup scripts, etc. under other modules, and finally make them into a compressed package in `tar.gz` format.\\n\\n- then docker\\n\\n  ```xml\\n  <profile>\\n      <id>docker</id>\\n      <activation>\\n          <activeByDefault>false</activeByDefault>\\n      </activation>\\n      <build>\\n          <plugins>\\n              <plugin>\\n                  <groupId>com.spotify</groupId>\\n                  <artifactId>dockerfile-maven-plugin</artifactId>\\n                  <version>${dockerfile-maven-plugin.version}</version>\\n                  <executions>\\n                      <execution>\\n                          <id>tag-latest</id>\\n                          <goals>\\n                              <goal>build</goal>\\n                          </goals>\\n                          <configuration>\\n                              <tag>latest</tag>\\n                          </configuration>\\n                      </execution>\\n                      <execution>\\n                          <id>tag-version</id>\\n                          <goals>\\n                              <goal>build</goal>\\n                          </goals>\\n                          <configuration>\\n                              <tag>${project.version}</tag>\\n                          </configuration>\\n                      </execution>\\n                  </executions>\\n                  <configuration>\\n                      <repository>apache/shenyu-admin</repository>\\n                      <buildArgs>\\n                          <APP_NAME>apache-shenyu-incubating-${project.version}-admin-bin</APP_NAME>\\n                      </buildArgs>\\n                  </configuration>\\n              </plugin>\\n          </plugins>\\n      </build>\\n  </profile>\\n  ```\\n\\n  Similar to the release above, here is the activation of the `dockerfile-maven-plugin` plugin. When `mvn install -Pdocker`, the plugin will use the dockerfile we wrote to build the docker image.\\n\\nIt should be noted that the dockerfile-maven-plugin currently has limited support for aarch64 architecture devices, and the following error will occur when running the plugin on aarch64 architecture machines. And when I wrote this article, it has not been maintained for a long time, which means that the problem of aarch64 architecture devices using this plugin will not be solved in the short term.\\n\\n```shell\\n[ERROR] Failed to execute goal com.spotify:dockerfile-maven-plugin:1.4.6:build (tag-latest) on project shenyu-admin-dist: Could not build image: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.lang.UnsatisfiedLinkError: could not load FFI provider jnr.ffi.provider.jffi.Provider: ExceptionInInitializerError: Can\'t overwrite cause with java.lang.UnsatisfiedLinkError: java.lang.UnsatisfiedLinkError: /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: dlopen(/private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib, 1): no suitable image found.  Did find:\\n[ERROR]         /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: no matching architecture in universal wrapper\\n[ERROR]         /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: no matching architecture in universal wrapper\\n...\\n```\\n\\nHere is a temporary solution:\\n\\n1. Open a new shell, enter the following command, and use socat to route the unix socket to the tcp port\\n\\n   ```shell\\n   socat TCP-LISTEN:2375,range=127.0.0.1/32,reuseaddr,fork UNIX-CLIENT:/var/run/docker.sock\\n   ```\\n\\n2. Set environment variables\\n\\n   ```shell\\n   export DOCKER_HOST=tcp://127.0.0.1:2375\\n   ```\\n\\n### Build the examples module\\n\\n```yaml\\n- name: Build examples\\n  if: env.SKIP_CI != \'true\'\\n  run: ./mvnw -B clean install -Pexample -Dmaven.javadoc.skip=true -Dmaven.test.skip=true -f ./shenyu-examples/pom.xml\\n```\\n\\nConsidering the need for release, the current pom file in the project root directory does not contain the example submodule, so the examples module is additionally built in the above step.\\n\\nSimilar to the above, this line of command will also use the maven plugin to build an image for our subsequent docker orchestration.\\n\\n### Build custom gateways\\n\\n```yaml\\n- name: Build integrated tests\\n  if: env.SKIP_CI != \'true\'\\n  run: ./mvnw -B clean install -Pit -DskipTests -f ./shenyu-integrated-test/pom.xml\\n```\\n\\nIn order to subdivide the integration tests of different functions of Apache ShenYu, we will build a gateway customized by the integration test module in this step. The so-called \\"customization\\" is to introduce the minimum required dependencies in the pom file, and then replace the default `shenyu-bootstrap`. Similar to the above two steps, this step will also build the docker image.\\n\\nIt is worth noting that the way of packaging and building here is slightly different from that of the `shenyu-dist` module, which you can find by comparing the pom file.\\n\\n### Run docker compose\\n\\n```yaml\\n- name: Start docker compose\\n  if: env.SKIP_CI != \'true\'\\n  run: docker-compose -f ./shenyu-integrated-test/${{ matrix.case }}/docker-compose.yml up -d\\n```\\n\\nIn this step, docker will be arranged according to the different `docker-compose.yml` files written under the integration test module.\\n\\n```yaml\\nversion: \\"3.9\\"\\nservices:\\n  shenyu-zk:\\n    container_name: shenyu-zk\\n    image: zookeeper:3.5\\n    ...\\n  shenyu-redis:\\n    image: redis:6.0-alpine\\n    container_name: shenyu-redis\\n    ...\\n\\n  shenyu-examples-http:\\n    deploy:\\n      resources:\\n        limits:\\n          memory: 2048M\\n    container_name: shenyu-examples-http\\n    image: shenyu-examples-http:latest\\n    ...\\n\\n  shenyu-admin:\\n    image: apache/shenyu-admin:latest\\n    container_name: shenyu-admin\\n    ...\\n\\n  shenyu-integrated-test-http:\\n    container_name: shenyu-integrated-test-http\\n    image: apache/shenyu-integrated-test-http:latest\\n    ...\\n    depends_on:\\n      shenyu-admin:\\n        condition: service_healthy\\n    healthcheck:\\n      test: [ \\"CMD\\", \\"wget\\", \\"http://shenyu-integrated-test-http:9195/actuator/health\\" ]\\n      timeout: 2s\\n      retries: 30\\n\\nnetworks:\\n  shenyu:\\n    name: shenyu\\n```\\n\\nFor example, the `docker-compose.yml` under the `shenyu-integrated-test-http` module starts zookeeper, redis, example, admin, gateway and other services in sequence. Among them, the mirrors of example, admin, and gateway are built by us before.\\n\\nAmong them, docker-compose uses depends_on to determine the topological relationship between services, and most services have corresponding health checks, and the next service will not be started until the health check passes.\\n\\n### Run the health check and wait for docker-compose to start\\n\\n```yaml\\n- name: Wait for docker compose start up completely\\n  if: env.SKIP_CI != \'true\'\\n  run: bash ./shenyu-integrated-test/${{ matrix.case }}/script/healthcheck.sh\\n```\\n\\nIn this step, the host will run the `healthcheck.sh` script, and then use the curl command to access the health status interface `/actuator/health` of each service list (in the services.list file), until the service status is normal. will continue.\\n\\n### run tests\\n\\n```yaml\\n- name: Run test\\n  id: test\\n  if: env.SKIP_CI != \'true\'\\n  run: ./mvnw test -Pit -f ./shenyu-integrated-test/${{ matrix.case }}/pom.xml\\n  continue-on-error: true\\n```\\n\\nThis step is to use the maven test command to execute the test classes in the `/src/test/` directory one by one.\\n\\n### View Docker Compose logs\\n\\n```yaml\\n- name: Check test result\\n  if: env.SKIP_CI != \'true\'\\n  run: |\\n    docker-compose -f ./shenyu-integrated-test/${{ matrix.case }}/docker-compose.yml logs --tail=\\"all\\"\\n    if [[ ${{steps.test.outcome}} == \\"failure\\" ]]; then\\n      echo \\"Test Failed\\"\\n      exit 1\\n    else\\n      echo \\"Test Successful\\"\\n      exit 0\\n    fi\\n```\\n\\nWhen there is an error in the workflow, the log of docker compose can help us to better troubleshoot the problem, so in this step, we will print the log of docker compose."},{"id":"/Loader-SourceCode-Analysis-ExtLoader","metadata":{"permalink":"/blog/Loader-SourceCode-Analysis-ExtLoader","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Loader-SourceCode-Analysis-ExtLoader.md","source":"@site/blog/Loader-SourceCode-Analysis-ExtLoader.md","title":"Extension plugin loading logic","description":"This article is based on the source code analysis of version \'shenyu-2.6.1\'","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"plugin","permalink":"/blog/tags/plugin"},{"label":"ext","permalink":"/blog/tags/ext"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":7.9,"hasTruncateMarker":false,"authors":[{"name":"hql0312","title":"hql0312 Coder","url":"https://github.com/hql0312"}],"frontMatter":{"title":"Extension plugin loading logic","author":"hql0312","author_title":"hql0312 Coder","author_url":"https://github.com/hql0312","tags":["plugin","ext","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Integration Test Analysis","permalink":"/blog/IntegrationTest-Analysis"},"nextItem":{"title":"Code Analysis For Context-Path Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin"}},"content":"> This article is based on the source code analysis of version \'shenyu-2.6.1\'\\n\\n# Content\\n\\nShenyu provides a mechanism to customize its own plugins or modify existing plugins, which is implemented internally through the configuration of extPlugin. It needs to meet the following two points\uff1a\\n1. Implement interface `ShenyuPlugin` or `PluginDataHandler`.\\n2. After packaging the implemented package, place it in the corresponding path of \'shenyu. extPlugin. path\'.\\n\\n## Entry\\n\\nThe class that truly implements this logic is\' ShenyuLoaderService \'. Now let\'s take a look at how this class handles it.\\n\\n```java\\n    public ShenyuLoaderService(final ShenyuWebHandler webHandler, final CommonPluginDataSubscriber subscriber, final ShenyuConfig shenyuConfig) {\\n        // Information subscription for plugin information\\n        this.subscriber = subscriber;\\n        // The WebHandler encapsulated by Shenyu contains all the plugin logic\\n        this.webHandler = webHandler;\\n        // configuration information\\n        this.shenyuConfig = shenyuConfig;\\n        // The configuration information of the extension plugin, such as path, whether it is enabled, how many threads are enabled to process, and the frequency of loading checks\\n        ExtPlugin config = shenyuConfig.getExtPlugin();\\n        // If enabled, create a scheduled task to check and load\\n        if (config.getEnabled()) {\\n            // Create a scheduled task with a specified thread name\\n            ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(config.getThreads(), ShenyuThreadFactory.create(\\"plugin-ext-loader\\", true));\\n            // Create a task to be executed at a fixed frequency, with a default time of 30 seconds and execution every 300 seconds\\n            executor.scheduleAtFixedRate(() -> loadExtOrUploadPlugins(null), config.getScheduleDelay(), config.getScheduleTime(), TimeUnit.SECONDS);\\n        }\\n    }\\n    \\n```\\n\\nThis class has the following properties:\\n\\n`WebHandler`: This class is the entry point for shenyu to process requests, referencing all plugin data. After the extension plugin is loaded, it needs to be updated.\\n\\n`Subscriber`: This class is the entry point for the subscription of plugins, referencing the subscription processing classes of all plugins. After the extension configuration is loaded, synchronous updates are also required.\\n\\n`Executor`: A scheduled task will be created inside\' ShenyuLoaderService \'to periodically scan and load jar packages under the specified path, facilitating the loading of extended plugins and achieving dynamic discovery\\nBy default, it will scan every 300 seconds after 30 seconds of startup.\\n\\nMeanwhile, the decision to enable extension plugin functionality can be made through the configuration of `shenyu. extPlugin. enabled`.\\n\\nThe above configurations can be adjusted in the configuration file:\\n\\n```yaml\\nshenyu:\\n  extPlugin:\\n    path:   # Storage directory for extension plugins\\n    enabled: true # Is the extension function enabled\\n    threads: 1 # Number of threads loaded by scanning\\n    scheduleTime: 300 # The frequency of task execution\\n    scheduleDelay: 30 # How long after the task starts to execute\\n```\\n\\nNext, let\'s take a look at the loading logic\uff1a\\n\\n```java\\n   public void loadExtOrUploadPlugins(final PluginData uploadedJarResource) {\\n        try {\\n            List<ShenyuLoaderResult> plugins = new ArrayList<>();\\n            // Obtain the holding object of ShenyuPluginClassloader\\n            ShenyuPluginClassloaderHolder singleton = ShenyuPluginClassloaderHolder.getSingleton();\\n            if (Objects.isNull(uploadedJarResource)) {\\n                // If the parameter is empty, load all jar packages from the extended directory\\n                // PluginJar: Data containing the ShenyuPlugin interface and PluginDataHandler interface\\n                List<PluginJarParser.PluginJar> uploadPluginJars = ShenyuExtPathPluginJarLoader.loadExtendPlugins(shenyuConfig.getExtPlugin().getPath());\\n                // Traverse all pending plugins\\n                for (PluginJarParser.PluginJar extPath : uploadPluginJars) {\\n                    LOG.info(\\"shenyu extPlugin find new {} to load\\", extPath.getAbsolutePath());\\n                    // Use the loader of the extension plugin to load the specified plugin, facilitating subsequent loading and unloading\\n                    ShenyuPluginClassLoader extPathClassLoader = singleton.createPluginClassLoader(extPath);\\n                    // Using ShenyuPluginClassLoader for loading\\n                    // The main logic is to determine whether to implement ShenyuPlugin interface, PluginDataHandler interface, or identify annotations such as @ Component \\\\ @ Service. If so, register as SpringBean\\n                    // Construct ShenyuLoaderResult object\\n                    plugins.addAll(extPathClassLoader.loadUploadedJarPlugins());\\n                }\\n            } else {\\n                // Load the specified jar, with the same logic as loading all\\n                PluginJarParser.PluginJar pluginJar = PluginJarParser.parseJar(Base64.getDecoder().decode(uploadedJarResource.getPluginJar()));\\n                LOG.info(\\"shenyu upload plugin jar find new {} to load\\", pluginJar.getJarKey());\\n                ShenyuPluginClassLoader uploadPluginClassLoader = singleton.createPluginClassLoader(pluginJar);\\n                plugins.addAll(uploadPluginClassLoader.loadUploadedJarPlugins());\\n            }\\n            // Add the extended plugins to the plugin list of ShenyuWebHandler, and subsequent requests will go through the added plugin content\\n            loaderPlugins(plugins);\\n        } catch (Exception e) {\\n            LOG.error(\\"shenyu plugins load has error \\", e);\\n        }\\n    }\\n```\\n\\nThe logic processed by this method:\\n\\n1. Check if the parameter uploadedJarResource has a value. If not, all will be loaded. Otherwise, load the specified resource jar package for processing.\\n\\n2. Retrieve the specified jar package from `shenyu. extPlugin. path` and encapsulate it as a PluginJar object, which contains the following information about the jar package:\\n   - version: version information\\n\\n   - groupId: The groupId of the package\\n\\n   - artifactId: The artifactId of the package\\n\\n   - absolutePath: Absolute path\\n\\n   - clazzMap: Bytecode corresponding to class\\n\\n   - resourceMap: Bytecode of jar package\\n\\n3. Create a corresponding ClassLoader using `ShenyuPluginClassloaderHolder`, with the corresponding class being \'ShenyuPluginClassLoader\', and load the corresponding class accordingly.\\n\\n   - Call `ShenyuPluginClassLoader. loadUploadedJarPlugins` to load the corresponding class and register it as a Spring Bean, which can be managed using the Spring container\\n\\n4. Call the `loaderPlugins` method to update the extended plugin to\'`webHandler` and `subscriber`.\\n\\n## Plugin Registration\\n\\nFor the content in the provided jar package, the loader will only handle classes of the specified interface type, and the implementation logic is in the `ShenyuPluginClassLoader.loadUploadedJarPlugins()` method.\\n\\n```java\\npublic List<ShenyuLoaderResult> loadUploadedJarPlugins() {\\n        List<ShenyuLoaderResult> results = new ArrayList<>();\\n        // All class mapping relationships\\n        Set<String> names = pluginJar.getClazzMap().keySet();\\n        // Traverse all classes\\n        names.forEach(className -> {\\n            Object instance;\\n            try {\\n                // Try creating objects and, if possible, add them to the Spring container\\n                instance = getOrCreateSpringBean(className);\\n                if (Objects.nonNull(instance)) {\\n                    // Building the ShenyuLoaderResult object\\n                    results.add(buildResult(instance));\\n                    LOG.info(\\"The class successfully loaded into a upload-Jar-plugin {} is registered as a spring bean\\", className);\\n                }\\n            } catch (ClassNotFoundException | IllegalAccessException | InstantiationException e) {\\n                LOG.warn(\\"Registering upload-Jar-plugins succeeds spring bean fails:{}\\", className, e);\\n            }\\n        });\\n        return results;\\n    }\\n```\\n\\nThis method is responsible for building all eligible objects and encapsulating them into a `ShenyuLoaderResult` object. This object is encapsulated for the created object and will be processed in the method `buildResult()`.\\n\\n```java\\n    private ShenyuLoaderResult buildResult(final Object instance) {\\n        ShenyuLoaderResult result = new ShenyuLoaderResult();\\n        // Does the created object implement ShenyuPlugin\\n        if (instance instanceof ShenyuPlugin) {\\n            result.setShenyuPlugin((ShenyuPlugin) instance);\\n            // Does the created object implement PluginDataHandler\\n        } else if (instance instanceof PluginDataHandler) {\\n            result.setPluginDataHandler((PluginDataHandler) instance);\\n        }\\n        return result;\\n    }\\n```\\n\\nSimultaneously enter the method `getOrCreatSpringBean()` for further analysis:\\n\\n```java\\n    private <T> T getOrCreateSpringBean(final String className) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\\n        // Confirm if it has been registered. If so, do not process it and return directly\\n        if (SpringBeanUtils.getInstance().existBean(className)) {\\n            return SpringBeanUtils.getInstance().getBeanByClassName(className);\\n        }\\n        lock.lock();\\n        try {\\n            // Double check,\\n            T inst = SpringBeanUtils.getInstance().getBeanByClassName(className);\\n            if (Objects.isNull(inst)) {\\n                // Using ShenyuPluginClassLoader to load classes\\n                Class<?> clazz = Class.forName(className, false, this);\\n                //Exclude ShenyuPlugin subclass and PluginDataHandler subclass\\n                // without adding @Component @Service annotation\\n                // Confirm if it is a subclass of ShenyuPlugin or PluginDataHandler\\n                boolean next = ShenyuPlugin.class.isAssignableFrom(clazz)\\n                        || PluginDataHandler.class.isAssignableFrom(clazz);\\n                if (!next) {\\n                    // If not, confirm if @ Component and @ Service annotations are identified\\n                    Annotation[] annotations = clazz.getAnnotations();\\n                    next = Arrays.stream(annotations).anyMatch(e -> e.annotationType().equals(Component.class)\\n                            || e.annotationType().equals(Service.class));\\n                }\\n                if (next) {\\n                    // If the above content is met, register the bean\\n                    GenericBeanDefinition beanDefinition = new GenericBeanDefinition();\\n                    beanDefinition.setBeanClassName(className);\\n                    beanDefinition.setAutowireCandidate(true);\\n                    beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);\\n                    // Registering beans\\n                    String beanName = SpringBeanUtils.getInstance().registerBean(beanDefinition, this);\\n                    // create object\\n                    inst = SpringBeanUtils.getInstance().getBeanByClassName(beanName);\\n                }\\n            }\\n            return inst;\\n        } finally {\\n            lock.unlock();\\n        }\\n    }\\n```\\n\\nThe logic is roughly as follows:\\n1. Check if the interface `ShenyuPlugin` or `PluginDataHandler` has been implemented. If not, check if `@Component` or `@Service` has been identified`.\\n2. If the condition of 1 is met, register the object in the Spring container and return the created object.\\n\\n## Sync Data\\n\\nAfter the plugin registration is successful, the plugin is only instantiated, but it will not take effect yet because it has not been added to Shenyu\'s plugin chain. The synchronization logic is implemented by the `loaderPlugins()` method.\\n\\n```java\\n    private void loaderPlugins(final List<ShenyuLoaderResult> results) {\\n        if (CollectionUtils.isEmpty(results)) {\\n            return;\\n        }\\n        // Get all objects that implement the interface ShenyuPlugin\\n        List<ShenyuPlugin> shenyuExtendPlugins = results.stream().map(ShenyuLoaderResult::getShenyuPlugin).filter(Objects::nonNull).collect(Collectors.toList());\\n        // Synchronize updating plugins in webHandler\\n        webHandler.putExtPlugins(shenyuExtendPlugins);\\n        // Get all objects that implement the interface PluginDataHandler\\n        List<PluginDataHandler> handlers = results.stream().map(ShenyuLoaderResult::getPluginDataHandler).filter(Objects::nonNull).collect(Collectors.toList());\\n        // Synchronize updating handlers in subscriber\\n        subscriber.putExtendPluginDataHandler(handlers);\\n\\n    }\\n```\\n\\nThe logic of this method processes two data points:\\n1. Synchronize the data that implements the `ShenyuPlugin` interface to the plugins list of  `webHandler`.\\n\\n```java\\n    public void putExtPlugins(final List<ShenyuPlugin> extPlugins) {\\n        if (CollectionUtils.isEmpty(extPlugins)) {\\n            return;\\n        }\\n        // Filter out newly added plugins\\n        final List<ShenyuPlugin> shenyuAddPlugins = extPlugins.stream()\\n                .filter(e -> plugins.stream().noneMatch(plugin -> plugin.named().equals(e.named())))\\n                .collect(Collectors.toList());\\n        // Filter out updated plugins and determine if they have the same name as the old one, then it is an update\\n        final List<ShenyuPlugin> shenyuUpdatePlugins = extPlugins.stream()\\n                .filter(e -> plugins.stream().anyMatch(plugin -> plugin.named().equals(e.named())))\\n                .collect(Collectors.toList());\\n        // If there is no data, skip\\n        if (CollectionUtils.isEmpty(shenyuAddPlugins) && CollectionUtils.isEmpty(shenyuUpdatePlugins)) {\\n            return;\\n        }\\n        // Copy old data\\n        // copy new list\\n        List<ShenyuPlugin> newPluginList = new ArrayList<>(plugins);\\n        // Add new plugin data\\n        // Add extend plugin from pluginData or shenyu ext-lib\\n        this.sourcePlugins.addAll(shenyuAddPlugins);\\n        // Add new data\\n        if (CollectionUtils.isNotEmpty(shenyuAddPlugins)) {\\n            shenyuAddPlugins.forEach(plugin -> LOG.info(\\"shenyu auto add extends plugins:{}\\", plugin.named()));\\n            newPluginList.addAll(shenyuAddPlugins);\\n        }\\n        // Modify updated data\\n        if (CollectionUtils.isNotEmpty(shenyuUpdatePlugins)) {\\n            shenyuUpdatePlugins.forEach(plugin -> LOG.info(\\"shenyu auto update extends plugins:{}\\", plugin.named()));\\n            for (ShenyuPlugin updatePlugin : shenyuUpdatePlugins) {\\n                for (int i = 0; i < newPluginList.size(); i++) {\\n                    if (newPluginList.get(i).named().equals(updatePlugin.named())) {\\n                        newPluginList.set(i, updatePlugin);\\n                    }\\n                }\\n                for (int i = 0; i < this.sourcePlugins.size(); i++) {\\n                    if (this.sourcePlugins.get(i).named().equals(updatePlugin.named())) {\\n                        this.sourcePlugins.set(i, updatePlugin);\\n                    }\\n                }\\n            }\\n        }\\n        // REORDER\\n        plugins = sortPlugins(newPluginList);\\n    }\\n```\\n\\n2. Synchronize the data that implements the `PluginDataHandler` interface to the handlers list of the `subscriber`.\\n\\n```java\\n    public void putExtendPluginDataHandler(final List<PluginDataHandler> handlers) {\\n        if (CollectionUtils.isEmpty(handlers)) {\\n            return;\\n        }\\n        // Traverse all data\\n        for (PluginDataHandler handler : handlers) {\\n            String pluginNamed = handler.pluginNamed();\\n            // Update existing PluginDataHandler list\\n            MapUtils.computeIfAbsent(handlerMap, pluginNamed, name -> {\\n                LOG.info(\\"shenyu auto add extends plugin data handler name is :{}\\", pluginNamed);\\n                return handler;\\n            });\\n        }\\n    }\\n```\\n\\nAt this point, the analysis of the loading process of the extension plugin is completed."},{"id":"/Plugin-SourceCode-Analysis-Context-Path-Plugin","metadata":{"permalink":"/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin.md","source":"@site/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin.md","title":"Code Analysis For Context-Path Plugin","description":"Before starting, you can refer to this article to start the gateway","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"Context-Path","permalink":"/blog/tags/context-path"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":2.02,"hasTruncateMarker":false,"authors":[{"name":"Kunshuai Zhu","title":"Apache ShenYu Contributor","url":"https://github.com/JooKS-me","imageURL":"https://avatars1.githubusercontent.com/u/62384022?v=4"}],"frontMatter":{"title":"Code Analysis For Context-Path Plugin","author":"Kunshuai Zhu","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/JooKS-me","author_image_url":"https://avatars1.githubusercontent.com/u/62384022?v=4","tags":["Context-Path","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Extension plugin loading logic","permalink":"/blog/Loader-SourceCode-Analysis-ExtLoader"},"nextItem":{"title":"Code Analysis For Divide Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Divide-Plugin"}},"content":"> Before starting, you can refer to [this article](./start-demo) to start the gateway\\n\\n### Body\\n\\nFirst, look at the `ContextPathPlugin#doExecute` method, which is the core of this plugin.\\n\\n```java\\nprotected Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\\n    ...\\n    // 1. get the contextMappingHandle from the JVM cache\\n    ContextMappingHandle contextMappingHandle = ContextPathPluginDataHandler.CACHED_HANDLE.get().obtainHandle(CacheKeyUtils.INST.getKey(rule));\\n    ...\\n    // 2. set shenyu context according to contextMappingHandle\\n    buildContextPath(shenyuContext, contextMappingHandle);\\n    return chain.execute(exchange);\\n}\\n```\\n\\n1. Get the `contextMappingHandle` from the JVM cache\\n\\n   The `contextMappingHandle` here is an instance of the `ContextMappingHandle` class, which has two member variables: `contextPath` and `addPrefix`\\n\\n   These two variables have appeared in the Rules form in the Admin before, and they are updated when the data is synchronized.\\n\\n2. Set shenyu context according to contextMappingHandle\\n\\n   Below is the source code of the `ContextPathPlugin#buildContextPath` method\\n\\n   ```java\\n   private void buildContextPath(final ShenyuContext context, final ContextMappingHandle handle) {\\n       String realURI = \\"\\";\\n       // 1. set the context path of shenyu, remove the prefix of the real URI according to the length of the contextPath\\n       if (StringUtils.isNoneBlank(handle.getContextPath())) {\\n           context.setContextPath(handle.getContextPath());\\n           context.setModule(handle.getContextPath());\\n           realURI = context.getPath().substring(handle.getContextPath().length());\\n       }\\n       // add prefix\\n       if (StringUtils.isNoneBlank(handle.getAddPrefix())) {\\n           if (StringUtils.isNotBlank(realURI)) {\\n               realURI = handle.getAddPrefix() + realURI;\\n           } else {\\n               realURI = handle.getAddPrefix() + context.getPath();\\n           }\\n       }\\n       context.setRealUrl(realURI);\\n   }\\n   ```\\n\\n    - Set the context path of shenyu, **remove the prefix of the real URI according to the length of the contextPath**\\n\\n      You may be wondering whether **there is a problem with the so-called \\"according to the length of the contextPath\\" here**?\\n\\n      In fact, such a judgment is not a problem, because the request will be processed by the plugin only after it is matched by the Selector and Rules. Therefore, under the premise of setting up Selector and Rules, it is completely possible to meet the needs of converting a specific contextPath.\\n\\nThen, the `ContextPathPlugin` class has a more important method `skip`, part of the code is shown below. We can find: **If it is a call to the RPC service, the context_path plugin will be skipped directly.**\\n\\n```java\\npublic Boolean skip(final ServerWebExchange exchange) {\\n    ...\\n    return Objects.equals(rpcType, RpcTypeEnum.DUBBO.getName())\\n            || Objects.equals(rpcType, RpcTypeEnum.GRPC.getName())\\n            || Objects.equals(rpcType, RpcTypeEnum.TARS.getName())\\n            || Objects.equals(rpcType, RpcTypeEnum.MOTAN.getName())\\n            || Objects.equals(rpcType, RpcTypeEnum.SOFA.getName());\\n}\\n```\\n\\nFinally, the context-path plugin has another class `ContextPathPluginDataHandler`. The function of this class is to subscribe to the data of the plug-in. When the plugin configuration is modified, deleted, or added, the data is modified, deleted, or added to the JVM cache."},{"id":"/Plugin-SourceCode-Analysis-Divide-Plugin","metadata":{"permalink":"/blog/Plugin-SourceCode-Analysis-Divide-Plugin","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Plugin-SourceCode-Analysis-Divide-Plugin.md","source":"@site/blog/Plugin-SourceCode-Analysis-Divide-Plugin.md","title":"Code Analysis For Divide Plugin","description":"The ShenYu gateway uses the divide plugin to handle http requests. You can see the official documentation Quick start with Http to learn how to use this plugin.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"plugin","permalink":"/blog/tags/plugin"},{"label":"divide","permalink":"/blog/tags/divide"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":20.635,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"Code Analysis For Divide Plugin","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["plugin","divide","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Code Analysis For Context-Path Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin"},"nextItem":{"title":"Code Analysis For Dubbo Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin"}},"content":"The `ShenYu` gateway uses the `divide` plugin to handle `http` requests. You can see the official documentation [Quick start with Http](https://shenyu.apache.org/docs/quick-start/quick-start-http) to learn how to use this plugin.\\n\\n> This article is based on `shenyu-2.4.3` version for source code analysis, please refer to [Http Proxy](https://shenyu.apache.org/docs/user-guide/proxy/http-proxy) for the introduction of the official website.\\n\\n### 1. Register Service\\n\\n#### 1.1  Declaration of registration interface\\n\\nUse the annotation `@ShenyuSpringMvcClient` to register the service to the gateway. The simple `demo` is as follows.\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/order\\")\\n@ShenyuSpringMvcClient(path = \\"/order\\")  // API\\npublic class OrderController {\\n    @GetMapping(\\"/findById\\")\\n    @ShenyuSpringMvcClient(path = \\"/findById\\", desc = \\"Find by id\\") // method\\n    public OrderDTO findById(@RequestParam(\\"id\\") final String id) {\\n        return build(id, \\"hello world findById\\");\\n    }\\n}\\n```\\n\\ndefine annotation:\\n\\n```java\\n\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target({ElementType.TYPE, ElementType.METHOD})\\npublic @interface ShenyuSpringMvcClient {\\n    \\n\\t//path\\n    String path() default \\"\\";\\n    \\n    //rule name\\n    String ruleName() default \\"\\";\\n   \\n    //desc info\\n    String desc() default \\"\\";\\n\\n    //is enabled\\n    boolean enabled() default true;\\n    \\n    //register MetaData\\n    boolean registerMetaData() default false;\\n}\\n\\n```\\n\\n#### 1.2 Scan annotation \\n\\nAnnotation scanning is done through `SpringMvcClientBeanPostProcessor`, which implements the `BeanPostProcessor` interface and is a post-processor provided by `Spring`.\\n\\nDuring constructor instantiation.\\n\\n- Read the property configuration\\n- Add annotations, read `path` information\\n- Start the registry and register with `shenyu-admin`\\n\\n```java\\npublic class SpringMvcClientBeanPostProcessor implements BeanPostProcessor {\\n    //...\\n    /**\\n     * Constructor instantiation\\n     */\\n    public SpringMvcClientBeanPostProcessor(final PropertiesConfig clientConfig,\\n                                            final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        // 1. read Properties\\n        Properties props = clientConfig.getProps();\\n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\\n        this.contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH, \\"\\");\\n        if (StringUtils.isBlank(appName) && StringUtils.isBlank(contextPath)) {\\n            String errorMsg = \\"http register param must config the appName or contextPath\\";\\n            LOG.error(errorMsg);\\n            throw new ShenyuClientIllegalArgumentException(errorMsg);\\n        }\\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\\n        // 2. add annotation\\n        mappingAnnotation.add(ShenyuSpringMvcClient.class);\\n        mappingAnnotation.add(PostMapping.class);\\n        mappingAnnotation.add(GetMapping.class);\\n        mappingAnnotation.add(DeleteMapping.class);\\n        mappingAnnotation.add(PutMapping.class);\\n        mappingAnnotation.add(RequestMapping.class);\\n        // 3. start register cneter\\n        publisher.start(shenyuClientRegisterRepository);\\n    }\\n    \\n    @Override\\n    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {\\n       // override post process\\n        \\n        return bean;\\n    }\\n    \\n```\\n\\n- SpringMvcClientBeanPostProcessor#postProcessAfterInitialization()\\n\\nRewrite post-processor logic: read annotation information, construct metadata objects and `URI` objects, and register them with `shenyu-admin`.\\n\\n```java\\n    @Override\\n    public Object postProcessAfterInitialization(@NonNull final Object bean, @NonNull final String beanName) throws BeansException {\\n        // 1. If the all service is registered or is not a Controller class, it is not handled\\n        if (Boolean.TRUE.equals(isFull) || !hasAnnotation(bean.getClass(), Controller.class)) {\\n            return bean;\\n        }\\n        // 2. Read the annotations on the class ShenyuSpringMvcClient\\n        final ShenyuSpringMvcClient beanShenyuClient = AnnotationUtils.findAnnotation(bean.getClass(), ShenyuSpringMvcClient.class);\\n        // 2.1 build  superPath\\n        final String superPath = buildApiSuperPath(bean.getClass());\\n        // 2.2 whether to register the entire class method\\n        if (Objects.nonNull(beanShenyuClient) && superPath.contains(\\"*\\")) {\\n            // build the metadata object and register it with shenyu-admin\\n            publisher.publishEvent(buildMetaDataDTO(beanShenyuClient, pathJoin(contextPath, superPath)));\\n            return bean;\\n        }\\n        // 3. read all methods\\n        final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(bean.getClass());\\n        for (Method method : methods) {\\n            // 3.1 read the annotations on the method ShenyuSpringMvcClient\\n            ShenyuSpringMvcClient methodShenyuClient = AnnotationUtils.findAnnotation(method, ShenyuSpringMvcClient.class);\\n            // If there is no annotation on the method, use the annotation on the class\\n            methodShenyuClient = Objects.isNull(methodShenyuClient) ? beanShenyuClient : methodShenyuClient;\\n            if (Objects.nonNull(methodShenyuClient)) {\\n               // 3.2 Build path information, build metadata objects, register with shenyu-admin\\n                publisher.publishEvent(buildMetaDataDTO(methodShenyuClient, buildApiPath(method, superPath)));\\n            }\\n        }\\n        \\n        return bean;\\n    }\\n```\\n\\n- 1. If you are registering the whole service or not `Controller` class, do not handle it\\n- 2. read the annotation on the class `ShenyuSpringMvcClient`, if the whole class is registered, build the metadata object here and register it with `shenyu-admin`.\\n- 3. Annotation on the handler method `ShenyuSpringMvcClient`, build `path` information for the specific method, build the metadata object and then register it with `shenyu-admin`\\n\\n\\nThere are two methods here that take `path` and need special instructions.\\n\\n\\n- buildApiSuperPath()\\n\\nConstruct `SuperPath`: first take the `path` property from the annotation `ShenyuSpringMvcClient` on the class, if not, take the `path` information from the `RequestMapping` annotation on the current class.\\n\\n```java\\n    private String buildApiSuperPath(@NonNull final Class<?> method) {\\n        // First take the path property from the annotation ShenyuSpringMvcClient on the class\\n        ShenyuSpringMvcClient shenyuSpringMvcClient = AnnotationUtils.findAnnotation(method, ShenyuSpringMvcClient.class);\\n        if (Objects.nonNull(shenyuSpringMvcClient) && StringUtils.isNotBlank(shenyuSpringMvcClient.path())) {\\n            return shenyuSpringMvcClient.path();\\n        }\\n        // Take the path information from the RequestMapping annotation of the current class\\n        RequestMapping requestMapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);\\n        if (Objects.nonNull(requestMapping) && ArrayUtils.isNotEmpty(requestMapping.path()) && StringUtils.isNotBlank(requestMapping.path()[0])) {\\n            return requestMapping.path()[0];\\n        }\\n        return \\"\\";\\n    }\\n```\\n\\n- buildApiPath()\\n\\nBuild `path`: first read the annotation `ShenyuSpringMvcClient` on the method and build it if it exists; otherwise get the `path` information from other annotations on the method; complete `path = contextPath(context information) + superPath(class information) + methodPath(method information)`.\\n\\n```java\\n    private String buildApiPath(@NonNull final Method method, @NonNull final String superPath) {\\n        // 1. Read the annotation ShenyuSpringMvcClient on the method\\n        ShenyuSpringMvcClient shenyuSpringMvcClient = AnnotationUtils.findAnnotation(method, ShenyuSpringMvcClient.class);\\n        // 1.1 If path exists, build\\n        if (Objects.nonNull(shenyuSpringMvcClient) && StringUtils.isNotBlank(shenyuSpringMvcClient.path())) {\\n            //1.2  path = contextPath+superPath+methodPath\\n            return pathJoin(contextPath, superPath, shenyuSpringMvcClient.path());\\n        }\\n        // 2. Get path information from other annotations on the method\\n        final String path = getPathByMethod(method);\\n        if (StringUtils.isNotBlank(path)) {\\n             // 2.1 path = contextPath+superPath+methodPath\\n            return pathJoin(contextPath, superPath, path);\\n        }\\n        return pathJoin(contextPath, superPath);\\n    }\\n```\\n\\n- getPathByMethod()\\n\\nGet `path` information from other annotations on the method, other annotations include.\\n   - ShenyuSpringMvcClient\\n   - PostMapping\\n   - GetMapping\\n   - DeleteMapping\\n   - PutMapping\\n   - RequestMapping\\n\\n\\n```java\\n\\n    private String getPathByMethod(@NonNull final Method method) {\\n        // Iterate through interface annotations to get path information\\n        for (Class<? extends Annotation> mapping : mappingAnnotation) {\\n            final String pathByAnnotation = getPathByAnnotation(AnnotationUtils.findAnnotation(method, mapping), pathAttributeNames);\\n            if (StringUtils.isNotBlank(pathByAnnotation)) {\\n                return pathByAnnotation;\\n            }\\n        }\\n        return null;\\n    }\\n```\\n\\nAfter the scanning annotation is finished, construct the metadata object and send the object to `shenyu-admin` to complete the registration.\\n\\n- Metadata \\n\\nIncludes the rule information of the currently registered method: contextPath, appName, registration path, description information, registration type, whether it is enabled, rule name and whether to register metadata.\\n\\n```java\\n private MetaDataRegisterDTO buildMetaDataDTO(@NonNull final ShenyuSpringMvcClient shenyuSpringMvcClient, final String path) {\\n        return MetaDataRegisterDTO.builder()\\n                .contextPath(contextPath) // contextPath\\n                .appName(appName) // appName\\n                .path(path) // Registered path, used when gateway rules match\\n                .pathDesc(shenyuSpringMvcClient.desc()) // desc info\\n                .rpcType(RpcTypeEnum.HTTP.getName()) // divide plugin, http type when default\\n                .enabled(shenyuSpringMvcClient.enabled()) // is enabled?\\n                .ruleName(StringUtils.defaultIfBlank(shenyuSpringMvcClient.ruleName(), path))//rule name\\n                .registerMetaData(shenyuSpringMvcClient.registerMetaData()) // whether to register metadata information\\n                .build();\\n    }\\n```\\n\\nThe specific registration logic is implemented by the registration center, which has been analyzed in the previous articles and will not be analyzed in depth here.\\n\\n#### 1.3 Register URI Data\\n\\n`ContextRegisterListener` is responsible for registering the client\'s `URI` information to `shenyu-admin`, it implements the `ApplicationListener` interface, when the context refresh event `ContextRefreshedEvent` occurs, the `onApplicationEvent()` method is executed to implement the registration logic.\\n\\n```java\\n\\npublic class ContextRegisterListener implements ApplicationListener<ContextRefreshedEvent>, BeanFactoryAware {\\n\\t//......\\n    \\n    /**\\n     * Constructor instantiation\\n     */\\n    public ContextRegisterListener(final PropertiesConfig clientConfig) {\\n        // read Properties\\n        final Properties props = clientConfig.getProps();\\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\\n        this.contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);\\n        if (Boolean.TRUE.equals(isFull)) {\\n            if (StringUtils.isBlank(contextPath)) {\\n                final String errorMsg = \\"http register param must config the contextPath\\";\\n                LOG.error(errorMsg);\\n                throw new ShenyuClientIllegalArgumentException(errorMsg);\\n            }\\n        }\\n        this.port = Integer.parseInt(Optional.ofNullable(props.getProperty(ShenyuClientConstants.PORT)).orElseGet(() -> \\"-1\\"));\\n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\\n        this.protocol = props.getProperty(ShenyuClientConstants.PROTOCOL, ShenyuClientConstants.HTTP);\\n        this.host = props.getProperty(ShenyuClientConstants.HOST);\\n    }\\n\\n    @Override\\n    public void setBeanFactory(final BeanFactory beanFactory) throws BeansException {\\n        this.beanFactory = beanFactory;\\n    }\\n\\n    // Execute application events\\n    @Override\\n    public void onApplicationEvent(@NonNull final ContextRefreshedEvent contextRefreshedEvent) {\\n          // The method is guaranteed to be executed once\\n        if (!registered.compareAndSet(false, true)) {\\n            return;\\n        }\\n        // 1. If you are registering for the entire service\\n        if (Boolean.TRUE.equals(isFull)) {\\n            // Build metadata and register\\n            publisher.publishEvent(buildMetaDataDTO());\\n        }\\n        try {\\n            // get port\\n            final int mergedPort = port <= 0 ? PortUtils.findPort(beanFactory) : port;\\n            // 2. Constructing URI data and registering\\n            publisher.publishEvent(buildURIRegisterDTO(mergedPort));\\n        } catch (ShenyuException e) {\\n            throw new ShenyuException(e.getMessage() + \\"please config ${shenyu.client.http.props.port} in xml/yml !\\");\\n        }\\n    }\\n\\n    // build URI data\\n    private URIRegisterDTO buildURIRegisterDTO(final int port) {\\n        return URIRegisterDTO.builder()\\n            .contextPath(this.contextPath) // contextPath\\n            .appName(appName) // appName\\n            .protocol(protocol) // protocol\\n            .host(IpUtils.isCompleteHost(this.host) ? this.host : IpUtils.getHost(this.host)) //host\\n            .port(port) // port\\n            .rpcType(RpcTypeEnum.HTTP.getName()) // divide plugin, default registration http type\\n            .build();\\n    }\\n\\n    // build MetaData\\n    private MetaDataRegisterDTO buildMetaDataDTO() {\\n        return MetaDataRegisterDTO.builder()\\n            .contextPath(contextPath)\\n            .appName(appName)\\n            .path(contextPath)\\n            .rpcType(RpcTypeEnum.HTTP.getName())\\n            .enabled(true)\\n            .ruleName(contextPath)\\n            .build();\\n    }\\n}\\n```\\n\\n#### 1.4 Handle registration information\\n\\nThe metadata and `URI` data registered by the client through the registry are processed in `shenyu-admin`, which is responsible for storing to the database and synchronizing to the `shenyu` gateway. The client registration processing logic of `Divide` plugin is in `ShenyuClientRegisterDivideServiceImpl`. The inheritance relationship is as follows.\\n\\n![](/img/activities/code-analysis-divide-plugin/ShenyuClientRegisterDivideServiceImpl.png)\\n\\n- ShenyuClientRegisterService: client registration service, top-level interface.\\n- FallbackShenyuClientRegisterService: registration failure, provides retry operation.\\n- AbstractShenyuClientRegisterServiceImpl: abstract class, implements part of the public registration logic;\\n- AbstractContextPathRegisterService: abstract class, responsible for registering `ContextPath`.\\n- ShenyuClientRegisterDivideServiceImpl: implementation of the `Divide` plug-in registration.\\n\\n\\n##### 1.4.1 Register Service\\n\\n- org.apache.shenyu.admin.service.register.AbstractShenyuClientRegisterServiceImpl#register()\\n\\nThe metadata `MetaDataRegisterDTO` object registered by the client through the registry is picked up and dropped in the `register()` method of `shenyu-admin`.\\n\\n```java\\n   @Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        String selectorHandler = selectorHandler(dto);\\n        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);\\n        //2. register rule\\n        String ruleHandler = ruleHandler();\\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\\n        ruleService.registerDefault(ruleDTO);\\n        //3. register metadat\\n        registerMetadata(dto);\\n        //4. register ContextPath\\n        String contextPath = dto.getContextPath();\\n        if (StringUtils.isNotEmpty(contextPath)) {\\n            registerContextPath(dto);\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n###### 1.4.1.1 Register Selector\\n\\n- org.apache.shenyu.admin.service.impl.SelectorServiceImpl#registerDefault()\\n\\nBuild `contextPath`, find if the selector information exists, if it does, return `id`; if it doesn\'t, create the default selector information.\\n\\n```java\\n    @Override\\n    public String registerDefault(final MetaDataRegisterDTO dto, final String pluginName, final String selectorHandler) {\\n        // build contextPath\\n        String contextPath = ContextPathUtils.buildContextPath(dto.getContextPath(), dto.getAppName());\\n        // Find if selector information exists by name\\n        SelectorDO selectorDO = findByNameAndPluginName(contextPath, pluginName);\\n        if (Objects.isNull(selectorDO)) {\\n            // Create a default selector message if it does not exist\\n            return registerSelector(contextPath, pluginName, selectorHandler);\\n        }\\n        return selectorDO.getId();\\n    }\\n```\\n\\n- Default Selector Information\\n\\nConstruct the default selector information and its conditional properties here.\\n\\n```java\\n   //register selector\\n   private String registerSelector(final String contextPath, final String pluginName, final String selectorHandler) {\\n        // build selector \\n        SelectorDTO selectorDTO = buildSelectorDTO(contextPath, pluginMapper.selectByName(pluginName).getId());\\n        selectorDTO.setHandle(selectorHandler);\\n        //register default Selector\\n        return registerDefault(selectorDTO);\\n    }\\n     //build\\n    private SelectorDTO buildSelectorDTO(final String contextPath, final String pluginId) {\\n        //build default\\n        SelectorDTO selectorDTO = buildDefaultSelectorDTO(contextPath);\\n        selectorDTO.setPluginId(pluginId);\\n         //build the conditional properties of the default selector\\n        selectorDTO.setSelectorConditions(buildDefaultSelectorConditionDTO(contextPath));\\n        return selectorDTO;\\n    }\\n```\\n\\n- Build Default Selector\\n\\n```\\nprivate SelectorDTO buildDefaultSelectorDTO(final String name) {\\n    return SelectorDTO.builder()\\n            .name(name) // name\\n            .type(SelectorTypeEnum.CUSTOM_FLOW.getCode()) // default CUSTOM_FLOW\\n            .matchMode(MatchModeEnum.AND.getCode()) //default  AND\\n            .enabled(Boolean.TRUE)  //default TRUE\\n            .loged(Boolean.TRUE)  //default TRUE\\n            .continued(Boolean.TRUE) //default TRUE\\n            .sort(1) //default 1\\n            .build();\\n}\\n\\n\\n```\\n\\n- Build default selector conditional properties\\n\\n```java\\nprivate List<SelectorConditionDTO> buildDefaultSelectorConditionDTO(final String contextPath) {\\n    SelectorConditionDTO selectorConditionDTO = new SelectorConditionDTO();\\n    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName()); // default URI\\n    selectorConditionDTO.setParamName(\\"/\\");\\n    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias()); // default match\\n    selectorConditionDTO.setParamValue(contextPath + AdminConstants.URI_SUFFIX); // default /contextPath/**\\n    return Collections.singletonList(selectorConditionDTO);\\n}\\n```\\n\\n- Register default selector\\n\\n```\\n@Override\\npublic String registerDefault(final SelectorDTO selectorDTO) {\\n    //selector info\\n    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n    //selector condition  info\\n    List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n    if (StringUtils.isEmpty(selectorDTO.getId())) {\\n        // insert selector information into the database\\n        selectorMapper.insertSelective(selectorDO);\\n          // insert selector condition information into the database\\n        selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n            selectorConditionDTO.setSelectorId(selectorDO.getId());        \\n                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n        });\\n    }\\n    // Publish synchronization events to synchronize selection information and its conditional attributes to the gateway\\n    publishEvent(selectorDO, selectorConditionDTOs);\\n    return selectorDO.getId();\\n}\\n```\\n\\n###### 1.4.1.2 Register Rule\\n\\nIn the second step of registering the service, start building the default rules and then register the rules.\\n\\n```java\\n@Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        //......\\n        \\n        //2. register rule\\n        // default rule handle\\n        String ruleHandler = ruleHandler();\\n        // build default rule\\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\\n        // register rule\\n        ruleService.registerDefault(ruleDTO);\\n        \\n        //3. register Metadata\\n        //......\\n        \\n        //4. register ContextPath\\n        //......\\n        \\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n- default rule handle\\n\\n```java\\n    @Override\\n    protected String ruleHandler() {\\n        // default rule handle\\n        return new DivideRuleHandle().toJson();\\n    }\\n```\\n\\n`Divide` plugin default rule handle.\\n\\n```java\\n\\npublic class DivideRuleHandle implements RuleHandle {\\n\\n    /**\\n     * load balance: default RANDOM\\n     */\\n    private String loadBalance = LoadBalanceEnum.RANDOM.getName();\\n\\n    /**\\n     * retry strategy: default CURRENT\\n     */\\n    private String retryStrategy = RetryEnum.CURRENT.getName();\\n\\n    /**\\n     * retry: default 3\\n     */\\n    private int retry = 3;\\n\\n    /**\\n     *  retry: default 3000\\n     */\\n    private long timeout = Constants.TIME_OUT;\\n\\n    /**\\n     *  retry: default  10240 byte\\n     */\\n    private long headerMaxSize = Constants.HEADER_MAX_SIZE;\\n\\n    /**\\n     *  retry: default 102400 byte\\n     */\\n    private long requestMaxSize = Constants.REQUEST_MAX_SIZE;\\n}\\n```\\n\\n- build default rule info\\n\\n```java\\n  // build default rule info\\n    private RuleDTO buildRpcDefaultRuleDTO(final String selectorId, final MetaDataRegisterDTO metaDataDTO, final String ruleHandler) {\\n        return buildRuleDTO(selectorId, ruleHandler, metaDataDTO.getRuleName(), metaDataDTO.getPath());\\n    }\\n   //  build default rule info\\n    private RuleDTO buildRuleDTO(final String selectorId, final String ruleHandler, final String ruleName, final String path) {\\n        RuleDTO ruleDTO = RuleDTO.builder()\\n                .selectorId(selectorId) //selector Id\\n                .name(ruleName) //rule Name\\n                .matchMode(MatchModeEnum.AND.getCode()) // default and\\n                .enabled(Boolean.TRUE) // default TRUE\\n                .loged(Boolean.TRUE) //default TRUE\\n                .sort(1) //default 1\\n                .handle(ruleHandler)\\n                .build();\\n        RuleConditionDTO ruleConditionDTO = RuleConditionDTO.builder()\\n                .paramType(ParamTypeEnum.URI.getName()) // default URI\\n                .paramName(\\"/\\")\\n                .paramValue(path) // path\\n                .build();\\n        if (path.indexOf(\\"*\\") > 1) {\\n            ruleConditionDTO.setOperator(OperatorEnum.MATCH.getAlias()); //if the path conatins *, default match\\n        } else {\\n            ruleConditionDTO.setOperator(OperatorEnum.EQ.getAlias()); // default = \\n        }\\n        ruleDTO.setRuleConditions(Collections.singletonList(ruleConditionDTO));\\n        return ruleDTO;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.impl.RuleServiceImpl#registerDefault()\\n\\nRegistration rules: insert records to the database and publish events to the gateway for data synchronization.\\n\\n```java\\n\\n    @Override\\n    public String registerDefault(final RuleDTO ruleDTO) {\\n        RuleDO exist = ruleMapper.findBySelectorIdAndName(ruleDTO.getSelectorId(), ruleDTO.getName());\\n        if (Objects.nonNull(exist)) {\\n            return \\"\\";\\n        }\\n\\n        RuleDO ruleDO = RuleDO.buildRuleDO(ruleDTO);\\n        List<RuleConditionDTO> ruleConditions = ruleDTO.getRuleConditions();\\n        if (StringUtils.isEmpty(ruleDTO.getId())) {\\n            // insert rule into database \\n            ruleMapper.insertSelective(ruleDO);\\n            //insert rule condition into database \\n            ruleConditions.forEach(ruleConditionDTO -> {\\n                ruleConditionDTO.setRuleId(ruleDO.getId());           \\n                ruleConditionMapper.insertSelective(RuleConditionDO.buildRuleConditionDO(ruleConditionDTO));\\n            });\\n        }\\n        // Publish events to the gateway for data synchronization\\n        publishEvent(ruleDO, ruleConditions);\\n        return ruleDO.getId();\\n    }\\n\\n```\\n\\n\\n###### 1.4.1.3 Register Metadata\\n\\n\\n```java\\n   @Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        //......\\n        \\n        //2. register rule\\n        //......\\n        \\n        //3. register metadata\\n        registerMetadata(dto);\\n        \\n        //4. register ContextPath\\n        //......\\n        \\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.register.ShenyuClientRegisterDivideServiceImpl#registerMetadata()\\n\\nInsert or update metadata and then publish sync events to the gateway.\\n\\n```java\\n\\n    @Override\\n    protected void registerMetadata(final MetaDataRegisterDTO dto) {\\n        if (dto.isRegisterMetaData()) { \\n            MetaDataService metaDataService = getMetaDataService();\\n            MetaDataDO exist = metaDataService.findByPath(dto.getPath());\\n            // save or update MetaData\\n            metaDataService.saveOrUpdateMetaData(exist, dto);\\n        }\\n    }\\n\\n    @Override\\n    public void saveOrUpdateMetaData(final MetaDataDO exist, final MetaDataRegisterDTO metaDataDTO) {\\n        DataEventTypeEnum eventType;\\n        //  DTO->DO\\n        MetaDataDO metaDataDO = MetaDataTransfer.INSTANCE.mapRegisterDTOToEntity(metaDataDTO);\\n        // insert\\n        if (Objects.isNull(exist)) {\\n            Timestamp currentTime = new Timestamp(System.currentTimeMillis());\\n            metaDataDO.setId(UUIDUtils.getInstance().generateShortUuid());\\n            metaDataDO.setDateCreated(currentTime);\\n            metaDataDO.setDateUpdated(currentTime);\\n            metaDataMapper.insert(metaDataDO);\\n            eventType = DataEventTypeEnum.CREATE;\\n        } else {\\n            // update\\n            metaDataDO.setId(exist.getId());\\n            metaDataMapper.update(metaDataDO);\\n            eventType = DataEventTypeEnum.UPDATE;\\n        }\\n        // publish event to  gateway\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.META_DATA, eventType,\\n                Collections.singletonList(MetaDataTransfer.INSTANCE.mapToData(metaDataDO))));\\n    }\\n```\\n\\n###### 1.4.1.4 Register ContextPath\\n\\n```java\\n   @Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        //......\\n        \\n        //2. register rule\\n        //......\\n        \\n        //3. register metadata\\n        //......\\n        \\n        //4. register ContextPath\\n        String contextPath = dto.getContextPath();\\n        if (StringUtils.isNotEmpty(contextPath)) {\\n            registerContextPath(dto);\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.register.AbstractContextPathRegisterService#registerContextPath()\\n\\n```java\\n    @Override\\n    public void registerContextPath(final MetaDataRegisterDTO dto) {\\n        // set contextPath for selector\\n        String contextPathSelectorId = getSelectorService().registerDefault(dto, PluginEnum.CONTEXT_PATH.getName(), \\"\\");\\n        ContextMappingRuleHandle handle = new ContextMappingRuleHandle();\\n        handle.setContextPath(PathUtils.decoratorContextPath(dto.getContextPath()));\\n        // set contextPath for rule\\n        getRuleService().registerDefault(buildContextPathDefaultRuleDTO(contextPathSelectorId, dto, handle.toJson()));\\n    }\\n```\\n\\n\\n##### 1.4.2 Register URI\\n\\n- org.apache.shenyu.admin.service.register.FallbackShenyuClientRegisterService#registerURI()\\n\\nThe server side receives the `URI` information registered by the client and processes it.\\n\\n```java\\n    @Override\\n    public String registerURI(final String selectorName, final List<URIRegisterDTO> uriList) {\\n        String result;\\n        String key = key(selectorName);\\n        try {\\n            this.removeFallBack(key);\\n            // register URI\\n            result = this.doRegisterURI(selectorName, uriList);\\n            logger.info(\\"Register success: {},{}\\", selectorName, uriList);\\n        } catch (Exception ex) {\\n            logger.warn(\\"Register exception: cause:{}\\", ex.getMessage());\\n            result = \\"\\";\\n            // Retry after registration failure\\n            this.addFallback(key, new FallbackHolder(selectorName, uriList));\\n        }\\n        return result;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.register.AbstractShenyuClientRegisterServiceImpl#doRegisterURI()\\n\\nGet a valid `URI` from the `URI` registered by the client, update the corresponding selector `handle` property, and send a selector update event to the gateway.\\n\\n```java\\n@Override\\n    public String doRegisterURI(final String selectorName, final List<URIRegisterDTO> uriList) {\\n        //check\\n        if (CollectionUtils.isEmpty(uriList)) {\\n            return \\"\\";\\n        }\\n        //get selector \\n        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n        if (Objects.isNull(selectorDO)) {\\n            throw new ShenyuException(\\"doRegister Failed to execute,wait to retry.\\");\\n        }\\n        // gte valid URI\\n        List<URIRegisterDTO> validUriList = uriList.stream().filter(dto -> Objects.nonNull(dto.getPort()) && StringUtils.isNotBlank(dto.getHost())).collect(Collectors.toList());\\n        // build handle\\n        String handler = buildHandle(validUriList, selectorDO);\\n        if (handler != null) {\\n            selectorDO.setHandle(handler);\\n            SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n            selectorData.setHandle(handler);\\n            // Update the handle property of the selector to the database\\n            selectorService.updateSelective(selectorDO);\\n            // Send selector update events to the gateway\\n            eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\nThe source code analysis on service registration is completed as well as the analysis flow chart is as follows.\\n\\n![](/img/activities/code-analysis-divide-plugin/divide-register-zh.png)\\n\\nThe next step is to analyze how the `divide` plugin initiates a call to the `http` service based on this information.\\n\\n\\n### 2. Call Http Service \\n\\nThe `divide` plugin is the core processing plugin used by the gateway to handle `http protocol` requests.\\n\\nTake the case provided on the official website [Quick start with Http](https://shenyu.apache.org/docs/quick-start/quick-start-http) as an example, a direct connection request is as follows.\\n\\n```\\nGET http://localhost:8189/order/findById?id=100\\nAccept: application/json\\n```\\n\\n\\nAfter proxying through the `ShenYu` gateway, the request is as follows.\\n\\n```\\nGET http://localhost:9195/http/order/findById?id=100\\nAccept: application/json\\n```\\n\\nThe services proxied by the `ShenYu` gateway are still able to request the previous services, where the `divide` plugin comes into play. The class inheritance relationship is as follows.\\n\\n![](/img/activities/code-analysis-divide-plugin/DividePlugin.png)\\n\\n- ShenyuPlugin: top-level interface, defining interface methods.\\n- AbstractShenyuPlugin: abstract class that implements the common logic of the pluin.\\n- DividePlugin: Divide pluin.\\n\\n#### 2.1 Accept Request\\n\\nAfter passing the `ShenYu` gateway proxy, the request entry is `ShenyuWebHandler`, which implements the `org.springframework.web.server.WebHandler` interface.\\n\\n```\\npublic final class ShenyuWebHandler implements WebHandler, ApplicationListener<SortPluginEvent> {\\n    //......\\n    \\n    /**\\n     * hanlde web reuest\\n     */\\n    @Override\\n    public Mono<Void> handle(@NonNull final ServerWebExchange exchange) {\\n       // execute plugin chain\\n        Mono<Void> execute = new DefaultShenyuPluginChain(plugins).execute(exchange);\\n        if (scheduled) {\\n            return execute.subscribeOn(scheduler);\\n        }\\n        return execute;\\n    }\\n    \\n    private static class DefaultShenyuPluginChain implements ShenyuPluginChain {\\n\\n        private int index;\\n\\n        private final List<ShenyuPlugin> plugins;\\n\\n        /**\\n         * Instantiating the default plugin chain\\n         */\\n        DefaultShenyuPluginChain(final List<ShenyuPlugin> plugins) {\\n            this.plugins = plugins;\\n        }\\n\\n        /**\\n         * Execute each plugin\\n         */\\n        @Override\\n        public Mono<Void> execute(final ServerWebExchange exchange) {\\n            return Mono.defer(() -> {\\n                if (this.index < plugins.size()) {\\n                    // get current plugin \\n                    ShenyuPlugin plugin = plugins.get(this.index++);\\n                    // is skip ?\\n                    boolean skip = plugin.skip(exchange);\\n                    if (skip) {\\n                        // If skipped, execute the next\\n                        return this.execute(exchange);\\n                    }\\n                    // execute current plugin \\n                    return plugin.execute(exchange, this);\\n                }\\n                return Mono.empty();\\n            });\\n        }\\n    }\\n}\\n```\\n\\n#### 2.2 Matching rule\\n\\n- org.apache.shenyu.plugin.base.AbstractShenyuPlugin#execute()\\n\\nExecute the matching logic for selectors and rules in the `execute()` method.\\n\\n- Matching selectors.\\n- Matching rules.\\n- Execute the plugin.\\n\\n```java\\n@Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        String pluginName = named();\\n        PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);\\n        if (pluginData != null && pluginData.getEnabled()) {\\n            // selector \\n            final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);\\n            if (CollectionUtils.isEmpty(selectors)) {\\n                return handleSelectorIfNull(pluginName, exchange, chain);\\n            }\\n            // match selector\\n            SelectorData selectorData = matchSelector(exchange, selectors);\\n            if (Objects.isNull(selectorData)) {\\n                return handleSelectorIfNull(pluginName, exchange, chain);\\n            }\\n            selectorLog(selectorData, pluginName);\\n            // rule \\n            List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());\\n            if (CollectionUtils.isEmpty(rules)) {\\n                return handleRuleIfNull(pluginName, exchange, chain);\\n            }\\n            // match rule \\n            RuleData rule;\\n            if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {\\n                //get last\\n                rule = rules.get(rules.size() - 1);\\n            } else {\\n                rule = matchRule(exchange, rules);\\n            }\\n            if (Objects.isNull(rule)) {\\n                return handleRuleIfNull(pluginName, exchange, chain);\\n            }\\n            ruleLog(rule, pluginName);\\n            // execute \\n            return doExecute(exchange, chain, selectorData, rule);\\n        }\\n        return chain.execute(exchange);\\n    }\\n```\\n\\n#### 2.3 Execute Divide Plugin\\n\\n- org.apache.shenyu.plugin.divide.DividePlugin#doExecute()\\n\\nExecute the specific logic of the `divide` plugin in the `doExecute()` method.\\n\\n- Checks the `header` size.\\n- Checking the `request` size.\\n- Obtaining the list of services.\\n- implementing load balancing.\\n- Set request `url`, timeout time, retry policy.\\n\\n```java\\n@Override\\n    protected Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\\n        // shenyu Context\\n        ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        assert shenyuContext != null;\\n        // Get the handle property of the rule\\n        DivideRuleHandle ruleHandle = DividePluginDataHandler.CACHED_HANDLE.get().obtainHandle(CacheKeyUtils.INST.getKey(rule));\\n        long headerSize = 0;\\n        // check header size\\n        for (List<String> multiHeader : exchange.getRequest().getHeaders().values()) {\\n            for (String value : multiHeader) {\\n                headerSize += value.getBytes(StandardCharsets.UTF_8).length;\\n            }\\n        }\\n        if (headerSize > ruleHandle.getHeaderMaxSize()) {\\n            LOG.error(\\"request header is too large\\");\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.REQUEST_HEADER_TOO_LARGE, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        \\n        // check request size\\n        if (exchange.getRequest().getHeaders().getContentLength() > ruleHandle.getRequestMaxSize()) {\\n            LOG.error(\\"request entity is too large\\");\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.REQUEST_ENTITY_TOO_LARGE, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        // upstream list\\n        List<Upstream> upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());\\n        if (CollectionUtils.isEmpty(upstreamList)) {\\n            LOG.error(\\"divide upstream configuration error\uff1a {}\\", rule);\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.CANNOT_FIND_HEALTHY_UPSTREAM_URL, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        // request ip\\n        String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\\n        // load balance\\n        Upstream upstream = LoadBalancerFactory.selector(upstreamList, ruleHandle.getLoadBalance(), ip);\\n        if (Objects.isNull(upstream)) {\\n            LOG.error(\\"divide has no upstream\\");\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.CANNOT_FIND_HEALTHY_UPSTREAM_URL, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        // set url\\n        String domain = upstream.buildDomain();\\n        exchange.getAttributes().put(Constants.HTTP_DOMAIN, domain);\\n        // set timeout\\n        exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());\\n        exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry());\\n        // set retry \\n        exchange.getAttributes().put(Constants.RETRY_STRATEGY, ruleHandle.getRetryStrategy());\\n        exchange.getAttributes().put(Constants.LOAD_BALANCE, ruleHandle.getLoadBalance());\\n        exchange.getAttributes().put(Constants.DIVIDE_SELECTOR_ID, selector.getId());\\n        return chain.execute(exchange);\\n    }\\n```\\n\\n#### 2.4 Do Request\\n\\nBy default, the `WebClientPlugin` initiates a call request to the `http` service with the following class inheritance relationship.\\n\\n![](/img/activities/code-analysis-divide-plugin/WebClientPlugin.png)\\n\\n- ShenyuPlugin: top-level plug-in, defining plug-in methods.\\n- AbstractHttpClientPlugin: abstract class that implements the public logic of request invocation.\\n- WebClientPlugin: initiating requests through `WebClient`.\\n- NettyHttpClientPlugin: initiating requests through `Netty`.\\n\\nInitiate the request call.\\n\\n- org.apache.shenyu.plugin.httpclient.AbstractHttpClientPlugin#execute()\\n\\nInitiate the request call in the `execute()` method.\\n\\n- Get the specified timeout, number of retries\\n- Initiate the request\\n- Retry after failure according to the specified retry policy\\n\\n```java\\n\\npublic abstract class AbstractHttpClientPlugin<R> implements ShenyuPlugin {\\n\\n    protected static final Logger LOG = LoggerFactory.getLogger(AbstractHttpClientPlugin.class);\\n\\n    @Override\\n    public final Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        // shenyu Context\\n        final ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        assert shenyuContext != null;\\n        // uri\\n        final URI uri = exchange.getAttribute(Constants.HTTP_URI);\\n        if (Objects.isNull(uri)) {\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.CANNOT_FIND_URL, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        // get time out\\n        final long timeout = (long) Optional.ofNullable(exchange.getAttribute(Constants.HTTP_TIME_OUT)).orElse(3000L);\\n        final Duration duration = Duration.ofMillis(timeout);\\n        // get retry times\\n        final int retryTimes = (int) Optional.ofNullable(exchange.getAttribute(Constants.HTTP_RETRY)).orElse(0);\\n        // get retry strategy\\n        final String retryStrategy = (String) Optional.ofNullable(exchange.getAttribute(Constants.RETRY_STRATEGY)).orElseGet(RetryEnum.CURRENT::getName);\\n        LOG.info(\\"The request urlPath is {}, retryTimes is {}, retryStrategy is {}\\", uri.toASCIIString(), retryTimes, retryStrategy);\\n        // build header\\n        final HttpHeaders httpHeaders = buildHttpHeaders(exchange);\\n        // do request\\n        final Mono<R> response = doRequest(exchange, exchange.getRequest().getMethodValue(), uri, httpHeaders, exchange.getRequest().getBody())\\n                .timeout(duration, Mono.error(new TimeoutException(\\"Response took longer than timeout: \\" + duration)))\\n                .doOnError(e -> LOG.error(e.getMessage(), e));\\n        \\n        // Retry Policy CURRENT, retries the current service.\\n        if (RetryEnum.CURRENT.getName().equals(retryStrategy)) {\\n            //old version of DividePlugin and SpringCloudPlugin will run on this\\n            return response.retryWhen(Retry.anyOf(TimeoutException.class, ConnectTimeoutException.class, ReadTimeoutException.class, IllegalStateException.class)\\n                    .retryMax(retryTimes)\\n                    .backoff(Backoff.exponential(Duration.ofMillis(200), Duration.ofSeconds(20), 2, true)))\\n                    .onErrorMap(TimeoutException.class, th -> new ResponseStatusException(HttpStatus.GATEWAY_TIMEOUT, th.getMessage(), th))\\n                    .flatMap((Function<Object, Mono<? extends Void>>) o -> chain.execute(exchange));\\n        }\\n        \\n        // Retry for other services\\n        // Exclude services that have already been called\\n        final Set<URI> exclude = Sets.newHashSet(uri);\\n        // resend\\n        return resend(response, exchange, duration, httpHeaders, exclude, retryTimes)\\n                .onErrorMap(TimeoutException.class, th -> new ResponseStatusException(HttpStatus.GATEWAY_TIMEOUT, th.getMessage(), th))\\n                .flatMap((Function<Object, Mono<? extends Void>>) o -> chain.execute(exchange));\\n    }\\n\\n    private Mono<R> resend(final Mono<R> clientResponse,\\n                           final ServerWebExchange exchange,\\n                           final Duration duration,\\n                           final HttpHeaders httpHeaders,\\n                           final Set<URI> exclude,\\n                           final int retryTimes) {\\n        Mono<R> result = clientResponse;\\n        // Retry according to the specified number of retries\\n        for (int i = 0; i < retryTimes; i++) {\\n            result = resend(result, exchange, duration, httpHeaders, exclude);\\n        }\\n        return result;\\n    }\\n\\n    private Mono<R> resend(final Mono<R> response,\\n                           final ServerWebExchange exchange,\\n                           final Duration duration,\\n                           final HttpHeaders httpHeaders,\\n                           final Set<URI> exclude) {\\n        return response.onErrorResume(th -> {\\n            final String selectorId = exchange.getAttribute(Constants.DIVIDE_SELECTOR_ID);\\n            final String loadBalance = exchange.getAttribute(Constants.LOAD_BALANCE);\\n            //Check available services\\n            final List<Upstream> upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selectorId)\\n                    .stream().filter(data -> {\\n                        final String trimUri = data.getUrl().trim();\\n                        for (URI needToExclude : exclude) {\\n                            // exclude already called\\n                            if ((needToExclude.getHost() + \\":\\" + needToExclude.getPort()).equals(trimUri)) {\\n                                return false;\\n                            }\\n                        }\\n                        return true;\\n                    }).collect(Collectors.toList());\\n            if (CollectionUtils.isEmpty(upstreamList)) {\\n                // no need to retry anymore\\n                return Mono.error(new ShenyuException(ShenyuResultEnum.CANNOT_FIND_HEALTHY_UPSTREAM_URL_AFTER_FAILOVER.getMsg()));\\n            }\\n            // requets ip\\n            final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\\n            // Load Balance\\n            final Upstream upstream = LoadBalancerFactory.selector(upstreamList, loadBalance, ip);\\n            if (Objects.isNull(upstream)) {\\n                // no need to retry anymore\\n                return Mono.error(new ShenyuException(ShenyuResultEnum.CANNOT_FIND_HEALTHY_UPSTREAM_URL_AFTER_FAILOVER.getMsg()));\\n            }\\n            final URI newUri = RequestUrlUtils.buildRequestUri(exchange, upstream.buildDomain());\\n            // Exclude uri that has already been called\\n            exclude.add(newUri);\\n             // Make another call\\n            return doRequest(exchange, exchange.getRequest().getMethodValue(), newUri, httpHeaders, exchange.getRequest().getBody())\\n                    .timeout(duration, Mono.error(new TimeoutException(\\"Response took longer than timeout: \\" + duration)))\\n                    .doOnError(e -> LOG.error(e.getMessage(), e));\\n        });\\n    }\\n\\n    //......\\n}\\n\\n```\\n\\n- org.apache.shenyu.plugin.httpclient.WebClientPlugin#doRequest()\\n\\nInitiate a real request call via `webClient` in the `doRequest()` method.\\n\\n```java\\n\\n@Override\\n    protected Mono<ClientResponse> doRequest(final ServerWebExchange exchange, final String httpMethod, final URI uri,\\n                                             final HttpHeaders httpHeaders, final Flux<DataBuffer> body) {\\n        return webClient.method(HttpMethod.valueOf(httpMethod)).uri(uri) // uri\\n                .headers(headers -> headers.addAll(httpHeaders)) // header\\n                .body(BodyInserters.fromDataBuffers(body))\\n                .exchange() // request\\n                .doOnSuccess(res -> {\\n                    if (res.statusCode().is2xxSuccessful()) { // success\\n                        exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.SUCCESS.getName());\\n                    } else { // error\\n                        exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.ERROR.getName());\\n                    }\\n                    exchange.getResponse().setStatusCode(res.statusCode());\\n                    exchange.getAttributes().put(Constants.CLIENT_RESPONSE_ATTR, res);\\n                });\\n    }\\n```\\n\\n#### 2.5 Response Result\\n\\n- org.apache.shenyu.plugin.response.ResponsePlugin#execute()\\n\\nThe response results are handled by the `ResponsePlugin` plugin.\\n\\n```java\\n    @Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        assert shenyuContext != null;\\n        // Processing results according to rpc type\\n        return writerMap.get(shenyuContext.getRpcType()).writeWith(exchange, chain);\\n    }\\n```\\n\\nThe processing type is determined by `MessageWriter` and the class inheritance relationship is as follows.\\n\\n![](/img/activities/code-analysis-divide-plugin/MessageWriter.png)\\n\\n- MessageWriter: interface, defining message processing methods.\\n- NettyClientMessageWriter: processing of `Netty` call results.\\n- RPCMessageWriter: processing the results of `RPC` calls.\\n- WebClientMessageWriter: processing `WebClient` call results.\\n\\nThe default is to initiate `http` requests via `WebCient`.\\n\\n- org.apache.shenyu.plugin.response.strategy.WebClientMessageWriter#writeWith()\\n\\nProcess the response results in the `writeWith()` method.\\n\\n```java\\n\\n    @Override\\n    public Mono<Void> writeWith(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        return chain.execute(exchange).then(Mono.defer(() -> {\\n            // get response\\n            ServerHttpResponse response = exchange.getResponse();\\n            ClientResponse clientResponse = exchange.getAttribute(Constants.CLIENT_RESPONSE_ATTR);\\n            if (Objects.isNull(clientResponse)) {\\n                Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.SERVICE_RESULT_ERROR, null);\\n                return WebFluxResultUtils.result(exchange, error);\\n            }\\n            //cookies and headers\\n            response.getCookies().putAll(clientResponse.cookies());\\n            response.getHeaders().putAll(clientResponse.headers().asHttpHeaders());\\n            // image, pdf or stream does not do format processing.\\n            // Handling special response types\\n            if (clientResponse.headers().contentType().isPresent()) {\\n                final String media = clientResponse.headers().contentType().get().toString().toLowerCase();\\n                if (media.matches(COMMON_BIN_MEDIA_TYPE_REGEX)) {\\n                    return response.writeWith(clientResponse.body(BodyExtractors.toDataBuffers()))\\n                            .doOnCancel(() -> clean(exchange));\\n                }\\n            }\\n            // Handling general response types\\n            clientResponse = ResponseUtils.buildClientResponse(response, clientResponse.body(BodyExtractors.toDataBuffers()));\\n            return clientResponse.bodyToMono(byte[].class)\\n                    .flatMap(originData -> WebFluxResultUtils.result(exchange, originData))\\n                    .doOnCancel(() -> clean(exchange));\\n        }));\\n    }\\n```\\n\\nAnalysis to this point, the source code analysis on `Divide` plugin is complete, the analysis flow chart is as follows.\\n\\n![](/img/activities/code-analysis-divide-plugin/divide-execute-zh.png)\\n\\n\\n### 3. Summary\\n\\nThe source code analysis in this article starts from the `http` service registration to the `divide` plugin service calls. The `divide` plugin is mainly used to handle `http` requests. Some of the source code does not enter the in-depth analysis, such as the implementation of load balancing, service probe live, will continue to analyze in the following."},{"id":"/Plugin-SourceCode-Analysis-Dubbo-Plugin","metadata":{"permalink":"/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin.md","source":"@site/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin.md","title":"Code Analysis For Dubbo Plugin","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"plugin","permalink":"/blog/tags/plugin"},{"label":"dubbo","permalink":"/blog/tags/dubbo"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":21.51,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"Code Analysis For Dubbo Plugin","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["plugin","dubbo","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Code Analysis For Divide Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Divide-Plugin"},"nextItem":{"title":"McpServer Plugin Source Code Analysis","permalink":"/blog/Plugin-SourceCode-Analysis-Mcp-Server-Plugin"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive `API` gateway.\\n\\n\\nThe `Apache ShenYu` gateway uses the `dubbo` plugin to make calls to the `dubbo` service. You can see the official documentation [Dubbo Quick Start](https://shenyu.apache.org/docs/quick-start/quick-start-dubbo) to learn how to use the plugin.\\n\\n> This article is based on `shenyu-2.4.3` version for source code analysis, please refer to [Dubbo Service Access](https://shenyu.apache.org/zh/docs/user-guide/proxy/dubbo-proxy/) for the introduction of the official website.\\n\\n\\n### 1. Service Registration\\n\\nTake the example provided on the official website [shenyu-examples-dubbo](https://github.com/apache/shenyu/tree/master/shenyu-examples/shenyu-examples-dubbo/shenyu-examples-apache-dubbo-service). Suppose your `dubbo` service is defined as follows (`spring-dubbo.xml`).\\n\\n```xml\\n<beans xmlns=\\"http://www.springframework.org/schema/beans\\"\\n       xmlns:xsi=\\"http://www.w3.org/2001/XMLSchema-instance\\"\\n       xmlns:dubbo=\\"http://code.alibabatech.com/schema/dubbo\\"\\n       xsi:schemaLocation=\\"http://www.springframework.org/schema/beans\\n       http://www.springframework.org/schema/beans/spring-beans.xsd\\n       http://code.alibabatech.com/schema/dubbo\\n       https://code.alibabatech.com/schema/dubbo/dubbo.xsd\\">\\n\\n    <dubbo:application name=\\"test-dubbo-service\\"/>\\n    <dubbo:registry address=\\"${dubbo.registry.address}\\"/>\\n    <dubbo:protocol name=\\"dubbo\\" port=\\"20888\\"/>\\n\\n    <dubbo:service timeout=\\"10000\\" interface=\\"org.apache.shenyu.examples.dubbo.api.service.DubboTestService\\" ref=\\"dubboTestService\\"/>\\n\\n</beans>\\n```\\n\\nDeclare the application service name, register the center address, use the `dubbo` protocol, declare the service interface, and the corresponding interface implementation class.\\n\\n```java\\n/**\\n * DubboTestServiceImpl.\\n */\\n@Service(\\"dubboTestService\\")\\npublic class DubboTestServiceImpl implements DubboTestService {\\n    \\n    @Override\\n    @ShenyuDubboClient(path = \\"/findById\\", desc = \\"Query by Id\\")\\n    public DubboTest findById(final String id) {\\n        return new DubboTest(id, \\"hello world shenyu Apache, findById\\");\\n    }\\n\\n    //......\\n}\\n```\\n\\nIn the interface implementation class, use the annotation `@ShenyuDubboClient` to register the service with `shenyu-admin`. The role of this annotation and its rationale will be analyzed later.\\n\\nThe configuration information in the configuration file `application.yml`.\\n\\n```yaml\\nserver:\\n  port: 8011\\n  address: 0.0.0.0\\n  servlet:\\n    context-path: /\\nspring:\\n  main:\\n    allow-bean-definition-overriding: true\\ndubbo:\\n  registry:\\n    address: zookeeper://localhost:2181  # dubbo registry\\n    \\nshenyu:\\n  register:\\n    registerType: http \\n    serverLists: http://localhost:9095 \\n    props:\\n      username: admin \\n      password: 123456\\n  client:\\n    dubbo:\\n      props:\\n        contextPath: /dubbo  \\n        appName: dubbo\\n\\n```\\n\\n\\nIn the configuration file, declare the registry address used by `dubbo`. The `dubbo` service registers with `shenyu-admin`, using the method `http`, and the registration address is `http://localhost:9095`.\\n\\nSee [Application Client Access](https://shenyu.apache.org/docs/design/register-center-design/) for more information on the use of the registration method.\\n\\n\\n#### 1.1  Declaration of registration interface\\n\\nUse the annotation `@ShenyuDubboClient` to register the service to the gateway. The simple `demo` is as follows.\\n\\n```java\\n// dubbo sevice\\n@Service(\\"dubboTestService\\")\\npublic class DubboTestServiceImpl implements DubboTestService {\\n    \\n    @Override\\n    @ShenyuDubboClient(path = \\"/findById\\", desc = \\"Query by Id\\") // need to be registered method\\n    public DubboTest findById(final String id) {\\n        return new DubboTest(id, \\"hello world shenyu Apache, findById\\");\\n    }\\n\\n    //......\\n}\\n```\\n\\nannotation definition:\\n\\n```java\\n/**\\n * Works on classes and methods\\n */\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target({ElementType.TYPE, ElementType.METHOD})\\n@Inherited\\npublic @interface ShenyuDubboClient {\\n    \\n\\t//path\\n    String path();\\n    \\n    //rule name\\n    String ruleName() default \\"\\";\\n   \\n    //desc\\n    String desc() default \\"\\";\\n\\n    //enabled\\n    boolean enabled() default true;\\n}\\n\\n```\\n\\n#### 1.2 Scan annotation information\\n\\nAnnotation scanning is done through the `ApacheDubboServiceBeanListener`, which implements the `ApplicationListener<ContextRefreshedEvent>` interface and starts executing the event handler method when a context refresh event occurs during the `Spring` container startup `onApplicationEvent()`.\\n\\nDuring constructor instantiation.\\n\\n- Read property configuration\\n- Start the thread pool\\n- Start the registry for registering with `shenyu-admin`\\n\\n```java\\npublic class ApacheDubboServiceBeanListener implements ApplicationListener<ContextRefreshedEvent> {\\n\\n\\t// ......\\n\\n    //Constructor\\n    public ApacheDubboServiceBeanListener(final PropertiesConfig clientConfig, final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        //1.Read property configuration\\n        Properties props = clientConfig.getProps();\\n        String contextPath = props.getProperty(ShenyuClientConstants.CONTEXT_PATH);\\n        String appName = props.getProperty(ShenyuClientConstants.APP_NAME);\\n        if (StringUtils.isBlank(contextPath)) {\\n            throw new ShenyuClientIllegalArgumentException(\\"apache dubbo client must config the contextPath or appName\\");\\n        }\\n        this.contextPath = contextPath;\\n        this.appName = appName;\\n        this.host = props.getProperty(ShenyuClientConstants.HOST);\\n        this.port = props.getProperty(ShenyuClientConstants.PORT);\\n        //2.Start the thread pool\\n        executorService = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder().setNameFormat(\\"shenyu-apache-dubbo-client-thread-pool-%d\\").build());\\n        //3.Start the registry for registering with `shenyu-admin`\\n        publisher.start(shenyuClientRegisterRepository);\\n    }\\n\\n    /**\\n     * Context refresh event, execute method logic\\n     */\\n    @Override\\n    public void onApplicationEvent(final ContextRefreshedEvent contextRefreshedEvent) {\\n        //......\\n    }\\n```\\n\\n- ApacheDubboServiceBeanListener#onApplicationEvent()\\n\\nRewritten method logic: read `Dubbo` service `ServiceBean`, build metadata object and `URI` object, and register it with `shenyu-admin`.\\n\\n```java\\n    @Override\\n    public void onApplicationEvent(final ContextRefreshedEvent contextRefreshedEvent) {\\n        //read ServiceBean\\n        Map<String, ServiceBean> serviceBean = contextRefreshedEvent.getApplicationContext().getBeansOfType(ServiceBean.class);\\n        if (serviceBean.isEmpty()) {\\n            return;\\n        }\\n        //The method is guaranteed to be executed only once\\n        if (!registered.compareAndSet(false, true)) {\\n            return;\\n        }\\n        //handle metadata \\n        for (Map.Entry<String, ServiceBean> entry : serviceBean.entrySet()) {\\n            handler(entry.getValue());\\n        }\\n        //handle URI\\n        serviceBean.values().stream().findFirst().ifPresent(bean -> {\\n            publisher.publishEvent(buildURIRegisterDTO(bean));\\n        });\\n    }\\n```\\n\\n- handler()\\n\\n  In the `handler()` method, read all methods from the `serviceBean`, determine if there is a `ShenyuDubboClient` annotation on the method, build a metadata object if it exists, and register the method with `shenyu-admin` through the registry.\\n\\n```java\\n    private void handler(final ServiceBean<?> serviceBean) {\\n        //get proxy\\n        Object refProxy = serviceBean.getRef();\\n        //get class\\n        Class<?> clazz = refProxy.getClass();\\n        if (AopUtils.isAopProxy(refProxy)) {\\n            clazz = AopUtils.getTargetClass(refProxy);\\n        }\\n        //all methods\\n        Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(clazz);\\n        for (Method method : methods) {\\n            //read ShenyuDubboClient annotation\\n            ShenyuDubboClient shenyuDubboClient = method.getAnnotation(ShenyuDubboClient.class);\\n            if (Objects.nonNull(shenyuDubboClient)) {\\n                //build meatdata and registry\\n                publisher.publishEvent(buildMetaDataDTO(serviceBean, shenyuDubboClient, method));\\n            }\\n        }\\n    }\\n```\\n\\n- buildMetaDataDTO()\\n\\n  Constructs a metadata object where the necessary information for method registration is constructed and subsequently used for selector or rule matching.\\n\\n```java\\n    private MetaDataRegisterDTO buildMetaDataDTO(final ServiceBean<?> serviceBean, final ShenyuDubboClient shenyuDubboClient, final Method method) {\\n        //app name\\n        String appName = buildAppName(serviceBean);\\n        //path\\n        String path = contextPath + shenyuDubboClient.path();\\n        //desc\\n        String desc = shenyuDubboClient.desc();\\n        //service name\\n        String serviceName = serviceBean.getInterface();\\n        //rule name\\n        String configRuleName = shenyuDubboClient.ruleName();\\n        String ruleName = (\\"\\".equals(configRuleName)) ? path : configRuleName;\\n        //method name \\n        String methodName = method.getName();\\n        //parameter Types\\n        Class<?>[] parameterTypesClazz = method.getParameterTypes();\\n        String parameterTypes = Arrays.stream(parameterTypesClazz).map(Class::getName).collect(Collectors.joining(\\",\\"));\\n        return MetaDataRegisterDTO.builder()\\n                .appName(appName)\\n                .serviceName(serviceName)\\n                .methodName(methodName)\\n                .contextPath(contextPath)\\n                .host(buildHost())\\n                .port(buildPort(serviceBean))\\n                .path(path)\\n                .ruleName(ruleName)\\n                .pathDesc(desc)\\n                .parameterTypes(parameterTypes)\\n                .rpcExt(buildRpcExt(serviceBean)) //dubbo ext\\n                .rpcType(RpcTypeEnum.DUBBO.getName())\\n                .enabled(shenyuDubboClient.enabled())\\n                .build();\\n    }\\n```\\n\\n- buildRpcExt()\\n\\n  `dubbo` ext information.\\n\\n ```java\\n    private String buildRpcExt(final ServiceBean serviceBean) {\\n        DubboRpcExt build = DubboRpcExt.builder()\\n                .group(StringUtils.isNotEmpty(serviceBean.getGroup()) ? serviceBean.getGroup() : \\"\\")//group\\n                .version(StringUtils.isNotEmpty(serviceBean.getVersion()) ? serviceBean.getVersion() : \\"\\")//version\\n                .loadbalance(StringUtils.isNotEmpty(serviceBean.getLoadbalance()) ? serviceBean.getLoadbalance() : Constants.DEFAULT_LOADBALANCE)//load balance\\n                .retries(Objects.isNull(serviceBean.getRetries()) ? Constants.DEFAULT_RETRIES : serviceBean.getRetries())//retry\\n                .timeout(Objects.isNull(serviceBean.getTimeout()) ? Constants.DEFAULT_CONNECT_TIMEOUT : serviceBean.getTimeout())//time\\n                .sent(Objects.isNull(serviceBean.getSent()) ? Constants.DEFAULT_SENT : serviceBean.getSent())//sent\\n                .cluster(StringUtils.isNotEmpty(serviceBean.getCluster()) ? serviceBean.getCluster() : Constants.DEFAULT_CLUSTER)//cluster\\n                .url(\\"\\")\\n                .build();\\n        return GsonUtils.getInstance().toJson(build);\\n    }\\n ```\\n\\n\\n- buildURIRegisterDTO()\\n\\n  Construct `URI` objects to register information about the service itself, which can be subsequently used for service probing live.\\n\\n\\n```java\\nprivate URIRegisterDTO buildURIRegisterDTO(final ServiceBean serviceBean) {\\n        return URIRegisterDTO.builder()\\n                .contextPath(this.contextPath) //context path\\n                .appName(buildAppName(serviceBean))//app name\\n                .rpcType(RpcTypeEnum.DUBBO.getName())//dubbo\\n                .host(buildHost()) //host\\n                .port(buildPort(serviceBean))//port\\n                .build();\\n }\\n```\\n\\nThe specific registration logic is implemented by the registration center, please refer to [Client Access Principles](https://shenyu.apache.org/zh/docs/design/register-center-design/) .\\n\\n```java\\n//To the registration center, post registration events   \\npublisher.publishEvent();\\n```\\n\\n#### 1.3 Processing registration information\\n\\nThe metadata and `URI` data registered by the client through the registry are processed at the `shenyu-admin` end, which is responsible for storing to the database and synchronizing to the `shenyu` gateway. The client-side registration processing logic of the `Dubbo` plugin is in the `ShenyuClientRegisterDubboServiceImpl`. The inheritance relationship is as follows.\\n\\n![](/img/activities/code-analysis-dubbo-plugin/ShenyuClientRegisterDubboServiceImpl.png)\\n\\n\\n- ShenyuClientRegisterService: client registration service, top-level interface.\\n- FallbackShenyuClientRegisterService: registration failure, provides retry operation.\\n- AbstractShenyuClientRegisterServiceImpl: abstract class, implements part of the public registration logic.\\n- ShenyuClientRegisterDubboServiceImpl: implementation of the `Dubbo` plugin registration.\\n\\n##### 1.3.1 Registration Service\\n\\n- org.apache.shenyu.admin.service.register.AbstractShenyuClientRegisterServiceImpl#register()\\n\\n  The metadata `MetaDataRegisterDTO` object registered by the client through the registry is picked up and dropped in the `register()` method of `shenyu-admin`.\\n\\n```java\\n   @Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        String selectorHandler = selectorHandler(dto);\\n        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);\\n        //2. register rule\\n        String ruleHandler = ruleHandler();\\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\\n        ruleService.registerDefault(ruleDTO);\\n        //3. register metadata\\n        registerMetadata(dto);\\n        //4. register contextPath\\n        String contextPath = dto.getContextPath();\\n        if (StringUtils.isNotEmpty(contextPath)) {\\n            registerContextPath(dto);\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n###### 1.3.1.1 Register Selector\\n\\n- org.apache.shenyu.admin.service.impl.SelectorServiceImpl#registerDefault()\\n\\nConstruct `contextPath`, find if the selector information exists, if it does, return `id`; if it doesn\'t, create the default selector information.\\n\\n```java\\n    @Override\\n    public String registerDefault(final MetaDataRegisterDTO dto, final String pluginName, final String selectorHandler) {\\n        // build contextPath\\n        String contextPath = ContextPathUtils.buildContextPath(dto.getContextPath(), dto.getAppName());\\n        // Find if selector information exists by name\\n        SelectorDO selectorDO = findByNameAndPluginName(contextPath, pluginName);\\n        if (Objects.isNull(selectorDO)) {\\n            // Create a default selector message if it does not exist\\n            return registerSelector(contextPath, pluginName, selectorHandler);\\n        }\\n        return selectorDO.getId();\\n    }\\n```\\n\\n- Default selector information\\n\\n  Construct the default selector information and its conditional properties here.\\n\\n```java\\n   //register selector\\n   private String registerSelector(final String contextPath, final String pluginName, final String selectorHandler) {\\n        //build selector\\n        SelectorDTO selectorDTO = buildSelectorDTO(contextPath, pluginMapper.selectByName(pluginName).getId());\\n        selectorDTO.setHandle(selectorHandler);\\n        //register default selector\\n        return registerDefault(selectorDTO);\\n    }\\n     //build selector\\n    private SelectorDTO buildSelectorDTO(final String contextPath, final String pluginId) {\\n        //build default\\n        SelectorDTO selectorDTO = buildDefaultSelectorDTO(contextPath);\\n        selectorDTO.setPluginId(pluginId);\\n         //build the conditional properties of the default selector\\n        selectorDTO.setSelectorConditions(buildDefaultSelectorConditionDTO(contextPath));\\n        return selectorDTO;\\n    }\\n```\\n\\n- Build default selector\\n\\n```java\\nprivate SelectorDTO buildDefaultSelectorDTO(final String name) {\\n    return SelectorDTO.builder()\\n            .name(name) // name\\n            .type(SelectorTypeEnum.CUSTOM_FLOW.getCode()) // default type cutom\\n            .matchMode(MatchModeEnum.AND.getCode()) //default match mode\\n            .enabled(Boolean.TRUE)  //enable\\n            .loged(Boolean.TRUE)  //log\\n            .continued(Boolean.TRUE) \\n            .sort(1) \\n            .build();\\n}\\n```\\n\\n- Build default selector conditional properties\\n\\n```java\\nprivate List<SelectorConditionDTO> buildDefaultSelectorConditionDTO(final String contextPath) {\\n    SelectorConditionDTO selectorConditionDTO = new SelectorConditionDTO();\\n    selectorConditionDTO.setParamType(ParamTypeEnum.URI.getName()); // default URI\\n    selectorConditionDTO.setParamName(\\"/\\");\\n    selectorConditionDTO.setOperator(OperatorEnum.MATCH.getAlias()); // default  match\\n    selectorConditionDTO.setParamValue(contextPath + AdminConstants.URI_SUFFIX); \\n    return Collections.singletonList(selectorConditionDTO);\\n}\\n```\\n\\n- Register default selector\\n\\n```java\\n@Override\\npublic String registerDefault(final SelectorDTO selectorDTO) {\\n    //selector information\\n    SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);\\n    //selector conditional properties\\n    List<SelectorConditionDTO> selectorConditionDTOs = selectorDTO.getSelectorConditions();\\n    if (StringUtils.isEmpty(selectorDTO.getId())) {\\n        // insert selector information into the database\\n        selectorMapper.insertSelective(selectorDO);\\n          // inserting selector conditional properties to the database\\n        selectorConditionDTOs.forEach(selectorConditionDTO -> {\\n            selectorConditionDTO.setSelectorId(selectorDO.getId());            \\n            selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));\\n        });\\n    }\\n    // Publish synchronization events to synchronize selection information and its conditional attributes to the gateway\\n    publishEvent(selectorDO, selectorConditionDTOs);\\n    return selectorDO.getId();\\n}\\n```\\n\\n###### 1.3.1.2 Registration Rules\\n\\nIn the second step of registering the service, start building the default rules and then register the rules.\\n\\n```java\\n@Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. handle selector\\n        //......\\n        \\n        //2. handle rule\\n        \\n        String ruleHandler = ruleHandler();\\n        // build default rule\\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\\n        // register rule\\n        ruleService.registerDefault(ruleDTO);\\n        \\n        //3. reigster metadata\\n        //......\\n        \\n        //4. register ContextPath\\n        //......\\n        \\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n- \u9ed8\u8ba4\u89c4\u5219\u5904\u7406\u5c5e\u6027\\n\\n```java\\n    @Override\\n    protected String ruleHandler() {\\n        // default rule\\n        return new DubboRuleHandle().toJson();\\n    }\\n```\\n\\n`Dubbo` plugin default rule handling properties.\\n\\n```java\\npublic class DubboRuleHandle implements RuleHandle {\\n\\n    /**\\n     * dubbo version.\\n     */\\n    private String version;\\n\\n    /**\\n     * group.\\n     */\\n    private String group;\\n\\n    /**\\n     * retry.\\n     */\\n    private Integer retries = 0;\\n\\n    /**\\n     * loadbalance:RANDOM\\n     */\\n    private String loadbalance = LoadBalanceEnum.RANDOM.getName();\\n\\n    /**\\n     * timeout default 3000\\n     */\\n    private long timeout = Constants.TIME_OUT;\\n}\\n```\\n\\n- build default rule\\n\\n```java\\n  // build default rule\\n    private RuleDTO buildRpcDefaultRuleDTO(final String selectorId, final MetaDataRegisterDTO metaDataDTO, final String ruleHandler) {\\n        return buildRuleDTO(selectorId, ruleHandler, metaDataDTO.getRuleName(), metaDataDTO.getPath());\\n    }\\n   //  build default rule\\n    private RuleDTO buildRuleDTO(final String selectorId, final String ruleHandler, final String ruleName, final String path) {\\n        RuleDTO ruleDTO = RuleDTO.builder()\\n                .selectorId(selectorId)\\n                .name(ruleName) \\n                .matchMode(MatchModeEnum.AND.getCode()) \\n                .enabled(Boolean.TRUE) \\n                .loged(Boolean.TRUE) \\n                .sort(1)\\n                .handle(ruleHandler)\\n                .build();\\n        RuleConditionDTO ruleConditionDTO = RuleConditionDTO.builder()\\n                .paramType(ParamTypeEnum.URI.getName()) \\n                .paramName(\\"/\\")\\n                .paramValue(path) \\n                .build();\\n        if (path.indexOf(\\"*\\") > 1) {\\n            ruleConditionDTO.setOperator(OperatorEnum.MATCH.getAlias()); \\n        } else {\\n            ruleConditionDTO.setOperator(OperatorEnum.EQ.getAlias()); \\n        }\\n        ruleDTO.setRuleConditions(Collections.singletonList(ruleConditionDTO));\\n        return ruleDTO;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.impl.RuleServiceImpl#registerDefault()\\n\\nRegistration rules: insert records to the database and publish events to the gateway for data synchronization.\\n\\n\\n```java\\n\\n    @Override\\n    public String registerDefault(final RuleDTO ruleDTO) {\\n        RuleDO exist = ruleMapper.findBySelectorIdAndName(ruleDTO.getSelectorId(), ruleDTO.getName());\\n        if (Objects.nonNull(exist)) {\\n            return \\"\\";\\n        }\\n\\n        RuleDO ruleDO = RuleDO.buildRuleDO(ruleDTO);\\n        List<RuleConditionDTO> ruleConditions = ruleDTO.getRuleConditions();\\n        if (StringUtils.isEmpty(ruleDTO.getId())) {\\n            // insert rule information into the database\\n            ruleMapper.insertSelective(ruleDO);\\n            //insert  rule body conditional attributes into the database\\n            ruleConditions.forEach(ruleConditionDTO -> {\\n                ruleConditionDTO.setRuleId(ruleDO.getId());     \\n                ruleConditionMapper.insertSelective(RuleConditionDO.buildRuleConditionDO(ruleConditionDTO));\\n            });\\n        }\\n        // Publish events to the gateway for data synchronization\\n        publishEvent(ruleDO, ruleConditions);\\n        return ruleDO.getId();\\n    }\\n\\n```\\n\\n\\n###### 1.3.1.3 Register Metadata\\n\\nMetadata is mainly used for `RPC` service calls.\\n\\n```java\\n   @Override\\n    public String register(final MetaDataRegisterDTO dto) {\\n        //1. register selector\\n        //......\\n        \\n        //2. register rule\\n        //......\\n        \\n        //3. register metadata\\n        registerMetadata(dto);\\n        \\n        //4. register ContextPath\\n        //......\\n        \\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.register.ShenyuClientRegisterDubboServiceImpl#registerMetadata()\\n\\n  Insert or update metadata and then publish sync events to the gateway.\\n\\n```java\\n    @Override\\n    protected void registerMetadata(final MetaDataRegisterDTO dto) {\\n            // get metaDataService\\n            MetaDataService metaDataService = getMetaDataService();\\n            MetaDataDO exist = metaDataService.findByPath(dto.getPath());\\n            //insert or update metadata\\n            metaDataService.saveOrUpdateMetaData(exist, dto);\\n    }\\n\\n    @Override\\n    public void saveOrUpdateMetaData(final MetaDataDO exist, final MetaDataRegisterDTO metaDataDTO) {\\n        DataEventTypeEnum eventType;\\n        // DTO->DO\\n        MetaDataDO metaDataDO = MetaDataTransfer.INSTANCE.mapRegisterDTOToEntity(metaDataDTO);\\n        // insert data\\n        if (Objects.isNull(exist)) {\\n            Timestamp currentTime = new Timestamp(System.currentTimeMillis());\\n            metaDataDO.setId(UUIDUtils.getInstance().generateShortUuid());\\n            metaDataDO.setDateCreated(currentTime);\\n            metaDataDO.setDateUpdated(currentTime);\\n            metaDataMapper.insert(metaDataDO);\\n            eventType = DataEventTypeEnum.CREATE;\\n        } else {\\n            // update\\n            metaDataDO.setId(exist.getId());\\n            metaDataMapper.update(metaDataDO);\\n            eventType = DataEventTypeEnum.UPDATE;\\n        }\\n        // Publish sync events to gateway\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.META_DATA, eventType,\\n                Collections.singletonList(MetaDataTransfer.INSTANCE.mapToData(metaDataDO))));\\n    }\\n```\\n\\n##### 1.3.2 Register URI\\n\\n- org.apache.shenyu.admin.service.register.FallbackShenyuClientRegisterService#registerURI()\\n\\nThe server side receives the `URI` information registered by the client and processes it.\\n\\n```java\\n    @Override\\n    public String registerURI(final String selectorName, final List<URIRegisterDTO> uriList) {\\n        String result;\\n        String key = key(selectorName);\\n        try {\\n            this.removeFallBack(key);\\n            // register URI\\n            result = this.doRegisterURI(selectorName, uriList);\\n            logger.info(\\"Register success: {},{}\\", selectorName, uriList);\\n        } catch (Exception ex) {\\n            logger.warn(\\"Register exception: cause:{}\\", ex.getMessage());\\n            result = \\"\\";\\n            // Retry after registration failure\\n            this.addFallback(key, new FallbackHolder(selectorName, uriList));\\n        }\\n        return result;\\n    }\\n```\\n\\n- org.apache.shenyu.admin.service.register.AbstractShenyuClientRegisterServiceImpl#doRegisterURI()\\n\\nGet a valid `URI` from the `URI` registered by the client, update the corresponding selector `handle` property, and send a selector update event to the gateway.\\n\\n```java\\n@Override\\n    public String doRegisterURI(final String selectorName, final List<URIRegisterDTO> uriList) {\\n        //check\\n        if (CollectionUtils.isEmpty(uriList)) {\\n            return \\"\\";\\n        }\\n        \\n        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n        if (Objects.isNull(selectorDO)) {\\n            throw new ShenyuException(\\"doRegister Failed to execute,wait to retry.\\");\\n        }\\n        // gte valid URI\\n        List<URIRegisterDTO> validUriList = uriList.stream().filter(dto -> Objects.nonNull(dto.getPort()) && StringUtils.isNotBlank(dto.getHost())).collect(Collectors.toList());\\n        // build handle\\n        String handler = buildHandle(validUriList, selectorDO);\\n        if (handler != null) {\\n            selectorDO.setHandle(handler);\\n            SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n            selectorData.setHandle(handler);\\n            // Update the handle property of the selector to the database\\n            selectorService.updateSelective(selectorDO);\\n            // Send selector update events to the gateway\\n            eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n```\\n\\nThe source code analysis on service registration is completed as well as the analysis flow chart is as follows.\\n\\n![](/img/activities/code-analysis-dubbo-plugin/dubbo-register-en.png)\\n\\n\\nThe next step is to analyze how the `dubbo` plugin initiates calls to the `http` service based on this information.\\n\\n### 2. Service Invocation\\n\\nThe `dubbo` plugin is the core processing plugin used by the `ShenYu` gateway to convert `http` requests into the `dubbo protocol` and invoke the `dubbo` service.\\n\\nTake the case provided by the official website [Quick Start with Dubbo](https://shenyu.apache.org/docs/quick-start/quick-start-dubbo/) as an example, a `dubbo` service is registered with `shenyu-admin` through the registry, and then requested through the `ShenYu` gateway proxy, the request is as follows.\\n\\n\\n```\\nGET http://localhost:9195/dubbo/findById?id=100\\nAccept: application/json\\n```\\n\\nThe class inheritance relationship in the `Dubbo` plugin is as follows.\\n\\n![](/img/activities/code-analysis-dubbo-plugin/ApacheDubboPlugin.png)\\n\\n- ShenyuPlugin: top-level interface, defining interface methods.\\n- AbstractShenyuPlugin: abstract class that implements plugin common logic.\\n- AbstractDubboPlugin: dubbo plugin abstract class, implementing `dubbo` common logic.\\n- ApacheDubboPlugin: ApacheDubbo plugin.\\n\\n> ShenYu Gateway supports ApacheDubbo and AlibabaDubbo\\\\\\n\\n#### 2.1 Receive requests\\n\\nAfter passing the `ShenYu` gateway proxy, the request entry is `ShenyuWebHandler`, which implements the `org.springframework.web.server.WebHandler` interface.\\n\\n```java\\npublic final class ShenyuWebHandler implements WebHandler, ApplicationListener<SortPluginEvent> {\\n    //......\\n    \\n    /**\\n     * hanlde request\\n     */\\n    @Override\\n    public Mono<Void> handle(@NonNull final ServerWebExchange exchange) {\\n       // execute default plugin chain\\n        Mono<Void> execute = new DefaultShenyuPluginChain(plugins).execute(exchange);\\n        if (scheduled) {\\n            return execute.subscribeOn(scheduler);\\n        }\\n        return execute;\\n    }\\n    \\n    private static class DefaultShenyuPluginChain implements ShenyuPluginChain {\\n\\n        private int index;\\n\\n        private final List<ShenyuPlugin> plugins;\\n\\n  \\n        DefaultShenyuPluginChain(final List<ShenyuPlugin> plugins) {\\n            this.plugins = plugins;\\n        }\\n\\n        /**\\n         * execute.\\n         */\\n        @Override\\n        public Mono<Void> execute(final ServerWebExchange exchange) {\\n            return Mono.defer(() -> {\\n                if (this.index < plugins.size()) {\\n                    // get plugin \\n                    ShenyuPlugin plugin = plugins.get(this.index++);\\n                    boolean skip = plugin.skip(exchange);\\n                    if (skip) {\\n                        // next\\n                        return this.execute(exchange);\\n                    }\\n                    // execute\\n                    return plugin.execute(exchange, this);\\n                }\\n                return Mono.empty();\\n            });\\n        }\\n    }\\n}\\n```\\n\\n#### 2.2 Match Rule\\n\\n- org.apache.shenyu.plugin.base.AbstractShenyuPlugin#execute()\\n\\nExecute the matching logic for selectors and rules in the `execute()` method.\\n\\n- Matching selectors.\\n- Matching rules.\\n- Execute the plugin.\\n\\n```java\\n@Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        // plugin name\\n        String pluginName = named();\\n        // plugin data\\n        PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);\\n        if (pluginData != null && pluginData.getEnabled()) {\\n            // selector data\\n            final Collection<SelectorData> selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);\\n            if (CollectionUtils.isEmpty(selectors)) {\\n                return handleSelectorIfNull(pluginName, exchange, chain);\\n            }\\n            // match selector\\n            SelectorData selectorData = matchSelector(exchange, selectors);\\n            if (Objects.isNull(selectorData)) {\\n                return handleSelectorIfNull(pluginName, exchange, chain);\\n            }\\n            selectorLog(selectorData, pluginName);\\n            // rule data\\n            List<RuleData> rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());\\n            if (CollectionUtils.isEmpty(rules)) {\\n                return handleRuleIfNull(pluginName, exchange, chain);\\n            }\\n            // match rule\\n            RuleData rule;\\n            if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {\\n                //get last\\n                rule = rules.get(rules.size() - 1);\\n            } else {\\n                rule = matchRule(exchange, rules);\\n            }\\n            if (Objects.isNull(rule)) {\\n                return handleRuleIfNull(pluginName, exchange, chain);\\n            }\\n            ruleLog(rule, pluginName);\\n            // execute\\n            return doExecute(exchange, chain, selectorData, rule);\\n        }\\n        return chain.execute(exchange);\\n    }\\n```\\n\\n#### 2.3 Execute GlobalPlugin\\n\\n- org.apache.shenyu.plugin.global.GlobalPlugin#execute()\\n\\n`GlobalPlugin` is a global plugin that constructs contextual information in the `execute()` method.\\n\\n```java\\npublic class GlobalPlugin implements ShenyuPlugin {\\n    // shenyu context\\n    private final ShenyuContextBuilder builder;\\n    \\n    //......\\n    \\n    @Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n       // build context information to be passed into the exchange\\n        ShenyuContext shenyuContext = builder.build(exchange);\\n        exchange.getAttributes().put(Constants.CONTEXT, shenyuContext);\\n        return chain.execute(exchange);\\n    }\\n    \\n    //......\\n}\\n```\\n\\n- org.apache.shenyu.plugin.global.DefaultShenyuContextBuilder#build()\\n\\nBuild the default context information.\\n\\n```java\\npublic class DefaultShenyuContextBuilder implements ShenyuContextBuilder {\\n    //......\\n    \\n    @Override\\n    public ShenyuContext build(final ServerWebExchange exchange) {\\n        //build data\\n        Pair<String, MetaData> buildData = buildData(exchange);\\n        //wrap ShenyuContext\\n        return decoratorMap.get(buildData.getLeft()).decorator(buildDefaultContext(exchange.getRequest()), buildData.getRight());\\n    }\\n    \\n    private Pair<String, MetaData> buildData(final ServerWebExchange exchange) {\\n        //......\\n        //get the metadata according to the requested uri\\n        MetaData metaData = MetaDataCache.getInstance().obtain(request.getURI().getPath());\\n        if (Objects.nonNull(metaData) && Boolean.TRUE.equals(metaData.getEnabled())) {\\n            exchange.getAttributes().put(Constants.META_DATA, metaData);\\n            return Pair.of(metaData.getRpcType(), metaData);\\n        } else {\\n            return Pair.of(RpcTypeEnum.HTTP.getName(), new MetaData());\\n        }\\n    }\\n    //set the default context information\\n    private ShenyuContext buildDefaultContext(final ServerHttpRequest request) {\\n        String appKey = request.getHeaders().getFirst(Constants.APP_KEY);\\n        String sign = request.getHeaders().getFirst(Constants.SIGN);\\n        String timestamp = request.getHeaders().getFirst(Constants.TIMESTAMP);\\n        ShenyuContext shenyuContext = new ShenyuContext();\\n        String path = request.getURI().getPath();\\n        shenyuContext.setPath(path); \\n        shenyuContext.setAppKey(appKey);\\n        shenyuContext.setSign(sign);\\n        shenyuContext.setTimestamp(timestamp);\\n        shenyuContext.setStartDateTime(LocalDateTime.now());\\n        Optional.ofNullable(request.getMethod()).ifPresent(httpMethod -> shenyuContext.setHttpMethod(httpMethod.name()));\\n        return shenyuContext;\\n    }\\n }\\n```\\n\\n- org.apache.shenyu.plugin.dubbo.common.context.DubboShenyuContextDecorator#decorator()\\n\\nwrap `ShenyuContext`:\\n\\n```java\\npublic class DubboShenyuContextDecorator implements ShenyuContextDecorator {\\n    \\n    @Override\\n    public ShenyuContext decorator(final ShenyuContext shenyuContext, final MetaData metaData) {\\n        shenyuContext.setModule(metaData.getAppName());\\n        shenyuContext.setMethod(metaData.getServiceName()); \\n        shenyuContext.setContextPath(metaData.getContextPath()); \\n        shenyuContext.setRpcType(RpcTypeEnum.DUBBO.getName()); \\n        return shenyuContext;\\n    }\\n    \\n    @Override\\n    public String rpcType() {\\n        return RpcTypeEnum.DUBBO.getName();\\n    }\\n}\\n```\\n\\n\\n#### 2.4 Execute RpcParamTransformPlugin\\n\\nThe `RpcParamTransformPlugin` is responsible for reading the parameters from the `http` request, saving them in the `exchange` and passing them to the `rpc` service.\\n\\n\\n- org.apache.shenyu.plugin.base.RpcParamTransformPlugin#execute()\\n\\nIn the `execute()` method, the core logic of the plugin is executed: get the request information from `exchange` and process the parameters according to the form of content passed in by the request.\\n\\n```java\\npublic class RpcParamTransformPlugin implements ShenyuPlugin {\\n\\n    @Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        //get request information from exchange\\n        ServerHttpRequest request = exchange.getRequest();\\n        ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        if (Objects.nonNull(shenyuContext)) {\\n           // APPLICATION_JSON\\n            MediaType mediaType = request.getHeaders().getContentType();\\n            if (MediaType.APPLICATION_JSON.isCompatibleWith(mediaType)) {\\n                return body(exchange, request, chain);\\n            }\\n            // APPLICATION_FORM_URLENCODED\\n            if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) {\\n                return formData(exchange, request, chain);\\n            }\\n            //query\\n            return query(exchange, request, chain);\\n        }\\n        return chain.execute(exchange);\\n    }\\n    \\n    //APPLICATION_JSON\\n    private Mono<Void> body(final ServerWebExchange exchange, final ServerHttpRequest serverHttpRequest, final ShenyuPluginChain chain) {\\n        return Mono.from(DataBufferUtils.join(serverHttpRequest.getBody())\\n                .flatMap(body -> {\\n                    exchange.getAttributes().put(Constants.PARAM_TRANSFORM, resolveBodyFromRequest(body));//\u89e3\u6790body\uff0c\u4fdd\u5b58\u5230exchange\u4e2d\\n                    return chain.execute(exchange);\\n                }));\\n    }\\n   // APPLICATION_FORM_URLENCODED\\n    private Mono<Void> formData(final ServerWebExchange exchange, final ServerHttpRequest serverHttpRequest, final ShenyuPluginChain chain) {\\n        return Mono.from(DataBufferUtils.join(serverHttpRequest.getBody())\\n                .flatMap(map -> {\\n                    String param = resolveBodyFromRequest(map);\\n                    LinkedMultiValueMap<String, String> linkedMultiValueMap;\\n                    try {\\n                        linkedMultiValueMap = BodyParamUtils.buildBodyParams(URLDecoder.decode(param, StandardCharsets.UTF_8.name())); //\u683c\u5f0f\u5316\u6570\u636e\\n                    } catch (UnsupportedEncodingException e) {\\n                        return Mono.error(e);\\n                    }\\n                    exchange.getAttributes().put(Constants.PARAM_TRANSFORM, HttpParamConverter.toMap(() -> linkedMultiValueMap));// \u4fdd\u5b58\u5230exchange\u4e2d\\n                    return chain.execute(exchange);\\n                }));\\n    }\\n    //query\\n    private Mono<Void> query(final ServerWebExchange exchange, final ServerHttpRequest serverHttpRequest, final ShenyuPluginChain chain) {\\n        exchange.getAttributes().put(Constants.PARAM_TRANSFORM, HttpParamConverter.ofString(() -> serverHttpRequest.getURI().getQuery()));//\u4fdd\u5b58\u5230exchange\u4e2d\\n        return chain.execute(exchange);\\n    }\\n    //......\\n }\\n```\\n\\n#### 2.5 Execute DubboPlugin\\n\\n- org.apache.shenyu.plugin.dubbo.common.AbstractDubboPlugin#doExecute()\\n\\nIn the `doExecute()` method, the main purpose is to check the metadata and parameters.\\n\\n```java\\npublic abstract class AbstractDubboPlugin extends AbstractShenyuPlugin {\\n    \\n    @Override\\n    public Mono<Void> doExecute(final ServerWebExchange exchange,\\n                                   final ShenyuPluginChain chain,\\n                                   final SelectorData selector,\\n                                   final RuleData rule) {\\n        //param\\n        String param = exchange.getAttribute(Constants.PARAM_TRANSFORM);\\n        //context\\n        ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        assert shenyuContext != null;\\n        //metaData\\n        MetaData metaData = exchange.getAttribute(Constants.META_DATA);\\n        //check metaData\\n        if (!checkMetaData(metaData)) {\\n            LOG.error(\\" path is : {}, meta data have error : {}\\", shenyuContext.getPath(), metaData);\\n            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.META_DATA_ERROR, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        //check\\n        if (Objects.nonNull(metaData) && StringUtils.isNoneBlank(metaData.getParameterTypes()) && StringUtils.isBlank(param)) {\\n            exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);\\n            Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.DUBBO_HAVE_BODY_PARAM, null);\\n            return WebFluxResultUtils.result(exchange, error);\\n        }\\n        //set rpcContext\\n        this.rpcContext(exchange);\\n        //dubbo invoke\\n        return this.doDubboInvoker(exchange, chain, selector, rule, metaData, param);\\n    }\\n}\\n```\\n\\n\\n- org.apache.shenyu.plugin.apache.dubbo.ApacheDubboPlugin#doDubboInvoker()\\n\\nSet special context information in the `doDubboInvoker()` method, and then start the dubbo generalization call.\\n\\n```java\\npublic class ApacheDubboPlugin extends AbstractDubboPlugin {\\n    \\n    @Override\\n    protected Mono<Void> doDubboInvoker(final ServerWebExchange exchange,\\n                                        final ShenyuPluginChain chain,\\n                                        final SelectorData selector,\\n                                        final RuleData rule,\\n                                        final MetaData metaData,\\n                                        final String param) {\\n        //set the current selector and rule information, and request address for dubbo graying support\\n        RpcContext.getContext().setAttachment(Constants.DUBBO_SELECTOR_ID, selector.getId());\\n        RpcContext.getContext().setAttachment(Constants.DUBBO_RULE_ID, rule.getId());\\n        RpcContext.getContext().setAttachment(Constants.DUBBO_REMOTE_ADDRESS, Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress());\\n        //dubbo generic invoker\\n        final Mono<Object> result = dubboProxyService.genericInvoker(param, metaData, exchange);\\n        //execute next plugin in chain\\n        return result.then(chain.execute(exchange));\\n    }\\n}\\n```\\n\\n- org.apache.shenyu.plugin.apache.dubbo.proxy.ApacheDubboProxyService#genericInvoker()\\n\\n`genericInvoker()` method.\\n\\n- Gets the `ReferenceConfig` object.\\n- Gets the generalization service `GenericService` object.\\n- Constructs the request parameter `pair` object.\\n- Initiates an asynchronous generalization invocation.\\n\\n```java\\npublic class ApacheDubboProxyService {\\n    //...... \\n\\n    /**\\n     * Generic invoker object.\\n     */\\n    public Mono<Object> genericInvoker(final String body, final MetaData metaData, final ServerWebExchange exchange) throws ShenyuException {\\n        //1.Get the ReferenceConfig object\\n        ReferenceConfig<GenericService> reference = ApacheDubboConfigCache.getInstance().get(metaData.getPath());\\n\\n        if (Objects.isNull(reference) || StringUtils.isEmpty(reference.getInterface())) {\\n            //Failure of the current cache information\\n            ApacheDubboConfigCache.getInstance().invalidate(metaData.getPath());\\n            //Reinitialization with metadata\\n            reference = ApacheDubboConfigCache.getInstance().initRef(metaData);\\n        }\\n        //2.Get the GenericService object of the generalization service\\n        GenericService genericService = reference.get();\\n        //3.Constructing the request parameter pair object\\n        Pair<String[], Object[]> pair;\\n        if (StringUtils.isBlank(metaData.getParameterTypes()) || ParamCheckUtils.dubboBodyIsEmpty(body)) {\\n            pair = new ImmutablePair<>(new String[]{}, new Object[]{});\\n        } else {\\n            pair = dubboParamResolveService.buildParameter(body, metaData.getParameterTypes());\\n        }\\n        //4.Initiating asynchronous generalization calls\\n        return Mono.fromFuture(invokeAsync(genericService, metaData.getMethodName(), pair.getLeft(), pair.getRight()).thenApply(ret -> {\\n            //handle result\\n            if (Objects.isNull(ret)) {\\n                ret = Constants.DUBBO_RPC_RESULT_EMPTY;\\n            }\\n            exchange.getAttributes().put(Constants.RPC_RESULT, ret);\\n            exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.SUCCESS.getName());\\n            return ret;\\n        })).onErrorMap(exception -> exception instanceof GenericException ? new ShenyuException(((GenericException) exception).getExceptionMessage()) : new ShenyuException(exception));//\u5904\u7406\u5f02\u5e38\\n    }\\n    \\n    //Generalized calls, asynchronous operations\\n    private CompletableFuture<Object> invokeAsync(final GenericService genericService, final String method, final String[] parameterTypes, final Object[] args) throws GenericException {\\n        genericService.$invoke(method, parameterTypes, args);\\n        Object resultFromFuture = RpcContext.getContext().getFuture();\\n        return resultFromFuture instanceof CompletableFuture ? (CompletableFuture<Object>) resultFromFuture : CompletableFuture.completedFuture(resultFromFuture);\\n    }\\n}\\n\\n```\\n\\n\\nCalling the `dubbo` service at the gateway can be achieved by generalizing the call.\\n\\n\\n\\nThe `ReferenceConfig` object is the key object to support generalization calls , and its initialization operation is done during data synchronization. There are two parts of data involved here, one is the synchronized plugin `handler` information and the other is the synchronized plugin metadata information.\\n\\n- org.apache.shenyu.plugin.dubbo.common.handler.AbstractDubboPluginDataHandler#handlerPlugin()\\n\\nWhen the plugin data is updated, the data synchronization module synchronizes the data from `shenyu-admin` to the gateway. The initialization operation is performed in `handlerPlugin()`.\\n\\n```java\\npublic abstract class AbstractDubboPluginDataHandler implements PluginDataHandler {\\n    //......\\n    \\n    //Initializing the configuration cache\\n   protected abstract void initConfigCache(DubboRegisterConfig dubboRegisterConfig);\\n\\n    @Override\\n    public void handlerPlugin(final PluginData pluginData) {\\n        if (Objects.nonNull(pluginData) && Boolean.TRUE.equals(pluginData.getEnabled())) {\\n            //Data deserialization\\n            DubboRegisterConfig dubboRegisterConfig = GsonUtils.getInstance().fromJson(pluginData.getConfig(), DubboRegisterConfig.class);\\n            DubboRegisterConfig exist = Singleton.INST.get(DubboRegisterConfig.class);\\n            if (Objects.isNull(dubboRegisterConfig)) {\\n                return;\\n            }\\n            if (Objects.isNull(exist) || !dubboRegisterConfig.equals(exist)) {\\n                // Perform initialization operations\\n                this.initConfigCache(dubboRegisterConfig);\\n            }\\n            Singleton.INST.single(DubboRegisterConfig.class, dubboRegisterConfig);\\n        }\\n    }\\n    //......\\n}\\n```\\n\\n- org.apache.shenyu.plugin.apache.dubbo.handler.ApacheDubboPluginDataHandler#initConfigCache()\\n\\nPerform initialization operations.\\n\\n```java\\npublic class ApacheDubboPluginDataHandler extends AbstractDubboPluginDataHandler {\\n\\n    @Override\\n    protected void initConfigCache(final DubboRegisterConfig dubboRegisterConfig) {\\n        //perform initialization operations\\n        ApacheDubboConfigCache.getInstance().init(dubboRegisterConfig);\\n        //cached results before failure\\n        ApacheDubboConfigCache.getInstance().invalidateAll();\\n    }\\n}\\n\\n```\\n\\n- org.apache.shenyu.plugin.apache.dubbo.cache.ApacheDubboConfigCache#init()\\n\\nIn the initialization, set `registryConfig` and `consumerConfig`.\\n\\n```java\\npublic final class ApacheDubboConfigCache extends DubboConfigCache {\\n    //......  \\n   /**\\n     * init\\n     */\\n    public void init(final DubboRegisterConfig dubboRegisterConfig) {\\n        //ApplicationConfig\\n        if (Objects.isNull(applicationConfig)) {\\n            applicationConfig = new ApplicationConfig(\\"shenyu_proxy\\");\\n        }\\n        //When the protocol or address changes, you need to update the registryConfig\\n        if (needUpdateRegistryConfig(dubboRegisterConfig)) {\\n            RegistryConfig registryConfigTemp = new RegistryConfig();\\n            registryConfigTemp.setProtocol(dubboRegisterConfig.getProtocol());\\n            registryConfigTemp.setId(\\"shenyu_proxy\\");\\n            registryConfigTemp.setRegister(false);\\n            registryConfigTemp.setAddress(dubboRegisterConfig.getRegister());            Optional.ofNullable(dubboRegisterConfig.getGroup()).ifPresent(registryConfigTemp::setGroup);\\n            registryConfig = registryConfigTemp;\\n        }\\n        //ConsumerConfig\\n        if (Objects.isNull(consumerConfig)) {\\n            consumerConfig = ApplicationModel.getConfigManager().getDefaultConsumer().orElseGet(() -> {\\n                ConsumerConfig consumerConfig = new ConsumerConfig();\\n                consumerConfig.refresh();\\n                return consumerConfig;\\n            });\\n           \\n            //ConsumerConfig\\n            Optional.ofNullable(dubboRegisterConfig.getThreadpool()).ifPresent(consumerConfig::setThreadpool); \\n            Optional.ofNullable(dubboRegisterConfig.getCorethreads()).ifPresent(consumerConfig::setCorethreads);\\n            Optional.ofNullable(dubboRegisterConfig.getThreads()).ifPresent(consumerConfig::setThreads);\\n            Optional.ofNullable(dubboRegisterConfig.getQueues()).ifPresent(consumerConfig::setQueues);\\n        }\\n    }\\n    \\n    //Does the registration configuration need to be updated\\n    private boolean needUpdateRegistryConfig(final DubboRegisterConfig dubboRegisterConfig) {\\n        if (Objects.isNull(registryConfig)) {\\n            return true;\\n        }\\n        return !Objects.equals(dubboRegisterConfig.getProtocol(), registryConfig.getProtocol())\\n                || !Objects.equals(dubboRegisterConfig.getRegister(), registryConfig.getAddress())\\n                || !Objects.equals(dubboRegisterConfig.getProtocol(), registryConfig.getProtocol());\\n    }\\n\\n    //......\\n}\\n```\\n\\n\\n- org.apache.shenyu.plugin.apache.dubbo.subscriber.ApacheDubboMetaDataSubscriber#onSubscribe()\\n\\nWhen the metadata is updated, the data synchronization module synchronizes the data from `shenyu-admin` to the gateway. The metadata update operation is performed in the `onSubscribe()` method.\\n\\n```java\\npublic class ApacheDubboMetaDataSubscriber implements MetaDataSubscriber {\\n    //local memory cache\\n    private static final ConcurrentMap<String, MetaData> META_DATA = Maps.newConcurrentMap();\\n\\n    //update metaData\\n    public void onSubscribe(final MetaData metaData) {\\n        // dubbo\\n        if (RpcTypeEnum.DUBBO.getName().equals(metaData.getRpcType())) {\\n            //Whether the corresponding metadata exists\\n            MetaData exist = META_DATA.get(metaData.getPath());\\n            if (Objects.isNull(exist) || Objects.isNull(ApacheDubboConfigCache.getInstance().get(metaData.getPath()))) {\\n                // initRef\\n                ApacheDubboConfigCache.getInstance().initRef(metaData);\\n            } else {\\n                // The corresponding metadata has undergone an update operation\\n                if (!Objects.equals(metaData.getServiceName(), exist.getServiceName())\\n                        || !Objects.equals(metaData.getRpcExt(), exist.getRpcExt())\\n                        || !Objects.equals(metaData.getParameterTypes(), exist.getParameterTypes())\\n                        || !Objects.equals(metaData.getMethodName(), exist.getMethodName())) {\\n                    //Build ReferenceConfig again based on the latest metadata\\n                    ApacheDubboConfigCache.getInstance().build(metaData);\\n                }\\n            }\\n            //local memory cache\\n            META_DATA.put(metaData.getPath(), metaData);\\n        }\\n    }\\n\\n    //dalete\\n    public void unSubscribe(final MetaData metaData) {\\n        if (RpcTypeEnum.DUBBO.getName().equals(metaData.getRpcType())) {\\n            //\u4f7fReferenceConfig\u5931\u6548\\n            ApacheDubboConfigCache.getInstance().invalidate(metaData.getPath());\\n            META_DATA.remove(metaData.getPath());\\n        }\\n    }\\n}\\n```\\n\\n- org.apache.shenyu.plugin.apache.dubbo.cache.ApacheDubboConfigCache#initRef()\\n\\nBuild `ReferenceConfig` objects from `metaData`.\\n\\n```java\\npublic final class ApacheDubboConfigCache extends DubboConfigCache {\\n    //......\\n    \\n    public ReferenceConfig<GenericService> initRef(final MetaData metaData) {\\n            try {\\n                //First try to get it from the cache, and return it directly if it exists\\n                ReferenceConfig<GenericService> referenceConfig = cache.get(metaData.getPath());\\n                if (StringUtils.isNoneBlank(referenceConfig.getInterface())) {\\n                    return referenceConfig;\\n                }\\n            } catch (ExecutionException e) {\\n                LOG.error(\\"init dubbo ref exception\\", e);\\n            }\\n          \\n            //build if not exist\\n            return build(metaData);\\n        }\\n\\n        /**\\n         * Build reference config.\\n         */\\n        @SuppressWarnings(\\"deprecation\\")\\n        public ReferenceConfig<GenericService> build(final MetaData metaData) {\\n            if (Objects.isNull(applicationConfig) || Objects.isNull(registryConfig)) {\\n                return new ReferenceConfig<>();\\n            }\\n            ReferenceConfig<GenericService> reference = new ReferenceConfig<>(); //ReferenceConfig\\n            reference.setGeneric(\\"true\\"); //generic invoke\\n            reference.setAsync(true);//async\\n\\n            reference.setApplication(applicationConfig);//applicationConfig\\n            reference.setRegistry(registryConfig);//registryConfig\\n            reference.setConsumer(consumerConfig);//consumerConfig\\n            reference.setInterface(metaData.getServiceName());//serviceName\\n            reference.setProtocol(\\"dubbo\\");//dubbo\\n            reference.setCheck(false); \\n            reference.setLoadbalance(\\"gray\\");//gray\\n\\n            Map<String, String> parameters = new HashMap<>(2);\\n            parameters.put(\\"dispatcher\\", \\"direct\\");\\n            reference.setParameters(parameters);\\n\\n            String rpcExt = metaData.getRpcExt();//rpc ext param\\n            DubboParam dubboParam = parserToDubboParam(rpcExt);\\n            if (Objects.nonNull(dubboParam)) {\\n                if (StringUtils.isNoneBlank(dubboParam.getVersion())) {\\n                    reference.setVersion(dubboParam.getVersion());//version\\n                }\\n                if (StringUtils.isNoneBlank(dubboParam.getGroup())) {\\n                    reference.setGroup(dubboParam.getGroup());//group\\n                }\\n                if (StringUtils.isNoneBlank(dubboParam.getUrl())) {\\n                    reference.setUrl(dubboParam.getUrl());//url\\n                }\\n                if (StringUtils.isNoneBlank(dubboParam.getCluster())) {\\n                    reference.setCluster(dubboParam.getCluster());\\n                }\\n                Optional.ofNullable(dubboParam.getTimeout()).ifPresent(reference::setTimeout);//timeout\\n                Optional.ofNullable(dubboParam.getRetries()).ifPresent(reference::setRetries);//retires\\n                Optional.ofNullable(dubboParam.getSent()).ifPresent(reference::setSent);//Whether to ack async-sent\\n            }\\n            try {\\n                //get GenericService\\n                Object obj = reference.get();\\n                if (Objects.nonNull(obj)) {\\n                    LOG.info(\\"init apache dubbo reference success there meteData is :{}\\", metaData);\\n                    //cache reference\\n                    cache.put(metaData.getPath(), reference);\\n                }\\n            } catch (Exception e) {\\n                LOG.error(\\"init apache dubbo reference exception\\", e);\\n            }\\n            return reference;\\n        }\\n    //......\\n    }\\n```\\n\\n\\n#### 2.6 Execute ResponsePlugin\\n\\n- org.apache.shenyu.plugin.response.ResponsePlugin#execute()\\n\\nThe response results are handled by the `ResponsePlugin` plugin.\\n\\n```java\\n    @Override\\n    public Mono<Void> execute(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        ShenyuContext shenyuContext = exchange.getAttribute(Constants.CONTEXT);\\n        assert shenyuContext != null;\\n        // handle results according to rpc type\\n        return writerMap.get(shenyuContext.getRpcType()).writeWith(exchange, chain);\\n    }\\n```\\n\\nThe processing type is determined by `MessageWriter` and the class inheritance relationship is as follows.\\n\\n![](/img/activities/code-analysis-dubbo-plugin/MessageWriter.png)\\n\\n\\n- MessageWriter: interface, defining message processing methods.\\n- NettyClientMessageWriter: processing of `Netty` call results.\\n- RPCMessageWriter: processing the results of `RPC` calls.\\n- WebClientMessageWriter: processing the results of `WebClient` calls.\\n\\n`Dubbo` service call, the processing result is `RPCMessageWriter` of course.\\n\\n- org.apache.shenyu.plugin.response.strategy.RPCMessageWriter#writeWith()\\n\\nProcess the response results in the `writeWith()` method.\\n\\n```java\\n\\npublic class RPCMessageWriter implements MessageWriter {\\n\\n    @Override\\n    public Mono<Void> writeWith(final ServerWebExchange exchange, final ShenyuPluginChain chain) {\\n        return chain.execute(exchange).then(Mono.defer(() -> {\\n            Object result = exchange.getAttribute(Constants.RPC_RESULT); //result\\n            if (Objects.isNull(result)) { \\n                Object error = ShenyuResultWrap.error(exchange, ShenyuResultEnum.SERVICE_RESULT_ERROR, null);\\n                return WebFluxResultUtils.result(exchange, error);\\n            }\\n            return WebFluxResultUtils.result(exchange, result);\\n        }));\\n    }\\n}\\n```\\n\\nAt this point in the analysis, the source code analysis of the `Dubbo` plugin is complete, and the analysis flow chart is as follows.\\n\\n\\n![](/img/activities/code-analysis-dubbo-plugin/dubbo-execute-en.png)\\n\\n\\n### 3. Summary\\n\\nThe source code analysis in this article starts from `Dubbo` service registration to `Dubbo` plug-in service calls. The `Dubbo` plugin is mainly used to handle the conversion of `http` requests to the `dubbo` protocol, and the main logic is implemented through generalized calls."},{"id":"/Plugin-SourceCode-Analysis-Mcp-Server-Plugin","metadata":{"permalink":"/blog/Plugin-SourceCode-Analysis-Mcp-Server-Plugin","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Plugin-SourceCode-Analysis-Mcp-Server-Plugin.md","source":"@site/blog/Plugin-SourceCode-Analysis-Mcp-Server-Plugin.md","title":"McpServer Plugin Source Code Analysis","description":"In the Shenyu gateway, when you start this plugin, Shenyu becomes a fully-featured McpServer.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"plugin","permalink":"/blog/tags/plugin"},{"label":"mcp","permalink":"/blog/tags/mcp"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":10.305,"hasTruncateMarker":false,"authors":[{"name":"yusiheng","title":"Apache ShenYu Contributor","url":"https://github.com/478320"}],"frontMatter":{"title":"McpServer Plugin Source Code Analysis","author":"yusiheng","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/478320","tags":["plugin","mcp","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Code Analysis For Dubbo Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Dubbo-Plugin"},"nextItem":{"title":"Code Analysis For Param-Mapping Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin"}},"content":"In the Shenyu gateway, when you start this plugin, Shenyu becomes a fully-featured McpServer.  \\nYou can easily register a service as a tool within the Shenyu gateway by simple configuration and use the extended functions the gateway offers.\\n\\n> This article is based on version `shenyu-2.7.0.2`. Here, I will track the Shenyu Mcp plugin chain and analyze the source code of its SSE communication.\\n\\n### Introduction\\n\\n> The Shenyu gateway\'s Mcp plugin is built on top of the spring-ai-mcp extension. To better understand how the Mcp plugin works, I\u2019ll briefly introduce how some official Mcp Java classes collaborate within its JDK.\\n\\nI want to start by introducing three key official Mcp Java classes:\\n\\n>1. **McpServer**  \\n    > This class manages resources like tools, Resource, promote, etc.\\n>2. **TransportProvider**  \\n    > Provides corresponding communication methods based on client-server communication protocols.\\n>3. **Session**  \\n    > Handles request data, response data, and notifications, offers some basic methods and corresponding handlers, and executes tool queries and calls here.\\n\\n### 1. Service Registration\\n\\nIn Shenyu Admin, after filling in endpoint and tool information for the McpServer plugin, this info is automatically registered into Shenyu bootstrap.  \\nYou can refer to the official [websocket data sync source code](https://shenyu.incubator.apache.org/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync) for details.\\n\\nShenyu bootstrap receives the data synced from admin in the `handler()` method of `McpServerPluginDataHandler`.\\n\\n- `handlerSelector()` receives URL data and creates McpServer.\\n- `handlerRule()` receives tool info and registers tools.\\n\\nThese two methods together form the service registration part of the Shenyu Mcp plugin. Below, I will analyze these two methods in detail.\\n\\n#### 1.1 Transport and McpServer Registration\\n\\nLet\u2019s analyze the `handlerSelector()` method, which handles McpServer registration.\\n\\n* What `handlerSelector()` does:\\n\\n```java\\npublic class McpServerPluginDataHandler implements PluginDataHandler {\\n    @Override\\n    public void handlerSelector(final SelectorData selectorData) {\\n        // Get URI\\n        String uri = selectorData.getConditionList().stream()\\n                .filter(condition -> Constants.URI.equals(condition.getParamType()))\\n                .map(ConditionData::getParamValue)\\n                .findFirst()\\n                .orElse(null);\\n        \\n        // Build McpServer\\n        ShenyuMcpServer shenyuMcpServer = GsonUtils.getInstance().fromJson(Objects.isNull(selectorData.getHandle()) ? DEFAULT_MESSAGE_ENDPOINT : selectorData.getHandle(), ShenyuMcpServer.class);\\n        shenyuMcpServer.setPath(path);\\n        // Cache shenyuMcpServer\\n        CACHED_SERVER.get().cachedHandle(\\n                selectorData.getId(),\\n                shenyuMcpServer);\\n        String messageEndpoint = shenyuMcpServer.getMessageEndpoint();\\n        // Try to get or register transportProvider\\n        shenyuMcpServerManager.getOrCreateMcpServerTransport(uri, messageEndpoint);\\n    }\\n    \\n}\\n```\\n\\n> `ShenyuMcpServerManager` is the management center of McpServer in Shenyu. It not only stores `McpAsyncServer`, `CompositeTransportProvider`, etc., but also contains methods to register Transport and McpServer.\\n\\n* The `getOrCreateMcpServerTransport()` method works as follows:\\n\\n```java\\n@Component\\npublic class ShenyuMcpServerManager {\\n    public ShenyuSseServerTransportProvider getOrCreateMcpServerTransport(final String uri, final String messageEndPoint) {\\n        // Remove /streamablehttp and /message suffixes\\n        String normalizedPath = processPath(uri);\\n        return getOrCreateTransport(normalizedPath, SSE_PROTOCOL,\\n                () -> createSseTransport(normalizedPath, messageEndPoint));\\n    }\\n    \\n    private <T> T getOrCreateTransport(final String normalizedPath, final String protocol,\\n                                       final java.util.function.Supplier<T> transportFactory) {\\n        // Get composite Transport instance\\n        CompositeTransportProvider compositeTransport = getOrCreateCompositeTransport(normalizedPath);\\n\\n        T transport = switch (protocol) {\\n            case SSE_PROTOCOL -> (T) compositeTransport.getSseTransport();\\n            case STREAMABLE_HTTP_PROTOCOL -> (T) compositeTransport.getStreamableHttpTransport();\\n            default -> null;\\n        };\\n        // If instance is missing in cache, create a new one\\n        if (Objects.isNull(transport)) {\\n            // Call createSseTransport() to create and store a new transport\\n            transport = transportFactory.get();\\n            // Create McpAsyncServer and register the transport\\n            addTransportToSharedServer(normalizedPath, protocol, transport);\\n        }\\n\\n        return transport;\\n    }\\n}\\n```\\n\\n##### 1.1.1 Transport Registration\\n\\n* `createSseTransport()` method\\n> This method is called within `getOrCreateMcpServerTransport()` and is used to create a Transport\\n\\n```java\\n@Component\\npublic class ShenyuMcpServerManager {\\n    private ShenyuSseServerTransportProvider createSseTransport(final String normalizedPath, final String messageEndPoint) {\\n        String messageEndpoint = normalizedPath + messageEndPoint;\\n        ShenyuSseServerTransportProvider transportProvider = ShenyuSseServerTransportProvider.builder()\\n                .objectMapper(objectMapper)\\n                .sseEndpoint(normalizedPath)\\n                .messageEndpoint(messageEndpoint)\\n                .build();\\n        // Register the two functions of transportProvider to the Manager\'s routeMap\\n        registerRoutes(normalizedPath, messageEndpoint, transportProvider::handleSseConnection, transportProvider::handleMessage);\\n        return transportProvider;\\n    }\\n}\\n```\\n\\n##### 1.1.2 McpServer Registration\\n\\n* `addTransportToSharedServer()` method\\n> This method is called within `getOrCreateMcpServerTransport()` and is used to create and save McpServer\\n\\nThis method creates a new McpServer, stores it in `sharedServerMap`, and saves the TransportProvider obtained above into `compositeTransportMap`.\\n\\n```java\\n@Component\\npublic class ShenyuMcpServerManager {\\n    private void addTransportToSharedServer(final String normalizedPath, final String protocol, final Object transportProvider) {\\n        // Get or create and register McpServer\\n        getOrCreateSharedServer(normalizedPath);\\n\\n        // Save the new transport protocol into compositeTransportMap\\n        compositeTransport.addTransport(protocol, transportProvider);\\n        \\n    }\\n\\n    private McpAsyncServer getOrCreateSharedServer(final String normalizedPath) {\\n        return sharedServerMap.computeIfAbsent(normalizedPath, path -> {\\n            // Get transport protocols\\n            CompositeTransportProvider compositeTransport = getOrCreateCompositeTransport(path);\\n\\n            // Select server capabilities\\n            var capabilities = McpSchema.ServerCapabilities.builder()\\n                    .tools(true)\\n                    .logging()\\n                    .build();\\n\\n            // Create and store McpServer\\n            McpAsyncServer server = McpServer\\n                    .async(compositeTransport)\\n                    .serverInfo(\\"MCP Shenyu Server (Multi-Protocol)\\", \\"1.0.0\\")\\n                    .capabilities(capabilities)\\n                    .tools(Lists.newArrayList())\\n                    .build();\\n            \\n            return server;\\n        });\\n    }\\n}\\n```\\n\\n#### 1.2 Tools Registration\\n\\n* `handlerRule()` method works as follows:\\n\\n1. Captures the tool configuration info users fill in for the Tool, all used to build the tool\\n2. Deserializes to create `ShenyuMcpServerTool` and obtains tool info\\n\\n> Note: `ShenyuMcpServerTool` is also a Shenyu-side object for storing tool info, unrelated by inheritance to `McpServerTool`\\n\\n3. Calls `addTool()` method to create the tool using this info and registers the tool to the matching McpServer based on SelectorId\\n\\n```java\\npublic class McpServerPluginDataHandler implements PluginDataHandler {\\n    @Override\\n    public void handlerRule(final RuleData ruleData) {\\n        Optional.ofNullable(ruleData.getHandle()).ifPresent(s -> {\\n            // Deserialize a new ShenyuMcpServerTool\\n            ShenyuMcpServerTool mcpServerTool = GsonUtils.getInstance().fromJson(s, ShenyuMcpServerTool.class);\\n            // Cache mcpServerTool\\n            CACHED_TOOL.get().cachedHandle(CacheKeyUtils.INST.getKey(ruleData), mcpServerTool);\\n            // Build MCP schema\\n            List<McpServerToolParameter> parameters = mcpServerTool.getParameters();\\n            String inputSchema = JsonSchemaUtil.createParameterSchema(parameters);\\n            ShenyuMcpServer server = CACHED_SERVER.get().obtainHandle(ruleData.getSelectorId());\\n            if (Objects.nonNull(server)) {\\n                // Save tool info into Manager\'s sharedServerMap\\n                shenyuMcpServerManager.addTool(server.getPath(),\\n                        StringUtils.isBlank(mcpServerTool.getName()) ? ruleData.getName()\\n                                : mcpServerTool.getName(),\\n                        mcpServerTool.getDescription(),\\n                        mcpServerTool.getRequestConfig(),\\n                        inputSchema);\\n            }\\n        });\\n    }\\n}\\n```\\n\\n* `addTool()` method\\n> This method is called by `handlerRule()` to add a new tool\\n\\nThis method performs:\\n\\n1. Converts the previous tool info into a `shenyuToolDefinition` object\\n2. Creates a `ShenyuToolCallback` object using the converted `shenyuToolDefinition`\\n> `ShenyuToolCallback` overrides the `call()` method of `ToolCallBack` and registers this overridden method to `AsyncToolSpecification`, so calling the tool\'s `call()` will actually invoke this overridden method\\n\\n3. Converts `ShenyuToolCallback` to `AsyncToolSpecification` and registers it to the corresponding McpServer\\n\\n```java\\npublic class McpServerPluginDataHandler implements PluginDataHandler {\\n    public void addTool(final String serverPath, final String name, final String description,\\n                        final String requestTemplate, final String inputSchema) {\\n        String normalizedPath = normalizeServerPath(serverPath);\\n        // Build Definition object\\n        ToolDefinition shenyuToolDefinition = ShenyuToolDefinition.builder()\\n                .name(name)\\n                .description(description)\\n                .requestConfig(requestTemplate)\\n                .inputSchema(inputSchema)\\n                .build();\\n        \\n        ShenyuToolCallback shenyuToolCallback = new ShenyuToolCallback(shenyuToolDefinition);\\n\\n        // Get previously registered McpServer and register the Tool\\n        McpAsyncServer sharedServer = sharedServerMap.get(normalizedPath);\\n        for (AsyncToolSpecification asyncToolSpecification : McpToolUtils.toAsyncToolSpecifications(shenyuToolCallback)) {\\n            sharedServer.addTool(asyncToolSpecification).block();\\n        }        \\n    }\\n}\\n```\\n\\nWith this, service registration analysis is complete.\\n\\nService registration overview diagram  \\n![](/img/activities/code-analysis-mcp-server-plugin/Mcp-server-register-en.png)\\n\\n### 2. Plugin Execution\\n\\nClients will send two types of messages with `/sse` and `/message` suffixes. These messages are captured by the Shenyu McpServer plugin, which handles them differently. When receiving `/sse` messages, the plugin creates and saves a session object, then returns a session id for `/message` usage. When receiving `/message` messages, the plugin executes methods based on the method info carried by the `/message` message, such as fetching work lists, tool invocation, and resource lists.\\n\\n* `doExecute()` method works as follows:\\n\\n1. Matches the path and checks if the Mcp plugin registered it\\n2. Calls `routeByProtocol()` to choose the appropriate handling plan based on the request protocol\\n\\n> This article focuses on the SSE request mode, so we enter the `handleSseRequest()` method\\n\\n```java\\npublic class McpServerPlugin extends AbstractShenyuPlugin {\\n    @Override\\n    protected Mono<Void> doExecute(final ServerWebExchange exchange,\\n                                   final ShenyuPluginChain chain,\\n                                   final SelectorData selector,\\n                                   final RuleData rule) {\\n        final String uri = exchange.getRequest().getURI().getRawPath();\\n        // Check if Mcp plugin registered this route; if not, continue chain without handling\\n        if (!shenyuMcpServerManager.canRoute(uri)) {\\n            return chain.execute(exchange);\\n        }\\n        final ServerRequest request = ServerRequest.create(exchange, messageReaders);\\n        // Choose handling method based on URI protocol\\n        return routeByProtocol(exchange, chain, request, selector, uri);\\n    }\\n\\n    private Mono<Void> routeByProtocol(final ServerWebExchange exchange,\\n                                       final ShenyuPluginChain chain,\\n                                       final ServerRequest request,\\n                                       final SelectorData selector,\\n                                       final String uri) {\\n\\n        if (isStreamableHttpProtocol(uri)) {\\n            return handleStreamableHttpRequest(exchange, chain, request, uri);\\n        } else if (isSseProtocol(uri)) {\\n            // Handle SSE requests\\n            return handleSseRequest(exchange, chain, request, selector, uri);\\n        } \\n    }\\n}\\n```\\n\\n* `handleSseRequest()` method\\n> Called by `routeByProtocol()` to determine if the client wants to create a session or call a tool based on URI suffix\\n\\n```java\\npublic class McpServerPlugin extends AbstractShenyuPlugin {\\n    private Mono<Void> handleSseRequest(final ServerWebExchange exchange,\\n                                        final ShenyuPluginChain chain,\\n                                        final ServerRequest request,\\n                                        final SelectorData selector,\\n                                        final String uri) {\\n        ShenyuMcpServer server = McpServerPluginDataHandler.CACHED_SERVER.get().obtainHandle(selector.getId());\\n        String messageEndpoint = server.getMessageEndpoint();\\n        // Get the transport provider\\n        ShenyuSseServerTransportProvider transportProvider\\n                = shenyuMcpServerManager.getOrCreateMcpServerTransport(uri, messageEndpoint);\\n        // Determine if the request is an SSE connection or a message call\\n        if (uri.endsWith(messageEndpoint)) {\\n            setupSessionContext(exchange, chain);\\n            return handleMessageEndpoint(exchange, transportProvider, request);\\n        } else {\\n            return handleSseEndpoint(exchange, transportProvider, request);\\n        }\\n    }\\n}\\n```\\n\\n#### 2.1 Client Sends SSE Request\\n\\n> If the client sends a request ending with `/sse`, the `handleSseEndpoint()` method is executed\\n\\n* `handleSseEndpoint()` mainly does:\\n\\n1. Sets SSE request headers\\n2. Calls `ShenyuSseServerTransportProvider.createSseFlux()` to create the SSE stream\\n\\n```java\\npublic class McpServerPlugin extends AbstractShenyuPlugin {\\n    private Mono<Void> handleSseEndpoint(final ServerWebExchange exchange,\\n                                         final ShenyuSseServerTransportProvider transportProvider,\\n                                         final ServerRequest request) {\\n        // Configure SSE request headers\\n        configureSseHeaders(exchange);\\n\\n        // Create SSE stream\\n        return exchange.getResponse()\\n                .writeWith(transportProvider\\n                        .createSseFlux(request));\\n    }\\n}\\n```\\n\\n* `createSseFlux()` method\\n> Called by `handleSseEndpoint()`; mainly used to create and save a session\\n> 1. Creates session; the session factory registers a series of handlers, which are the objects actually executing tool calls\\n> 2. Saves the session for reuse\\n> 3. Sends the session id as a parameter of the endpoint URL back to the client, to be used when calling the message endpoint\\n\\n```java\\npublic class ShenyuSseServerTransportProvider implements McpServerTransportProvider {\\n    public Flux<ServerSentEvent<?>> createSseFlux(final ServerRequest request) {\\n        return Flux.<ServerSentEvent<?>>create(sink -> {\\n                    WebFluxMcpSessionTransport sessionTransport = new WebFluxMcpSessionTransport(sink);\\n                    // Create McpServerSession and temporarily store plugin chain info\\n                    McpServerSession session = sessionFactory.create(sessionTransport);\\n                    String sessionId = session.getId();\\n                    sessions.put(sessionId, session);\\n\\n                    // Send session id info back to client\\n                    String endpointUrl = this.baseUrl + this.messageEndpoint + \\"?sessionId=\\" + sessionId;\\n                    ServerSentEvent<String> endpointEvent = ServerSentEvent.<String>builder()\\n                            .event(ENDPOINT_EVENT_TYPE)\\n                            .data(endpointUrl)\\n                            .build();\\n                }).doOnSubscribe(subscription -> LOGGER.info(\\"SSE Flux subscribed\\"))\\n                .doOnRequest(n -> LOGGER.debug(\\"SSE Flux requested {} items\\", n));\\n    }\\n}\\n```\\n\\n#### 2.2 Client Sends Message Request\\n\\n> If the client sends a request ending with `/message`, the current `ShenyuPluginChain` info is saved into the session, and `handleMessageEndpoint()` is called.  \\n> Subsequent tool calls continue executing this plugin chain, so plugins after the Mcp plugin will affect tool requests.\\n\\n* `handleMessageEndpoint()` method, calls `ShenyuSseServerTransportProvider.handleMessageEndpoint()` to process\\n\\n```\\nif (uri.endsWith(messageEndpoint)) {\\n       setupSessionContext(exchange, chain);\\n       return handleMessageEndpoint(exchange, transportProvider, request);\\n} \\n```\\n\\n```java\\npublic class McpServerPlugin extends AbstractShenyuPlugin {\\n    private Mono<Void> handleMessageEndpoint(final ServerWebExchange exchange,\\n                                             final ShenyuSseServerTransportProvider transportProvider,\\n                                             final ServerRequest request) {\\n        // Handle message requests\\n        return transportProvider.handleMessageEndpoint(request)\\n                .flatMap(result -> {\\n                    return exchange.getResponse()\\n                            .writeWith(Mono.just(exchange.getResponse().bufferFactory().wrap(responseBody.getBytes())));\\n                });\\n    }\\n}\\n```\\n\\n* `handleMessageEndpoint()` method\\n> Called by `McpServerPlugin.handleMessageEndpoint()`, hands over the request to the session for processing\\n\\nThe session\'s `handler()` method performs different actions depending on the message.  \\nFor example, when the method in the message is `\\"tools/call\\"`, the tool invocation handler executes the `call()` method to call the tool.  \\nThe related source is omitted here.\\n\\n```java\\npublic class ShenyuSseServerTransportProvider implements McpServerTransportProvider {\\n    public Mono<MessageHandlingResult> handleMessageEndpoint(final ServerRequest request) {\\n        // Get session\\n        String sessionId = request.queryParam(\\"sessionId\\").get();\\n        McpServerSession session = sessions.get(sessionId);\\n        return request.bodyToMono(String.class)\\n                .flatMap(body -> {\\n                    McpSchema.JSONRPCMessage message = McpSchema.deserializeJsonRpcMessage(objectMapper, body);\\n                    return session.handle(message);\\n                });\\n    }\\n}\\n```\\n\\nAt this point, the Shenyu Mcp Plugin service invocation source code analysis is complete.\\n\\nProcess flow overview  \\n![](/img/activities/code-analysis-mcp-server-plugin/Mcp-server-execute-en.png)\\n\\n### 3. Tool Invocation\\n\\n> If the client sends a message to invoke a tool, the session will use the tool invocation handler to execute the tool\u2019s `call()` method.  \\n> From service registration, we know the tool call actually runs the `call()` method of `ShenyuToolCallback`.\\n\\nTherefore, the tool invocation executes the following:\\n\\n* `call()` method mainly does:\\n\\n1. Gets session id\\n2. Gets `requestTemplate`, the extra configuration provided by Shenyu\\n3. Gets the previously stored Shenyu plugin chain and passes the tool call info to the chain for continued execution\\n4. Asynchronously waits for the tool response\\n\\nAfter the plugin chain completes, the tool call request is actually sent to the service hosting the tool.\\n\\n```java\\npublic class ShenyuToolCallback implements ToolCallback {\\n    @NonNull\\n    @Override\\n    public String call(@NonNull final String input, final ToolContext toolContext) {\\n        // Extract sessionId from MCP request\\n        final McpSyncServerExchange mcpExchange = extractMcpExchange(toolContext);\\n        final String sessionId = extractSessionId(mcpExchange);\\n        // Extract requestTemplate info\\n        final String configStr = extractRequestConfig(shenyuTool);\\n\\n        // Get the previously stored plugin chain by sessionId\\n        final ServerWebExchange originExchange = getOriginExchange(sessionId);\\n        final ShenyuPluginChain chain = getPluginChain(originExchange);\\n        \\n        // Execute the tool call\\n        return executeToolCall(originExchange, chain, sessionId, configStr, input);\\n    }\\n\\n    private String executeToolCall(final ServerWebExchange originExchange,\\n                                   final ShenyuPluginChain chain,\\n                                   final String sessionId,\\n                                   final String configStr,\\n                                   final String input) {\\n\\n        final CompletableFuture<String> responseFuture = new CompletableFuture<>();\\n        final ServerWebExchange decoratedExchange = buildDecoratedExchange(\\n                originExchange, responseFuture, sessionId, configStr, input);\\n        // Execute plugin chain, call the actual tool\\n        chain.execute(decoratedExchange)\\n                .subscribe();\\n\\n        // Wait for response\\n        final String result = responseFuture.get(DEFAULT_TIMEOUT_SECONDS, TimeUnit.SECONDS);\\n        return result;\\n    }\\n}\\n```\\n\\nThis concludes the Shenyu MCP Plugin tool invocation analysis.\\n\\n![](/img/activities/code-analysis-mcp-server-plugin/Mcp-server-tool-call-en.png)\\n\\n---\\n\\n### 4. Summary\\n\\nThis article analyzed the source code from Mcp service registration, through Mcp plugin service invocation, to tool invocation.  \\nThe McpServer plugin makes Shenyu a powerful and centralized McpServer.\\n\\n---"},{"id":"/Plugin-SourceCode-Analysis-Param-Mapping-Plugin","metadata":{"permalink":"/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin.md","source":"@site/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin.md","title":"Code Analysis For Param-Mapping Plugin","description":"Before starting, you can refer to this article to start the gateway","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"Param-Mapping","permalink":"/blog/tags/param-mapping"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":4.72,"hasTruncateMarker":false,"authors":[{"name":"Kunshuai Zhu","title":"Apache ShenYu Contributor","url":"https://github.com/JooKS-me","imageURL":"https://avatars1.githubusercontent.com/u/62384022?v=4"}],"frontMatter":{"title":"Code Analysis For Param-Mapping Plugin","author":"Kunshuai Zhu","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/JooKS-me","author_image_url":"https://avatars1.githubusercontent.com/u/62384022?v=4","tags":["Param-Mapping","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"McpServer Plugin Source Code Analysis","permalink":"/blog/Plugin-SourceCode-Analysis-Mcp-Server-Plugin"},"nextItem":{"title":"Register Center Source Code Analysis of Http Register","permalink":"/blog/RegisterCenter-SourceCode-Analysis-Http-Register"}},"content":"> Before starting, you can refer to [this article](./Start-SourceCode-Analysis-Start-Demo) to start the gateway\\n\\n### Body\\n\\nLet\'s take a look at the structure of this plugin first, as shown in the figure below.\\n\\n![param-mapping-structure](/img/activities/code-analysis-param-mapping-plugin/param-mapping-structure.png)\\n\\nGuess: handler is used for data synchronization; strategy may be adapted to various request bodies, which should be the focus of this plugin; `ParamMappingPlugin` should be the implementation of `ShenyuPlugin`.\\n\\nFirst, take a look at the `ParamMappingPlugin`, the focus is on the override of the `doExecute` method.\\n\\n```java\\npublic Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\\n    ... // judge whether paramMappingHandle is null\\n    // Determine the request body type according to the contentType in the header line\\n    HttpHeaders headers = exchange.getRequest().getHeaders();\\n    MediaType contentType = headers.getContentType();\\n  \\t// *\\n    return match(contentType).apply(exchange, chain, paramMappingHandle);\\n}\\n```\\n\\n- The match method returns the corresponding `Operator` according to contentType\\n\\n  ```java\\n  private Operator match(final MediaType mediaType) {\\n      if (MediaType.APPLICATION_JSON.isCompatibleWith(mediaType)) {\\n          return operatorMap.get(MediaType.APPLICATION_JSON.toString());\\n      } else if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) {\\n          return operatorMap.get(MediaType.APPLICATION_FORM_URLENCODED.toString());\\n      } else {\\n          return operatorMap.get(Constants.DEFAULT);\\n      }\\n  }\\n  ```\\n\\n  As can be seen from the code of the match method, there are currently three types of `DefaultOperator`, `FormDataOperator`, and `JsonOperator`, which support the request body in two formats: `x-www-form-urlencoded` and `json`.\\n\\nSo let\'s take a look at what the above three operators are like.\\n\\n#### 1. DefaultOperator\\n\\nNothing happens, its apply method just continues to execute the plug-in chain, and has no real function. When the request body does not match the Operator, it will be skipped by `DefaultOperator`.\\n\\n#### 2. FormDataOperator\\n\\nThis class is used to process the request body in the format of `x-www-form-urlencoded`.\\n\\nMainly depends on the `apply` method, but it looks a bit strange.\\n\\n```java\\npublic Mono<Void> apply(final ServerWebExchange exchange, final ShenyuPluginChain shenyuPluginChain, final ParamMappingHandle paramMappingHandle) {\\n    return exchange.getFormData()\\n            .switchIfEmpty(Mono.defer(() -> Mono.just(new LinkedMultiValueMap<>())))\\n            .flatMap(multiValueMap -> {\\n                ...\\n            });\\n}\\n```\\n\\nThe code in the ellipsis is the processing of the request body, as follows.\\n\\n```java\\n// judge whether it is empty\\nif (Objects.isNull(multiValueMap) || multiValueMap.isEmpty()) {\\n    return shenyuPluginChain.execute(exchange);\\n}\\n// convert form-data to json\\nString original = GsonUtils.getInstance().toJson(multiValueMap);\\nLOG.info(\\"get from data success data:{}\\", original);\\n// *modify request body*\\nString modify = operation(original, paramMappingHandle);\\nif (StringUtils.isEmpty(modify)) {\\n    return shenyuPluginChain.execute(exchange);\\n}\\n...\\n// Convert the modified json into LinkedMultiValueMap. Pay attention to this line, it will be mentioned later!\\nLinkedMultiValueMap<String, String> modifyMap = GsonUtils.getInstance().toLinkedMultiValueMap(modify);\\n...\\nfinal BodyInserter bodyInserter = BodyInserters.fromValue(modifyMap);\\n...\\n// modify the request body in the exchange, and then continue to execute the plugin chain\\nreturn bodyInserter.insert(cachedBodyOutputMessage, new BodyInserterContext())\\n        .then(Mono.defer(() -> shenyuPluginChain.execute(exchange.mutate()\\n                .request(new ModifyServerHttpRequestDecorator(httpHeaders, exchange.getRequest(), cachedBodyOutputMessage))\\n                .build())\\n        )).onErrorResume((Function<Throwable, Mono<Void>>) throwable -> release(cachedBodyOutputMessage, throwable));\\n```\\n\\n> PS: The omitted part is to set the request first and other operations.\\n\\nThe more important thing above should be the modification request body of the star, that is, the call of the `operation` method. Here, because of the parameter type, the default method of the `Operator` interface will be called first (instead of being overridden by the `FormDataOperator`).\\n\\n```java\\ndefault String operation(final String jsonValue, final ParamMappingHandle paramMappingHandle) {\\n    DocumentContext context = JsonPath.parse(jsonValue);\\n    // call the override operation method and add addParameterKey\\n    operation(context, paramMappingHandle);\\n    // replace the related replacedParameterKey\\n    if (!CollectionUtils.isEmpty(paramMappingHandle.getReplaceParameterKeys())) {\\n        paramMappingHandle.getReplaceParameterKeys().forEach(info -> {\\n            context.renameKey(info.getPath(), info.getKey(), info.getValue());\\n        });\\n    }\\n    // Delete the related removeParameterKey\\n    if (!CollectionUtils.isEmpty(paramMappingHandle.getRemoveParameterKeys())) {\\n        paramMappingHandle.getRemoveParameterKeys().forEach(info -> {\\n            context.delete(info);\\n        });\\n    }\\n    return context.jsonString();\\n}\\n```\\n\\nAfter sorting it out, we can find that the json tool [JsonPath](https://github.com/json-path/JsonPath) imported here makes the processing of the request body much simpler and clearer.\\n\\n**In addition, we can notice that the `FormDataOperator` overrides the `operation(DocumentContext, ParamMappingHandle)` method.**\\n\\n**Why override it?** There is a default method for handling addParameterKey in the interface.\\n\\n```java\\n// Default method in Operator interface\\ndefault void operation(final DocumentContext context, final ParamMappingHandle paramMappingHandle) {\\n    if (!CollectionUtils.isEmpty(paramMappingHandle.getAddParameterKeys())) {\\n        paramMappingHandle.getAddParameterKeys().forEach(info -> {\\n            context.put(info.getPath(), info.getKey(), info.getValue()); //\u4e0d\u540c\u4e4b\u5904\\n        });\\n    }\\n}\\n\\n// method overridden by FormDataOperator\\n@Override\\npublic void operation(final DocumentContext context, final ParamMappingHandle paramMappingHandle) {\\n    if (!CollectionUtils.isEmpty(paramMappingHandle.getAddParameterKeys())) {\\n        paramMappingHandle.getAddParameterKeys().forEach(info -> {\\n            context.put(info.getPath(), info.getKey(), Arrays.asList(info.getValue()));\\n        });\\n    }\\n}\\n```\\n\\nIn fact, there is such a line in `FormDataOperator#apply` (mentioned earlier):\\n`LinkedMultiValueMap<String, String> modifyMap = GsonUtils.getInstance().toLinkedMultiValueMap(modify);`\\n\\nThis line converts the modified json into `LinkedMultiValueMap`, `GsonUtils#toLinkedMultiValueMap` is as follows.\\n\\n```java\\npublic LinkedMultiValueMap<String, String> toLinkedMultiValueMap(final String json) {\\n    return GSON.fromJson(json, new TypeToken<LinkedMultiValueMap<String, String>>() {\\n    }.getType());\\n}\\n```\\n\\nThe attribute `targetMap` in the `LinkedMultiValueMap` class is defined as: `private final Map<K, List<V>> targetMap`\\n\\nTherefore, the value in the json string must be in the form of a list, otherwise Gson will throw a conversion error exception, which is why the `FormDataOperator` must override the operator method.\\n\\n**But why use `LinkedMultiValueMap`?**\\n\\nGo back to the first line `exchange.getFormData` of the `FormDataOperator#apply` method. In SpringMVC, the return value type of `DefaultServerWebExchange#getFormData` is `Mono<MultiValueMap<String, String>>`, and `LinkedMultiValueMap` is a subclass of `MultiValueMap`. And, the `getFormData` method is for the request body in the format of `x-www-form-urlencoded`.\\n\\n![param-mapping-getFormData](/img/activities/code-analysis-param-mapping-plugin/param-mapping-getFormData.png)\\n\\n#### \u4e09\u3001JsonOperator\\n\\nObviously, this class is used to process the request body in Json format.\\n\\n```java\\npublic Mono<Void> apply(final ServerWebExchange exchange, final ShenyuPluginChain shenyuPluginChain, final ParamMappingHandle paramMappingHandle) {\\n    ServerRequest serverRequest = ServerRequest.create(exchange, MESSAGE_READERS);\\n    Mono<String> mono = serverRequest.bodyToMono(String.class).switchIfEmpty(Mono.defer(() -> Mono.just(\\"\\"))).flatMap(originalBody -> {\\n        LOG.info(\\"get body data success data:{}\\", originalBody);\\n        // call the default operation method to modify the request body\\n        String modify = operation(originalBody, paramMappingHandle);\\n        return Mono.just(modify);\\n    });\\n    BodyInserter bodyInserter = BodyInserters.fromPublisher(mono, String.class);\\n    ... //process the header line\\n    CachedBodyOutputMessage outputMessage = new CachedBodyOutputMessage(exchange, headers);\\n    // modify the request body in the exchange, and then continue to execute the plugin chain\\n    return bodyInserter.insert(outputMessage, new BodyInserterContext())\\n            .then(Mono.defer(() -> {\\n                ServerHttpRequestDecorator decorator = new ModifyServerHttpRequestDecorator(headers, exchange.getRequest(), outputMessage);\\n                return shenyuPluginChain.execute(exchange.mutate().request(decorator).build());\\n            })).onErrorResume((Function<Throwable, Mono<Void>>) throwable -> release(outputMessage, throwable));\\n}\\n```\\n\\nThe processing flow of `JsonOperator` is roughly similar to that of `FormDataOperator`.\\n\\n### Conclusion\\n\\nFinally, use a picture to briefly summarize.\\n\\n![param-mapping-summary](/img/activities/code-analysis-param-mapping-plugin/param-mapping-summary.jpg)"},{"id":"/RegisterCenter-SourceCode-Analysis-Http-Register","metadata":{"permalink":"/blog/RegisterCenter-SourceCode-Analysis-Http-Register","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md","source":"@site/blog/RegisterCenter-SourceCode-Analysis-Http-Register.md","title":"Register Center Source Code Analysis of Http Register","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"http","permalink":"/blog/tags/http"},{"label":"register center","permalink":"/blog/tags/register-center"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":28.94,"hasTruncateMarker":false,"authors":[{"name":"midnight2104","title":"Apache ShenYu Committer","url":"https://github.com/midnight2104"}],"frontMatter":{"title":"Register Center Source Code Analysis of Http Register","author":"midnight2104","author_title":"Apache ShenYu Committer","author_url":"https://github.com/midnight2104","tags":["http","register center","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Code Analysis For Param-Mapping Plugin","permalink":"/blog/Plugin-SourceCode-Analysis-Param-Mapping-Plugin"},"nextItem":{"title":"LoadBalancer SPI Source Code Analysis","permalink":"/blog/SPI-SourceCode-Analysis-LoadBalance-SPI"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\n\\nIn `ShenYu` gateway, the registration center is used to register the client information to `shenyu-admin`, `admin` then synchronizes this information to the gateway through data synchronization, and the gateway completes traffic filtering through these data. The client information mainly includes `interface information` and `URI information`.\\n\\n> This article is based on `shenyu-2.5.0` version for source code analysis, please refer to [Client Access Principles](https://shenyu.apache.org/docs/design/register-center-design) for the introduction of the official website.\\n\\n### 1. Registration Center Principle\\n\\nWhen the client starts, it reads the interface information and `uri information`, and sends the data to `shenyu-admin` by the specified registration type.\\n\\n![](/img/activities/code-analysis-http-register/register-center-en.png)\\n\\n\\nThe registration center in the figure requires the user to specify which registration type to use. `ShenYu` currently supports `Http`, `Zookeeper`, `Etcd`, `Consul` and `Nacos` for registration. Please refer to [Client Access Configuration](https://shenyu.apache.org/docs/user-guide/property-config/register-center-access) for details on how to configure them.\\n\\n\\n`ShenYu` introduces `Disruptor` in the principle design of the registration center, in which the `Disruptor` queue plays a role in decoupling data and operations, which is conducive to expansion. If too many registration requests lead to registration exceptions, it also has a data buffering role.\\n\\n\\n![](/img/activities/code-analysis-http-register/shenyu-register-center-en.png)\\n\\n\\nAs shown in the figure, the registration center is divided into two parts, one is the registration center client `register-client`, the load processing client data reading. The other is the registration center server `register-server`, which is loaded to handle the server side (that is `shenyu-admin`) data writing. Data is sent and received by specifying the registration type.\\n\\n- Client: Usually it is a microservice, which can be `springmvc`, `spring-cloud`, `dubbo`, `grpc`, etc.\\n- `register-client`: register the central client, read the client interface and `uri` information.\\n- `Disruptor`: decoupling data from operations, data buffering role.\\n- `register-server`: registry server, here is `shenyu-admin`, receive data, write to database, send data synchronization events.\\n- registration-type: specify the registration type, complete data registration, currently supports `Http`, `Zookeeper`, `Etcd`, `Consul` and `Nacos`.\\n\\n\\nThis article analyzes the use of `Http` for registration, so the specific processing flow is as follows.\\n\\n\\n![](/img/activities/code-analysis-http-register/shenyu-register-center-http-en.png)\\n\\n\\nOn the client side, after the data is out of the queue, the data is transferred via `http` and on the server side, the corresponding interface is provided to receive the data and then write it to the queue.\\n\\n### 2. Client Registration Process\\n\\nWhen the client starts, it reads the attribute information according to the relevant configuration, and then writes it to the queue. Let\'s take the official [shenyu-examples-http](https://github.com/apache/shenyu/tree/master/shenyu-examples/shenyu-examples-http) as an example and start the source code analysis . The official example is a microservice built by `springboot`. For the configuration of the registration center, please refer to the official website [client access configuration](https://shenyu.apache.org/docs/user-guide/property-config/register-center-access) .\\n\\n#### 2.1 Load configuration, read properties\\n\\nLet\'s start with a diagram that ties together the initialization process of the registry client.\\n\\n![](/img/activities/code-analysis-http-register/client-register-init-en.png)\\n\\nWe are analyzing registration by means of `http`, so the following configuration is required.\\n\\n```yaml\\nshenyu:\\n  register:\\n    registerType: http\\n    serverLists: http://localhost:9095\\n  props:\\n    username: admin\\n    password: 123456\\n  client:\\n    http:\\n        props:\\n          contextPath: /http\\n          appName: http\\n          port: 8189  \\n          isFull: false\\n```\\n\\nEach attribute indicates the following meaning.\\n\\n- `registerType`: the service registration type, fill in `http`.\\n- `serverList`: The address of the `Shenyu-Admin` project to fill in for the `http` registration type, note the addition of `http://` and separate multiple addresses with English commas.\\n- `username`: The username of the `Shenyu-Admin`\\n- `password`: The password of the `Shenyu-Admin`\\n- `port`: the start port of your project, currently `springmvc/tars/grpc` needs to be filled in.\\n- `contextPath`: the routing prefix for your `mvc` project in `shenyu` gateway, such as `/order`, `/product`, etc. The gateway will route according to your prefix.\\n- `appName`: the name of your application, if not configured, it will take the value of `spring.application.name` by default.\\n- `isFull`: set `true` to proxy your entire service, `false` to proxy one of your `controllers`; currently applies to `springmvc/springcloud`.\\n\\nAfter the project starts, it will first load the configuration file, read the property information and generate the corresponding `Bean`.\\n\\nThe first configuration file read is `ShenyuSpringMvcClientConfiguration`, which is the `http` registration configuration class for the `shenyu` client, indicated by `@Configuration` which is a configuration class, and by `@ImportAutoConfiguration` which is a configuration class. to introduce other configuration classes. Create `SpringMvcClientEventListener`, which mainly handles metadata and `URI` information.\\n\\n```java\\n/**\\n * Shenyu SpringMvc Client Configuration\\n */\\n@Configuration\\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\\n@ConditionalOnProperty(value = \\"shenyu.register.enabled\\", matchIfMissing = true, havingValue = \\"true\\")\\npublic class ShenyuSpringMvcClientConfiguration {\\n\\n    // create SpringMvcClientEventListener to handle metadata and URI\\n    @Bean\\n    public SpringMvcClientEventListener springHttpClientEventListener(final ShenyuClientConfig clientConfig,\\n                                                                      final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        return new SpringMvcClientEventListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);\\n    }\\n}\\n\\n```\\n\\n`ShenyuClientCommonBeanConfiguration` is a `shenyu` client common configuration class that will create the `bean` common to the registry client.\\n\\n- Create `ShenyuClientRegisterRepository`, which is created by factory class.\\n- Create `ShenyuRegisterCenterConfig`, which reads the `shenyu.register` property configuration.\\n- Create `ShenyuClientConfig`, read the `shenyu.client` property configuration.\\n\\n```java\\n\\n/**\\n * Shenyu Client Common Bean Configuration\\n */\\n@Configuration\\npublic class ShenyuClientCommonBeanConfiguration {\\n    \\n   // create ShenyuClientRegisterRepository by factory \\n    @Bean\\n    public ShenyuClientRegisterRepository shenyuClientRegisterRepository(final ShenyuRegisterCenterConfig config) {\\n        return ShenyuClientRegisterRepositoryFactory.newInstance(config);\\n    }\\n    \\n\\t// create ShenyuRegisterCenterConfig to read shenyu.register properties\\n    @Bean\\n    @ConfigurationProperties(prefix = \\"shenyu.register\\")\\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\\n        return new ShenyuRegisterCenterConfig();\\n    }\\n    \\n  // create ShenyuClientConfig to read shenyu.client properties\\n    @Bean\\n    @ConfigurationProperties(prefix = \\"shenyu\\")\\n    public ShenyuClientConfig shenyuClientConfig() {\\n        return new ShenyuClientConfig();\\n    }\\n}\\n\\n```\\n\\n#### 2.2 HttpClientRegisterRepository\\n\\nThe `ShenyuClientRegisterRepository` generated in the configuration file above is a concrete implementation of the client registration, which is an interface with the following implementation class.\\n\\n![](/img/activities/code-analysis-http-register/shenyu-client-register-repository.png)\\n\\n\\n- `HttpClientRegisterRepository`: registration via `http`.\\n- `ConsulClientRegisterRepository`: registration via `Consul`.\\n- `EtcdClientRegisterRepository`: registration via `Etcd`; `EtcdClientRegisterRepository`: registration via `Etcd`.\\n- `NacosClientRegisterRepository`: registration via `nacos`; `NacosClientRegisterRepository`: registration via `nacos`.\\n- `ZookeeperClientRegisterRepository`: registration through `Zookeeper`.\\n\\nThe specific way which is achieved by loading through `SPI`, the implementation logic is as follows.\\n\\n\\n```java\\n\\n/**\\n * load ShenyuClientRegisterRepository\\n */\\npublic final class ShenyuClientRegisterRepositoryFactory {\\n    \\n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\\n    \\n    /**\\n     * create ShenyuClientRegisterRepository\\n     */\\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\\n            // Loading by means of SPI, type determined by registerType\\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\\n            //init ShenyuClientRegisterRepository\\n            result.init(shenyuRegisterCenterConfig);\\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\\n            return result;\\n        }\\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\\n    }\\n}\\n```\\n\\nThe load type is specified by `registerType`, which is the type we specify in the configuration file at\\n\\n```yaml\\nshenyu:\\n  register:\\n    registerType: http\\n    serverLists: http://localhost:9095\\n```\\n\\nWe specified `http`, so it will go to load `HttpClientRegisterRepository`. After the object is successfully created, the initialization method `init()` is executed as follows.\\n\\n```java\\n@Join\\npublic class HttpClientRegisterRepository implements ShenyuClientRegisterRepository {\\n\\n    @Override\\n    public void init(final ShenyuRegisterCenterConfig config) {\\n        this.username = config.getProps().getProperty(Constants.USER_NAME);\\n        this.password = config.getProps().getProperty(Constants.PASS_WORD);\\n        this.serverList = Lists.newArrayList(Splitter.on(\\",\\").split(config.getServerLists()));\\n        this.setAccessToken();\\n    }\\n  \\n  // ......\\n}\\n```\\n\\nRead `username`, `password` and `serverLists` from the configuration file, the username, password and address of `sheenyu-admin`, in preparation for subsequent data sending. The class annotation `@Join` is used for `SPI` loading.\\n\\n\\n> `SPI`, known as `Service Provider Interface`, is a service provider discovery feature built into the `JDK`, a mechanism for dynamic replacement discovery.\\n>\\n> [shenyu-spi](https://github.com/apache/shenyu/tree/master/shenyu-spi) is a custom `SPI` extension implementation for the `Apache ShenYu` gateway, designed and implemented with reference to Dubbo [SPI extension implementation](https://dubbo.apache.org/zh/docs/v2.7/dev/impls/).\\n\\n\\n#### 2.3 SpringMvcClientEventListener\\n\\nCreate `SpringMvcClientEventListener`, which is responsible for the construction and registration of client-side metadata and `URI` data, and its creation is done in the configuration file.\\n\\n\\n```java\\n@Configuration\\n@ImportAutoConfiguration(ShenyuClientCommonBeanConfiguration.class)\\npublic class ShenyuSpringMvcClientConfiguration {\\n     // ......\\n    \\n    // create SpringMvcClientEventListener\\n    @Bean\\n    public SpringMvcClientEventListener springHttpClientEventListener(final ShenyuClientConfig clientConfig,\\n                                                                      final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        return new SpringMvcClientEventListener(clientConfig.getClient().get(RpcTypeEnum.HTTP.getName()), shenyuClientRegisterRepository);\\n    }\\n}\\n```\\n\\n\\n`SpringMvcClientEventListener` implements the `AbstractContextRefreshedEventListener`\\n\\n![](/img/activities/code-analysis-http-register/shenyu-client-event-listener.png)\\n\\nThe `AbstractContextRefreshedEventListener` is an abstract class. it implements the `ApplicationListener` interface and overrides the `onApplicationEvent()` method, which is executed when a Spring event occurs. It has several implementation classes, which support different kind of `RPC` styles.\\n\\n- `AlibabaDubboServiceBeanListener`\uff1ahandles `Alibaba Dubbo` protocol.\\n- `ApacheDubboServiceBeanListener`\uff1ahandles `Apache Dubbo` protocol.\\n- `GrpcClientEventListener`\uff1ahandles `grpc` protocol.\\n- `MotanServiceEventListener`\uff1ahandles `Motan` protocol.\\n- `SofaServiceEventListener`\uff1ahandles `Sofa` protocol.\\n- `SpringMvcClientEventListener`\uff1ahandles `http` protocol.\\n- `SpringWebSocketClientEventListener`\uff1ahandles `Websocket` protocol.\\n- `TarsServiceBeanEventListener`\uff1ahandles `Tars` protocol.\\n\\n```java\\npublic abstract class AbstractContextRefreshedEventListener<T, A extends Annotation> implements ApplicationListener<ContextRefreshedEvent> {\\n\\n    //......\\n\\n    // Instantiation is done through the constructor\\n    public AbstractContextRefreshedEventListener(final PropertiesConfig clientConfig,\\n                                                 final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        // read shenyu.client.http properties\\n        Properties props = clientConfig.getProps();\\n        // appName \\n        this.appName = props.getProperty(ShenyuClientConstants.APP_NAME);\\n        // contextPath\\n        this.contextPath = Optional.ofNullable(props.getProperty(ShenyuClientConstants.CONTEXT_PATH)).map(UriUtils::repairData).orElse(\\"\\");\\n        if (StringUtils.isBlank(appName) && StringUtils.isBlank(contextPath)) {\\n            String errorMsg = \\"client register param must config the appName or contextPath\\";\\n            LOG.error(errorMsg);\\n            throw new ShenyuClientIllegalArgumentException(errorMsg);\\n        }\\n        this.ipAndPort = props.getProperty(ShenyuClientConstants.IP_PORT);\\n        // host\\n        this.host = props.getProperty(ShenyuClientConstants.HOST);\\n        // port\\n        this.port = props.getProperty(ShenyuClientConstants.PORT);\\n        // publish event\\n        publisher.start(shenyuClientRegisterRepository);\\n    }\\n\\n    // This method is executed when a context refresh event(ContextRefreshedEvent), occurs\\n    @Override\\n    public void onApplicationEvent(@NonNull final ContextRefreshedEvent event) {\\n        // The contents of the method are guaranteed to be executed only once\\n        if (!registered.compareAndSet(false, true)) {\\n            return;\\n        }\\n        final ApplicationContext context = event.getApplicationContext();\\n        // get the specific beans \\n        Map<String, T> beans = getBeans(context);\\n        if (MapUtils.isEmpty(beans)) {\\n            return;\\n        }\\n        // build URI data and register it\\n        publisher.publishEvent(buildURIRegisterDTO(context, beans));\\n        // build metadata and register it\\n        beans.forEach(this::handle);\\n    }\\n    \\n    @SuppressWarnings(\\"all\\")\\n    protected abstract URIRegisterDTO buildURIRegisterDTO(ApplicationContext context,\\n                                                          Map<String, T> beans);\\n\\n\\n    protected void handle(final String beanName, final T bean) {\\n        Class<?> clazz = getCorrectedClass(bean);\\n        final A beanShenyuClient = AnnotatedElementUtils.findMergedAnnotation(clazz, getAnnotationType());\\n        final String superPath = buildApiSuperPath(clazz, beanShenyuClient);\\n        if (Objects.nonNull(beanShenyuClient) && superPath.contains(\\"*\\")) {\\n            handleClass(clazz, bean, beanShenyuClient, superPath);\\n            return;\\n        }\\n        final Method[] methods = ReflectionUtils.getUniqueDeclaredMethods(clazz);\\n        for (Method method : methods) {\\n            handleMethod(bean, clazz, beanShenyuClient, method, superPath);\\n        }\\n    }\\n\\n    // default implementation. build URI data and register it\\n    protected void handleClass(final Class<?> clazz,\\n                               final T bean,\\n                               @NonNull final A beanShenyuClient,\\n                               final String superPath) {\\n        publisher.publishEvent(buildMetaDataDTO(bean, beanShenyuClient, pathJoin(contextPath, superPath), clazz, null));\\n    }\\n\\n    // default implementation. build metadata and register it\\n    protected void handleMethod(final T bean,\\n                                final Class<?> clazz,\\n                                @Nullable final A beanShenyuClient,\\n                                final Method method,\\n                                final String superPath) {\\n        // get the annotation\\n        A methodShenyuClient = AnnotatedElementUtils.findMergedAnnotation(method, getAnnotationType());\\n        if (Objects.nonNull(methodShenyuClient)) {\\n            // \u6784\u5efa\u5143\u6570\u636e\uff0c\u53d1\u9001\u6ce8\u518c\u4e8b\u4ef6\\n            publisher.publishEvent(buildMetaDataDTO(bean, methodShenyuClient, buildApiPath(method, superPath, methodShenyuClient), clazz, method));\\n        }\\n    }\\n    \\n    protected abstract MetaDataRegisterDTO buildMetaDataDTO(T bean,\\n                                                            @NonNull A shenyuClient,\\n                                                            String path,\\n                                                            Class<?> clazz,\\n                                                            Method method);\\n}\\n\\n```\\n\\nIn the constructor, the main purpose is to read the property information and then perform the checksum.\\n\\n```yaml\\nshenyu:\\n  client:\\n    http:\\n      props:\\n        contextPath: /http\\n        appName: http\\n        port: 8189\\n        isFull: false\\n```\\n\\nFinally, publisher.start() is executed to start event publishing and prepare for registration.\\n\\nShenyuClientRegisterEventPublisher is implemented via singleton pattern, mainly generating metadata and URI subscribers (subsequently used for data publishing), and then starting the Disruptor queue. A common method publishEvent() is provided to publish events and send data to the Disruptor queue.\\n\\n```java\\n\\npublic class ShenyuClientRegisterEventPublisher {\\n    \\n    private static final ShenyuClientRegisterEventPublisher INSTANCE = new ShenyuClientRegisterEventPublisher();\\n\\n    private DisruptorProviderManage<DataTypeParent> providerManage;\\n    \\n    public static ShenyuClientRegisterEventPublisher getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n    public void start(final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        RegisterClientExecutorFactory factory = new RegisterClientExecutorFactory();\\n        factory.addSubscribers(new ShenyuClientMetadataExecutorSubscriber(shenyuClientRegisterRepository));\\n        factory.addSubscribers(new ShenyuClientURIExecutorSubscriber(shenyuClientRegisterRepository));\\n        providerManage = new DisruptorProviderManage(factory);\\n        providerManage.startup();\\n    }\\n    \\n    public <T> void publishEvent(final DataTypeParent data) {\\n        DisruptorProvider<DataTypeParent> provider = providerManage.getProvider();\\n        provider.onData(data);\\n    }\\n}\\n```\\n\\nThe logic of the constructor of `AbstractContextRefreshedEventListener` is analyzed, it mainly reads the property configuration, creates metadata and URI subscribers, and starts the Disruptor queue.\\n\\nThe `onApplicationEvent()` method is executed when a `Spring` event occurs, the parameter here is `ContextRefreshedEvent`, which means the context refresh event. \\n\\n\\n> `ContextRefreshedEvent` is a `Spring` built-in event. It is fired when the `ApplicationContext` is initialized or refreshed. This can also happen in the `ConfigurableApplicationContext` interface using the `refresh()` method. Initialization here means that all `Bean`s have been successfully loaded, post-processing `Bean`s have been detected and activated, all `Singleton Bean`s have been pre-instantiated, and the `ApplicationContext` container is ready to be used.\\n\\n\\n- `SpringMvcClientEventListener`: the `http` implementation of `AbstractContextRefreshedEventListener`:\\n\\n```java\\npublic class SpringMvcClientEventListener extends AbstractContextRefreshedEventListener<Object, ShenyuSpringMvcClient> {\\n    \\n    private final List<Class<? extends Annotation>> mappingAnnotation = new ArrayList<>(3);\\n    \\n    private final Boolean isFull;\\n    \\n    private final String protocol;\\n    \\n    // \u6784\u9020\u51fd\u6570\\n    public SpringMvcClientEventListener(final PropertiesConfig clientConfig,\\n                                        final ShenyuClientRegisterRepository shenyuClientRegisterRepository) {\\n        super(clientConfig, shenyuClientRegisterRepository);\\n        Properties props = clientConfig.getProps();\\n        // get isFull\\n        this.isFull = Boolean.parseBoolean(props.getProperty(ShenyuClientConstants.IS_FULL, Boolean.FALSE.toString()));\\n        // http protocol\\n        this.protocol = props.getProperty(ShenyuClientConstants.PROTOCOL, ShenyuClientConstants.HTTP);\\n        mappingAnnotation.add(ShenyuSpringMvcClient.class);\\n        mappingAnnotation.add(RequestMapping.class);\\n    }\\n    \\n    @Override\\n    protected Map<String, Object> getBeans(final ApplicationContext context) {\\n        // Configuration attribute, if isFull=true, means register the whole microservice\\n        if (Boolean.TRUE.equals(isFull)) {\\n            getPublisher().publishEvent(MetaDataRegisterDTO.builder()\\n                    .contextPath(getContextPath())\\n                    .appName(getAppName())\\n                    .path(PathUtils.decoratorPathWithSlash(getContextPath()))\\n                    .rpcType(RpcTypeEnum.HTTP.getName())\\n                    .enabled(true)\\n                    .ruleName(getContextPath())\\n                    .build());\\n            return null;\\n        }\\n        // get bean with Controller annotation\\n        return context.getBeansWithAnnotation(Controller.class);\\n    }\\n    \\n    @Override\\n    protected URIRegisterDTO buildURIRegisterDTO(final ApplicationContext context,\\n                                                 final Map<String, Object> beans) {\\n        // ...\\n    }\\n    \\n    @Override\\n    protected String buildApiSuperPath(final Class<?> clazz, @Nullable final ShenyuSpringMvcClient beanShenyuClient) {\\n        if (Objects.nonNull(beanShenyuClient) && StringUtils.isNotBlank(beanShenyuClient.path())) {\\n            return beanShenyuClient.path();\\n        }\\n        RequestMapping requestMapping = AnnotationUtils.findAnnotation(clazz, RequestMapping.class);\\n        // Only the first path is supported temporarily\\n        if (Objects.nonNull(requestMapping) && ArrayUtils.isNotEmpty(requestMapping.path()) && StringUtils.isNotBlank(requestMapping.path()[0])) {\\n            return requestMapping.path()[0];\\n        }\\n        return \\"\\";\\n    }\\n    \\n    @Override\\n    protected Class<ShenyuSpringMvcClient> getAnnotationType() {\\n        return ShenyuSpringMvcClient.class;\\n    }\\n    \\n    @Override\\n    protected void handleMethod(final Object bean, final Class<?> clazz,\\n                                @Nullable final ShenyuSpringMvcClient beanShenyuClient,\\n                                final Method method, final String superPath) {\\n        // get RequestMapping annotation\\n        final RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(method, RequestMapping.class);\\n        // get ShenyuSpringMvcClient annotation\\n        ShenyuSpringMvcClient methodShenyuClient = AnnotatedElementUtils.findMergedAnnotation(method, ShenyuSpringMvcClient.class);\\n        methodShenyuClient = Objects.isNull(methodShenyuClient) ? beanShenyuClient : methodShenyuClient;\\n        // the result of ReflectionUtils#getUniqueDeclaredMethods contains method such as hashCode, wait, toSting\\n        // add Objects.nonNull(requestMapping) to make sure not register wrong method\\n        if (Objects.nonNull(methodShenyuClient) && Objects.nonNull(requestMapping)) {\\n            getPublisher().publishEvent(buildMetaDataDTO(bean, methodShenyuClient, buildApiPath(method, superPath, methodShenyuClient), clazz, method));\\n        }\\n    }\\n    \\n    //...\\n    \\n    // \u6784\u9020\u5143\u6570\u636e\\n    @Override\\n    protected MetaDataRegisterDTO buildMetaDataDTO(final Object bean,\\n                                                   @NonNull final ShenyuSpringMvcClient shenyuClient,\\n                                                   final String path, final Class<?> clazz,\\n                                                   final Method method) {\\n        //...\\n    }\\n}\\n```\\n\\nThe registration logic is done through `publisher.publishEvent()`. \\n\\nThe `Controller` annotation and the `RequestMapping` annotation are provided by `Spring`, which you should be familiar with, so I won\'t go into details. The `ShenyuSpringMvcClient` annotation is provided by `Apache ShenYu` to register the `SpringMvc` client, which is defined as follows.\\n\\n```java\\n\\n/**\\n * ShenyuSpringMvcClient\\n */\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target({ElementType.TYPE, ElementType.METHOD})\\npublic @interface ShenyuSpringMvcClient {\\n\\n    // path\\n    @AliasFor(attribute = \\"path\\")\\n    String value() default \\"\\";\\n    \\n    // path\\n    @AliasFor(attribute = \\"value\\")\\n    String path();\\n    \\n    // ruleName\\n    String ruleName() default \\"\\";\\n    \\n    // desc info\\n    String desc() default \\"\\";\\n\\n    // enabled\\n    boolean enabled() default true;\\n    \\n    // register MetaData \\n    boolean  registerMetaData() default false;\\n}\\n\\n```\\n\\nIt is used as follows.\\n\\n- register the entire interface\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/test\\")\\n@ShenyuSpringMvcClient(path = \\"/test/**\\")  // register the entire interface\\npublic class HttpTestController {\\n    //......\\n}\\n```\\n\\n- register current method\\n\\n```java\\n@RestController\\n@RequestMapping(\\"/order\\")\\n@ShenyuSpringMvcClient(path = \\"/order\\")\\npublic class OrderController {\\n\\n    /**\\n     * Save order dto.\\n     *\\n     * @param orderDTO the order dto\\n     * @return the order dto\\n     */\\n    @PostMapping(\\"/save\\")\\n    @ShenyuSpringMvcClient(path = \\"/save\\", desc = \\"Save order\\") // register current method\\n    public OrderDTO save(@RequestBody final OrderDTO orderDTO) {\\n        orderDTO.setName(\\"hello world save order\\");\\n        return orderDTO;\\n    }\\n```\\n\\n\\n\\n- publisher.publishEvent()\\n\\nThis method sends the data to the `Disruptor` queue. More details about the `Disruptor` queue are not described here, which does not affect the flow of analyzing the registration.\\n\\nWhen the data is sent, the consumers of the `Disruptor` queue will process the data for consumption.\\n\\nThis method sends the data to the `Disruptor` queue. More details about the `Disruptor` queue are not described here, which does not affect the flow of analyzing the registration.\\n\\n\\n\\n- QueueConsumer\\n\\n`QueueConsumer` is a consumer that implements the `WorkHandler` interface, which is created in the `providerManage.startup()` logic. The `WorkHandler` interface is the data consumption interface for `Disruptor`, and the only method is `onEvent()`.\\n\\n```java\\npackage com.lmax.disruptor;\\n\\npublic interface WorkHandler<T> {\\n    void onEvent(T event) throws Exception;\\n}\\n```\\n\\nThe `QueueConsumer` overrides the `onEvent()` method, and the main logic is to generate the consumption task and then go to the thread pool to execute it.\\n\\n```java\\n\\n/**\\n * \\n * QueueConsumer\\n */\\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\\n    \\n\\t// ......\\n\\n    @Override\\n    public void onEvent(final DataEvent<T> t) {\\n        if (t != null) {\\n            // Use different thread pools based on DataEvent type\\n            ThreadPoolExecutor executor = orderly(t);\\n            // create queue consumption tasks via factory\\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\\n            // set data\\n            queueConsumerExecutor.setData(t.getData());\\n            // help gc\\n            t.setData(null);\\n            // put in the thread pool to execute the consumption task\\n            executor.execute(queueConsumerExecutor);\\n        }\\n    }\\n}\\n```\\n\\n`QueueConsumerExecutor` is the task that is executed in the thread pool, it implements the `Runnable` interface, and there are two specific implementation classes.\\n\\n- `RegisterClientConsumerExecutor`\uff1athe client-side consumer executor.\\n- `RegisterServerConsumerExecutor`\uff1aserver-side consumer executor.\\n\\nAs the name implies, one is responsible for handling client-side tasks, and one is responsible for handling server-side tasks (the server side is `admin`, which is analyzed below).\\n\\n![](/img/activities/code-analysis-http-register/consumer-executor.png)\\n\\n\\n- RegisterClientConsumerExecutor\\n\\nThe logic of the rewritten `run()` is as follows.\\n\\n```java\\n\\npublic final class RegisterClientConsumerExecutor<T extends DataTypeParent> extends QueueConsumerExecutor<T> {\\n    \\n\\t//...... \\n\\n    @Override\\n    public void run() {\\n        // get data\\n        final T data = getData();\\n        // call the appropriate processor for processing according to the data type\\n        subscribers.get(data.getType()).executor(Lists.newArrayList(data));\\n    }\\n    \\n}\\n```\\n\\nDifferent processors are called to perform the corresponding tasks based on different data types. There are two types of data, one is metadata, which records the client registration information. One is the `URI` data, which records the client service information.\\n\\n```java\\npublic enum DataType {\\n   \\n    META_DATA,\\n    \\n    URI,\\n}\\n```\\n\\n- ExecutorSubscriber#executor()\\n\\nThe actuator subscribers are divided into two categories, one that handles metadata and one that handles `URIs`. There are two on the client side and two on the server side, so there are four in total.\\n\\n![](/img/activities/code-analysis-http-register/executor-subscriber.png)\\n\\nHere is the registration metadata information, so the execution class is `ShenyuClientMetadataExecutorSubscriber`.\\n\\n\\n- ShenyuClientMetadataExecutorSubscriber#executor()\\n\\nThe metadata processing logic on the client side is: iterate through the metadata information and call the interface method `persistInterface()` to finish publishing the data.\\n\\n```java\\npublic class ShenyuClientMetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\\n   \\n    //......\\n    \\n    @Override\\n    public DataType getType() {\\n        return DataType.META_DATA;\\n    }\\n    \\n    @Override\\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\\n        for (MetaDataRegisterDTO metaDataRegisterDTO : metaDataRegisterDTOList) {\\n            // call the interface method persistInterface() to finish publishing the data\\n            shenyuClientRegisterRepository.persistInterface(metaDataRegisterDTO);\\n        }\\n    }\\n}\\n```\\n\\nThe two registration interfaces get the data well and call the `publish()` method to publish the data to the `Disruptor` queue.\\n\\n- `ShenyuServerRegisterRepository`\\n\\nThe `ShenyuServerRegisterRepository` interface is a service registration interface, which has five implementation classes, indicating five types of registration.\\n\\n- `ConsulServerRegisterRepository`: registration is achieved through `Consul`;\\n- `EtcdServerRegisterRepository`: registration through `Etcd`.\\n- `NacosServerRegisterRepository`: registration through `Nacos`.\\n- `ShenyuHttpRegistryController`: registration via `Http`; `ShenyuHttpRegistryController`: registration via `Http`.\\n- `ZookeeperServerRegisterRepository`: registration through `Zookeeper`.\\n\\n\\n![](/img/activities/code-analysis-http-register/client-register-repository.png)\\n\\n\\nAs you can see from the diagram, the loading of the registry is done by means of SPI. This was mentioned earlier, and the specific class loading is done in the client-side generic configuration file by specifying the properties in the configuration file.\\n\\n```java\\n\\n/**\\n * load ShenyuClientRegisterRepository\\n */\\npublic final class ShenyuClientRegisterRepositoryFactory {\\n    \\n    private static final Map<String, ShenyuClientRegisterRepository> REPOSITORY_MAP = new ConcurrentHashMap<>();\\n    \\n    /**\\n     * create ShenyuClientRegisterRepository\\n     */\\n    public static ShenyuClientRegisterRepository newInstance(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig) {\\n        if (!REPOSITORY_MAP.containsKey(shenyuRegisterCenterConfig.getRegisterType())) {\\n            // loading by means of SPI, type determined by registerType\\n            ShenyuClientRegisterRepository result = ExtensionLoader.getExtensionLoader(ShenyuClientRegisterRepository.class).getJoin(shenyuRegisterCenterConfig.getRegisterType());\\n            // perform initialization operations\\n            result.init(shenyuRegisterCenterConfig);\\n            ShenyuClientShutdownHook.set(result, shenyuRegisterCenterConfig.getProps());\\n            REPOSITORY_MAP.put(shenyuRegisterCenterConfig.getRegisterType(), result);\\n            return result;\\n        }\\n        return REPOSITORY_MAP.get(shenyuRegisterCenterConfig.getRegisterType());\\n    }\\n}\\n```\\n\\nThe source code analysis in this article is based on the Http way of registration, so we first analyze the HttpClientRegisterRepository, and the other registration methods will be analyzed afterwards.\\n\\nRegistration by way of `http` is very simple, it is to call the tool class to send http requests. The registration metadata and URI are both called by the same method `doRegister()`, specifying the interface and type.\\n\\n- `Constants.URI_PATH` = `/shenyu-client/register-metadata`: the interface provided by the server for registering metadata.\\n- `Constants.META_PATH` = `/shenyu-client/register-uri`: Server-side interface for registering URIs.\\n\\n\\n```java\\n@Join\\npublic class HttpClientRegisterRepository extends FailbackRegistryRepository {\\n\\n    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientRegisterRepository.class);\\n\\n    private static URIRegisterDTO uriRegisterDTO;\\n\\n    private String username;\\n\\n    private String password;\\n\\n    private List<String> serverList;\\n\\n    private String accessToken;\\n    \\n    public HttpClientRegisterRepository() {\\n    }\\n    \\n    public HttpClientRegisterRepository(final ShenyuRegisterCenterConfig config) {\\n        init(config);\\n    }\\n\\n    @Override\\n    public void init(final ShenyuRegisterCenterConfig config) {\\n        // admin username\\n        this.username = config.getProps().getProperty(Constants.USER_NAME);\\n        // admin paaword\\n        this.password = config.getProps().getProperty(Constants.PASS_WORD);\\n        // admin server address\\n        this.serverList = Lists.newArrayList(Splitter.on(\\",\\").split(config.getServerLists()));\\n        // set access token\\n        this.setAccessToken();\\n    }\\n\\n    /**\\n     * Persist uri.\\n     *\\n     * @param registerDTO the register dto\\n     */\\n    @Override\\n    public void doPersistURI(final URIRegisterDTO registerDTO) {\\n        if (RuntimeUtils.listenByOther(registerDTO.getPort())) {\\n            return;\\n        }\\n        doRegister(registerDTO, Constants.URI_PATH, Constants.URI);\\n        uriRegisterDTO = registerDTO;\\n    }\\n\\n    @Override\\n    public void doPersistInterface(final MetaDataRegisterDTO metadata) {\\n        doRegister(metadata, Constants.META_PATH, Constants.META_TYPE);\\n    }\\n\\n    @Override\\n    public void close() {\\n        if (uriRegisterDTO != null) {\\n            uriRegisterDTO.setEventType(EventType.DELETED);\\n            doRegister(uriRegisterDTO, Constants.URI_PATH, Constants.URI);\\n        }\\n    }\\n\\n    private void setAccessToken() {\\n        for (String server : serverList) {\\n            try {\\n                Optional<?> login = RegisterUtils.doLogin(username, password, server.concat(Constants.LOGIN_PATH));\\n                login.ifPresent(v -> this.accessToken = String.valueOf(v));\\n            } catch (Exception e) {\\n                LOGGER.error(\\"Login admin url :{} is fail, will retry. cause: {} \\", server, e.getMessage());\\n            }\\n        }\\n    }\\n\\n    private <T> void doRegister(final T t, final String path, final String type) {\\n        int i = 0;\\n        // iterate through the list of admin services (admin may be clustered)\\n        for (String server : serverList) {\\n            i++;\\n            String concat = server.concat(path);\\n            try {\\n                // \u8bbe\u7f6e\u8bbf\u95eetoken\\n                if (StringUtils.isBlank(accessToken)) {\\n                    this.setAccessToken();\\n                    if (StringUtils.isBlank(accessToken)) {\\n                        throw new NullPointerException(\\"accessToken is null\\");\\n                    }\\n                }\\n                // calling the tool class to send http requests\\n                RegisterUtils.doRegister(GsonUtils.getInstance().toJson(t), concat, type, accessToken);\\n                return;\\n            } catch (Exception e) {\\n                LOGGER.error(\\"Register admin url :{} is fail, will retry. cause:{}\\", server, e.getMessage());\\n                if (i == serverList.size()) {\\n                    throw new RuntimeException(e);\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\nSerialize the data and send it via OkHttp.\\n\\n```java\\n\\npublic final class RegisterUtils {\\n   \\n   //...... \\n\\n    // Sending data via OkHttp\\n    public static void doRegister(final String json, final String url, final String type) throws IOException {\\n        if (!StringUtils.hasLength(accessToken)) {\\n            LOGGER.error(\\"{} client register error accessToken is null, please check the config : {} \\", type, json);\\n            return;\\n        }\\n        Headers headers = new Headers.Builder().add(Constants.X_ACCESS_TOKEN, accessToken).build();\\n        String result = OkHttpTools.getInstance().post(url, json, headers);\\n        if (Objects.equals(SUCCESS, result)) {\\n            LOGGER.info(\\"{} client register success: {} \\", type, json);\\n        } else {\\n            LOGGER.error(\\"{} client register error: {} \\", type, json);\\n        }\\n    }\\n}\\n```\\n\\nAt this point, the logic of the client registering metadata by means of `http` is finished. To summarize: construct metadata by reading custom annotation information, send the data to the `Disruptor` queue, then consume the data from the queue, put the consumer into the thread pool to execute, and finally send an `http` request to the `admin`.\\n\\nSimilarly, `ShenyuClientURIExecutorSubscriber` is the execution class of registering `URI` information.\\n\\n- ShenyuClientURIExecutorSubscriber#executor()\\n\\nThe main logic is to iterate through the URI data collection and implement data registration through the persistURI() method.\\n\\n```java\\n\\npublic class ShenyuClientURIExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\\n    \\n    //......\\n    \\n    @Override\\n    public DataType getType() {\\n        return DataType.URI; \\n    }\\n    \\n    // register URI\\n    @Override\\n    public void executor(final Collection<URIRegisterDTO> dataList) {\\n        for (URIRegisterDTO uriRegisterDTO : dataList) {\\n            Stopwatch stopwatch = Stopwatch.createStarted();\\n            while (true) {\\n                try (Socket ignored = new Socket(uriRegisterDTO.getHost(), uriRegisterDTO.getPort())) {\\n                    break;\\n                } catch (IOException e) {\\n                    long sleepTime = 1000;\\n                    // maybe the port is delay exposed\\n                    if (stopwatch.elapsed(TimeUnit.SECONDS) > 5) {\\n                        LOG.error(\\"host:{}, port:{} connection failed, will retry\\",\\n                                uriRegisterDTO.getHost(), uriRegisterDTO.getPort());\\n                        // If the connection fails for a long time, Increase sleep time\\n                        if (stopwatch.elapsed(TimeUnit.SECONDS) > 180) {\\n                            sleepTime = 10000;\\n                        }\\n                    }\\n                    try {\\n                        TimeUnit.MILLISECONDS.sleep(sleepTime);\\n                    } catch (InterruptedException ex) {\\n                        ex.printStackTrace();\\n                    }\\n                }\\n            }\\n            ShenyuClientShutdownHook.delayOtherHooks();\\n            \\n            shenyuClientRegisterRepository.persistURI(uriRegisterDTO);\\n        }\\n    }\\n}\\n```\\n\\nThe `while(true)` loop in the code is to ensure that the client has been successfully started and can connect via `host` and `port`.\\n\\nThe logic behind it is: add the `hook` function for gracefully stopping the client .\\n\\nData registration is achieved through the `persistURI()` method. The whole logic is also analyzed in the previous section, and ultimately it is the `OkHttp` client that initiates `http` to `shenyu-admin` and registers the `URI` by way of `http`.\\n\\nThe analysis of the registration logic of the client is finished here, and the metadata and URI data constructed are sent to the `Disruptor` queue, from which they are then consumed, read, and sent to `admin` via `http`.\\n\\n\\nThe source code analysis of the client-side metadata and `URI` registration process is complete, with the following flow chart.\\n\\n![](/img/activities/code-analysis-http-register/client-metadata-uri-register-en.png)\\n\\n\\n### 3. Server-side registration process\\n\\n\\n#### 3.1 ShenyuHttpRegistryController\\n\\nFrom the previous analysis, we know that the server side provides two interfaces for registration.\\n\\n- `/shenyu-client/register-metadata`: The interface provided by the server side is used to register metadata.\\n- `/shenyu-client/register-uri`: The server-side interface is provided for registering URIs.\\n\\n\\nThese two interfaces are located in `ShenyuHttpRegistryController`, which implements the `ShenyuServerRegisterRepository` interface and is the implementation class for server-side registration. It is marked with `@Join` to indicate loading via `SPI`.\\n\\n```java\\n@RequestMapping(\\"/shenyu-client\\")\\n@Join\\npublic class ShenyuHttpRegistryController implements ShenyuServerRegisterRepository {\\n\\n    private ShenyuServerRegisterPublisher publisher;\\n\\n    @Override\\n    public void init(final ShenyuServerRegisterPublisher publisher, final ShenyuRegisterCenterConfig config) {\\n        this.publisher = publisher;\\n    }\\n    \\n    // register Metadata\\n    @PostMapping(\\"/register-metadata\\")\\n    @ResponseBody\\n    public String registerMetadata(@RequestBody final MetaDataRegisterDTO metaDataRegisterDTO) {\\n        publisher.publish(metaDataRegisterDTO);\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n        \\n   // register URI\\n    @PostMapping(\\"/register-uri\\")\\n    @ResponseBody\\n    public String registerURI(@RequestBody final URIRegisterDTO uriRegisterDTO) {\\n        publisher.publish(uriRegisterDTO);\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n}\\n\\n```\\n\\n\\n\\nThe exact method used is specified by the configuration file and then loaded via `SPI`.\\n\\n\\nIn the `application.yml` file in `shenyu-admin` configure the registration method, `registerType` specify the registration type, when registering with `http`, `serverLists` do not need to be filled in, for more configuration instructions you can refer to the official website [Client Access Configuration](https://shenyu.apache.org/zh/docs/user-guide/property-config/register-center-access).\\n\\n```yaml\\nshenyu:\\n  register:\\n    registerType: http \\n    serverLists: \\n```\\n\\n- RegisterCenterConfiguration \\n\\nAfter introducing the relevant dependencies and properties configuration, when starting `shenyu-admin`, the configuration file will be loaded first, and the configuration file class related to the registration center is `RegisterCenterConfiguration`.\\n\\n\\n```java\\n@Configuration\\npublic class RegisterCenterConfiguration {\\n    @Bean\\n    @ConfigurationProperties(prefix = \\"shenyu.register\\")\\n    public ShenyuRegisterCenterConfig shenyuRegisterCenterConfig() {\\n        return new ShenyuRegisterCenterConfig();\\n    }\\n    \\n    //create ShenyuServerRegisterRepository to register in admin\\n    @Bean(destroyMethod = \\"close\\")\\n    public ShenyuServerRegisterRepository shenyuServerRegisterRepository(final ShenyuRegisterCenterConfig shenyuRegisterCenterConfig, final List<ShenyuClientRegisterService> shenyuClientRegisterService) {\\n        // 1. get the registration type from the configuration property\\n        String registerType = shenyuRegisterCenterConfig.getRegisterType();\\n        // 2. load the implementation class by registering the type with the SPI method\\n        ShenyuServerRegisterRepository registerRepository = ExtensionLoader.getExtensionLoader(ShenyuServerRegisterRepository.class).getJoin(registerType);\\n        // 3. get the publisher and write data to the Disruptor queue\\n        RegisterServerDisruptorPublisher publisher = RegisterServerDisruptorPublisher.getInstance();\\n        // 4. ShenyuClientRegisterService, rpcType -> registerService\\n        Map<String, ShenyuClientRegisterService> registerServiceMap = shenyuClientRegisterService.stream().collect(Collectors.toMap(ShenyuClientRegisterService::rpcType, e -> e));\\n        // 5. start publisher\\n        publisher.start(registerServiceMap);\\n        // 6. init registerRepository\\n        registerRepository.init(publisher, shenyuRegisterCenterConfig);\\n        return registerRepository;\\n    }\\n}\\n\\n```\\n\\nTwo `bean`s are generated in the configuration class.\\n\\n- `shenyuRegisterCenterConfig`: to read the attribute configuration.\\n\\n- `shenyuServerRegisterRepository`: for server-side registration.\\n\\n\\nIn the process of creating `shenyuServerRegisterRepository`, a series of preparations are also performed.\\n\\n- 1. get the registration type from the configuration property.\\n- 2. Load the implementation class by the registration type with the `SPI` method: for example, if the specified type is `http`, `ShenyuHttpRegistryController` will be loaded.\\n- 3. Get `publisher` and write data to the `Disruptor` queue.\\n- 4. Register `Service`, `rpcType -> registerService`: get the registered `Service`, each `rpc` has a corresponding `Service`. The client for this article is built through `springboot`, which belongs to the `http` type, and other client types: `dubbo`, `Spring Cloud`, `gRPC`, etc.\\n- 5. Preparation for event publishing: add server-side metadata and `URI` subscribers, process the data. And start the `Disruptor` queue.\\n- 6. Initialization operation for registration: `http` type registration initialization operation is to save `publisher`.\\n\\n\\n\\n- RegisterClientServerDisruptorPublisher#publish()\\n\\nThe server-side publisher that writes data to the `Disruptor` queue , built via the singleton pattern.\\n\\n```java\\n\\npublic class RegisterClientServerDisruptorPublisher implements ShenyuServerRegisterPublisher {\\n    private static final RegisterClientServerDisruptorPublisher INSTANCE = new     private static final RegisterClientServerDisruptorPublisher INSTANCE = new RegisterServerDisruptorPublisher();\\n();\\n\\n    public static RegisterClientServerDisruptorPublisher getInstance() {\\n        return INSTANCE;\\n    }\\n    \\n   //prepare for event publishing, add server-side metadata and URI subscribers, process data. And start the Disruptor queue.\\n    public void start(final Map<String, ShenyuClientRegisterService> shenyuClientRegisterService) {\\n        RegisterServerExecutorFactory factory = new RegisterServerExecutorFactory();\\n        // add URI data subscriber\\n        factory.addSubscribers(new URIRegisterExecutorSubscriber(shenyuClientRegisterService));\\n        // add Metadata subscriber\\n        factory.addSubscribers(new MetadataExecutorSubscriber(shenyuClientRegisterService));\\n        //start Disruptor\\n        providerManage = new DisruptorProviderManage(factory);\\n        providerManage.startup();\\n    }\\n    \\n    // write data to queue\\n    @Override\\n    public <T> void publish(final DataTypeParent data) {\\n        DisruptorProvider<Object> provider = providerManage.getProvider();\\n        provider.onData(Collections.singleton(data));\\n    }\\n\\n    // write data to queue on batch\\n    @Override\\n    public void publish(final Collection<? extends DataTypeParent> dataList) {\\n        DisruptorProvider<Collection<DataTypeParent>> provider = providerManage.getProvider();\\n        provider.onData(dataList.stream().map(DataTypeParent.class::cast).collect(Collectors.toList()));\\n    }\\n    \\n    @Override\\n    public void close() {\\n        providerManage.getProvider().shutdown();\\n    }\\n}\\n```\\n\\n\\nThe loading of the configuration file, which can be seen as the initialization process of the registry server, is described in the following diagram.\\n\\n\\n![](/img/activities/code-analysis-http-register/server-register-init-en.png)\\n\\n\\n#### 3.2 QueueConsumer\\n\\nIn the previous analysis of the client-side `disruptor` queue consumption of data over. The server side has the same logic, except that the executor performing the task changes.\\n\\nThe `QueueConsumer` is a consumer that implements the `WorkHandler` interface, which is created in the `providerManage.startup()` logic. The `WorkHandler` interface is the data consumption interface for `disruptor`, and the only method is `onEvent()`.\\n\\n```java\\npackage com.lmax.disruptor;\\n\\npublic interface WorkHandler<T> {\\n    void onEvent(T var1) throws Exception;\\n}\\n```\\n\\nThe `QueueConsumer` overrides the `onEvent()` method, and the main logic is to generate the consumption task and then go to the thread pool to execute it.\\n\\n\\n```java\\n/**\\n * \\n * QueueConsumer\\n */\\npublic class QueueConsumer<T> implements WorkHandler<DataEvent<T>> {\\n    \\n\\t// ......\\n\\n    @Override\\n    public void onEvent(final DataEvent<T> t) {\\n        if (t != null) {\\n            // Use different thread pools based on DataEvent type\\n            ThreadPoolExecutor executor = orderly(t);\\n            // create queue consumption tasks via factory\\n            QueueConsumerExecutor<T> queueConsumerExecutor = factory.create();\\n            // set data\\n            queueConsumerExecutor.setData(t.getData());\\n            // help gc\\n            t.setData(null);\\n            // put in the thread pool to execute the consumption task\\n            executor.execute(queueConsumerExecutor);\\n        }\\n    }\\n}\\n```\\n\\n`QueueConsumerExecutor` is the task that is executed in the thread pool, it implements the `Runnable` interface, and there are two specific implementation classes.\\n\\n- `RegisterClientConsumerExecutor`: the client-side consumer executor.\\n- `RegisterServerConsumerExecutor`: server-side consumer executor.\\n\\nAs the name implies, one is responsible for handling client-side tasks and one is responsible for handling server-side tasks.\\n\\n\\n- `RegisterServerConsumerExecutor#run()`\\n\\n`RegisterServerConsumerExecutor` is a server-side consumer executor that indirectly implements the `Runnable` interface via `QueueConsumerExecutor` and overrides the `run()` method.\\n\\n\\n```java\\n\\npublic final class RegisterServerConsumerExecutor extends QueueConsumerExecutor<List<DataTypeParent>> {\\n   // ...\\n\\n    @Override\\n    public void run() {\\n        //get the data from the disruptor queue and check data\\n        Collection<DataTypeParent> results = getData()\\n                .stream()\\n                .filter(this::isValidData)\\n                .collect(Collectors.toList());\\n        if (CollectionUtils.isEmpty(results)) {\\n            return;\\n        }\\n        //execute operations according to type\\n        getType(results).executor(results);\\n    }\\n    \\n    // get subscribers by type\\n    private ExecutorSubscriber<DataTypeParent> selectExecutor(final Collection<DataTypeParent> list) {\\n        final Optional<DataTypeParent> first = list.stream().findFirst();\\n        return subscribers.get(first.orElseThrow(() -> new RuntimeException(\\"the data type is not found\\")).getType());\\n    }\\n}\\n\\n```\\n\\n\\n- ExecutorSubscriber#executor()\\n\\nThe actuator subscribers are divided into two categories, one that handles metadata and one that handles `URIs`. There are two on the client side and two on the server side, so there are four in total.\\n\\n\\n![](/img/activities/code-analysis-http-register/executor-subscriber.png)\\n\\n\\n- MetadataExecutorSubscriber#executor()\\n\\nIn case of registering metadata, this is achieved by `MetadataExecutorSubscriber#executor()`: get the registered `Service` according to the type and call `register()`.\\n\\n```java\\npublic class MetadataExecutorSubscriber implements ExecutorTypeSubscriber<MetaDataRegisterDTO> {\\n \\n    //......\\n\\n    @Override\\n    public DataType getType() {\\n        return DataType.META_DATA; \\n    }\\n\\n    @Override\\n    public void executor(final Collection<MetaDataRegisterDTO> metaDataRegisterDTOList) {\\n        // Traversing the metadata list\\n        metaDataRegisterDTOList.forEach(meta -> {\\n            Optional.ofNullable(this.shenyuClientRegisterService.get(meta.getRpcType())) // Get registered Service by type\\n                    .ifPresent(shenyuClientRegisterService -> {\\n                        // Registration of metadata, locking to ensure sequential execution and prevent concurrent errors\\n                        synchronized (shenyuClientRegisterService) {\\n                            shenyuClientRegisterService.register(meta);\\n                        }\\n                    });\\n        });\\n    }\\n}\\n```\\n\\n\\n- URIRegisterExecutorSubscriber#executor()\\n\\nIn case of registration metadata, this is achieved by `URIRegisterExecutorSubscriber#executor()`: construct `URI` data, find `Service` according to the registration type, and achieve registration by the `registerURI` method.\\n\\n\\n```java\\n\\npublic class URIRegisterExecutorSubscriber implements ExecutorTypeSubscriber<URIRegisterDTO> {\\n    //......\\n    \\n    @Override\\n    public DataType getType() {\\n        return DataType.URI; \\n    }\\n    \\n    @Override\\n    public void executor(final Collection<URIRegisterDTO> dataList) {\\n        if (CollectionUtils.isEmpty(dataList)) {\\n            return;\\n        }\\n        \\n        findService(dataList).ifPresent(service -> {\\n            Map<String, List<URIRegisterDTO>> listMap = buildData(dataList);\\n            listMap.forEach(service::registerURI);\\n        });\\n        final Map<String, List<URIRegisterDTO>> groupByRpcType = dataList.stream()\\n                .filter(data -> StringUtils.isNotBlank(data.getRpcType()))\\n                .collect(Collectors.groupingBy(URIRegisterDTO::getRpcType));\\n        for (Map.Entry<String, List<URIRegisterDTO>> entry : groupByRpcType.entrySet()) {\\n            final String rpcType = entry.getKey();\\n            // Get registered Service by type\\n            Optional.ofNullable(shenyuClientRegisterService.get(rpcType))\\n                    .ifPresent(service -> {\\n                        final List<URIRegisterDTO> list = entry.getValue();\\n                        // Build URI data types and register them with the registerURI method\\n                        Map<String, List<URIRegisterDTO>> listMap = buildData(list);\\n                        listMap.forEach(service::registerURI);\\n                    });\\n        }\\n    }\\n    \\n    // Find Service by type\\n    private Optional<ShenyuClientRegisterService> findService(final Collection<URIRegisterDTO> dataList) {\\n        return dataList.stream().map(dto -> shenyuClientRegisterService.get(dto.getRpcType())).findFirst();\\n    }\\n}\\n\\n```\\n\\n\\n- ShenyuClientRegisterService#register()\\n\\n`ShenyuClientRegisterService` is the registration method interface, which has several implementation classes.\\n\\n![](/img/activities/code-analysis-http-register/client-register-service.png)\\n\\n\\n\\n- `AbstractContextPathRegisterService`: abstract class, handling part of the public logic.\\n- `AbstractShenyuClientRegisterServiceImpl`: : abstract class, handles part of the public logic.\\n- `ShenyuClientRegisterDivideServiceImpl`: `divide` class, handles `http` registration types.\\n- `ShenyuClientRegisterDubboServiceImpl`: `dubbo` class, handles `dubbo` registration types.\\n- `ShenyuClientRegisterGrpcServiceImpl`: `gRPC` class, handles `gRPC` registration types.\\n- `ShenyuClientRegisterMotanServiceImpl`: `Motan` class, handles `Motan` registration types.\\n- `ShenyuClientRegisterSofaServiceImpl`: `Sofa` class, handles `Sofa` registration types.\\n- `ShenyuClientRegisterSpringCloudServiceImpl`: `SpringCloud` class, handles `SpringCloud` registration types.\\n- `ShenyuClientRegisterTarsServiceImpl`: `Tars` class, handles `Tars` registration types.\\n- `ShenyuClientRegisterWebSocketServiceImpl`\uff1a `Websocket` class\uff0chandles `Websocket` registration types.\\n\\n\\nFrom the above, we can see that each microservice has a corresponding registration implementation class. The source code analysis in this article is based on the official [shenyu-examples-http](https://github.com/apache/shenyu/tree/master/shenyu-examples/shenyu-examples-http) as an example, it is of `http` registration type, so the registration implementation class for metadata and URI data is `ShenyuClientRegisterDivideServiceImpl`: `ShenyuClientRegisterDivideServiceImpl`.\\n\\n- register(): \\n\\n```java\\npublic abstract class AbstractShenyuClientRegisterServiceImpl extends FallbackShenyuClientRegisterService implements ShenyuClientRegisterService {\\n\\n    //......\\n\\n    public String register(final MetaDataRegisterDTO dto) {\\n        // 1.register selector information\\n        String selectorHandler = selectorHandler(dto);\\n        String selectorId = selectorService.registerDefault(dto, PluginNameAdapter.rpcTypeAdapter(rpcType()), selectorHandler);\\n        // 2.register rule information\\n        String ruleHandler = ruleHandler();\\n        RuleDTO ruleDTO = buildRpcDefaultRuleDTO(selectorId, dto, ruleHandler);\\n        ruleService.registerDefault(ruleDTO);\\n        // 3.register metadata information\\n        registerMetadata(dto);\\n        // 4.register contextPath\\n        String contextPath = dto.getContextPath();\\n        if (StringUtils.isNotEmpty(contextPath)) {\\n            registerContextPath(dto);\\n        }\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n}\\n```\\n\\nThe whole registration logic can be divided into 4 steps.\\n\\n- 1. Register selector information\\n- 2. Register rule information\\n- 3. Register metadata information\\n- 4. Register `contextPath\\n\\nThis side of `admin` requires the construction of selectors, rules, metadata and `ContextPath` through the metadata information of the client. The specific registration process and details of processing are related to the `rpc` type. We will not continue to track down the logical analysis of the registration center, tracking to this point is enough.\\n\\n\\nThe source code of the server-side metadata registration process is analyzed and the flow chart is described as follows.\\n\\n\\n![](/img/activities/code-analysis-http-register/server-metadata-register-en.png)\\n\\n\\n- registerURI()\\n\\n```java\\npublic abstract class AbstractShenyuClientRegisterServiceImpl extends FallbackShenyuClientRegisterService implements ShenyuClientRegisterService {\\n\\n    //......\\n\\n    public String registerURI(final String selectorName, final List<URIRegisterDTO> uriList) {\\n        if (CollectionUtils.isEmpty(uriList)) {\\n            return \\"\\";\\n        }\\n        // Does the corresponding selector exist\\n        SelectorDO selectorDO = selectorService.findByNameAndPluginName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n        if (Objects.isNull(selectorDO)) {\\n            return \\"\\";\\n        }\\n        // Handle handler information in the selector\\n        String handler = buildHandle(uriList, selectorDO);\\n        selectorDO.setHandle(handler);\\n        SelectorData selectorData = selectorService.buildByName(selectorName, PluginNameAdapter.rpcTypeAdapter(rpcType()));\\n        selectorData.setHandle(handler);\\n\\n        // Update records in the database\\n        selectorService.updateSelective(selectorDO);\\n        // publish Event to gateway\\n        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE, Collections.singletonList(selectorData)));\\n        return ShenyuResultMessage.SUCCESS;\\n    }\\n}\\n```\\n\\nAfter `admin` gets the `URI` data, it mainly updates the `handler` information in the selector, then writes it to the database, and finally publishes the event notification gateway. The logic of notifying the gateway is done by the data synchronization operation, which has been analyzed in the previous article, so we will not repeat it.\\n\\n\\nThe source code analysis of the server-side `URI` registration process is complete and is described in the following diagram.\\n\\n\\n![](/img/activities/code-analysis-http-register/server-uri-register-en.png)\\n\\nAt this point, the server-side registration process is also analyzed, mainly through the interface provided externally, accept the registration information from the client, and then write to the `Disruptor` queue, and then consume data from it, and update the `admin` selector, rules, metadata and selector `handler` according to the received metadata and `URI` data.\\n\\n### 4. Summary\\n\\nThis article focuses on the `http registration` module of the `Apache ShenYu` gateway for source code analysis. The main knowledge points involved are summarized as follows.\\n\\n- The register center is for registering client information to `admin` to facilitate traffic filtering.\\n- `http` registration is to register client metadata information and `URI` information to `admin`.\\n- `http` service access is identified by the annotation `@ShenyuSpringMvcClient`.\\n- construction of the registration information mainly through the application listener `ApplicationListener`.\\n- loading of the registration type is done through `SPI`.\\n- The `Disruptor` queue was introduced to decouple data from operations, and data buffering.\\n- The implementation of the registry uses interface-oriented programming, using design patterns such as template methods, singleton, and observer."},{"id":"/SPI-SourceCode-Analysis-LoadBalance-SPI","metadata":{"permalink":"/blog/SPI-SourceCode-Analysis-LoadBalance-SPI","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-LoadBalance-SPI.md","source":"@site/blog/SPI-SourceCode-Analysis-LoadBalance-SPI.md","title":"LoadBalancer SPI Source Code Analysis","description":"Gateway applications need to support a variety of load balancing  strategies, including random,Hashing, RoundRobin and so on. In Apache Shenyu gateway, it not only realizes such traditional algorithms, but also makes smoother traffic processing for the entry of server nodes through detailed processing such as traffic warm-up, so as to obtain better overall stability. In this article, let\'s walk through how Apache Shenyu is designed and implemented this part of the function.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"load balance","permalink":"/blog/tags/load-balance"},{"label":"SPI","permalink":"/blog/tags/spi"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":13.98,"hasTruncateMarker":false,"authors":[{"name":"Huihui Yin","title":"Apache ShenYu Contributor","url":"https://github.com/changanjennifer/"}],"frontMatter":{"title":"LoadBalancer SPI Source Code Analysis","author":"Huihui Yin","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/changanjennifer/","tags":["load balance","SPI","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Register Center Source Code Analysis of Http Register","permalink":"/blog/RegisterCenter-SourceCode-Analysis-Http-Register"},"nextItem":{"title":"MatchStrategy  -- analyze the design based on SPI","permalink":"/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI"}},"content":"Gateway applications need to support a variety of load balancing  strategies, including `random`,`Hashing`, `RoundRobin` and so on. In `Apache Shenyu` gateway, it not only realizes such traditional algorithms, but also makes smoother traffic processing for the entry of server nodes through detailed processing such as traffic `warm-up,` so as to obtain better overall stability. In this article, let\'s walk through how `Apache Shenyu` is designed and implemented this part of the function.\\n\\n> This article based on `shenyu-2.5.0` version of the source code analysis.\\n\\n[TOC]\\n\\n## LoadBalancer `SPI`\\n\\nThe implementation of `LoadBalancer` is in ***shenyu-loadbalancer*** module. It has based on its `SPI` creation mechanism. The core interface code is shown as follows. This interface  well explains the concept: load balancing is to select the most appropriate node from a series of server nodes.  Routing, traffic processing and load balancing is the basic function of `LoadBalancer` `SPI`.\\n\\n```java\\n@SPI\\npublic interface LoadBalancer {\\n\\n    /**\\n     * this is select one for upstream list.\\n     *\\n     * @param upstreamList upstream list\\n     * @param ip ip\\n     * @return upstream\\n     */\\n    Upstream select(List<Upstream> upstreamList, String ip);\\n}\\n```\\n\\nWhere `upstreamList` represents the server nodes list available for routing. `Upstream` is the data structure of server node, the  important elements including `protocol`, `upstreamUrl` , `weight`, `timestamp`, `warmup`\u3001`healthy`.  \\n\\n```java\\npublic class Upstream {\\n    /**\\n     * protocol.\\n     */\\n    private final String protocol;\\n\\n    /**\\n     * url.\\n     */\\n    private String url;\\n\\n    /**\\n     * weight.\\n     */\\n    private final int weight;\\n\\n    /**\\n     * false close, true open.\\n     */\\n    private boolean status;\\n\\n    /**\\n     * startup time.\\n     */\\n    private final long timestamp;\\n\\n    /**\\n     * warmup.\\n     */\\n    private final int warmup;\\n\\n    /**\\n     * healthy.\\n     */\\n    private boolean healthy;\\n\\n    /**\\n     * lastHealthTimestamp.\\n     */\\n    private long lastHealthTimestamp;\\n\\n    /**\\n     * lastUnhealthyTimestamp.\\n     */\\n    private long lastUnhealthyTimestamp;\\n\\n    /**\\n     * group.\\n     */\\n    private String group;\\n\\n    /**\\n     * version.\\n     */\\n    private String version;\\n}\\n\\n\\n```\\n\\n## Design of LoadBalancer module\\n\\nThe class diagram of `LoadBalancer` module`is`shown as follows.\\n\\n![loadbalancer-class-diagram](/img/activities/code-analysis-loadbalance-spi/loadBalancer-class-diagram.png)\\n\\nWe can draw the outline of `LoadBalancer` module from the class diagram:\\n\\n1. The abstract class `AbstractLoadBalancer` implements the SPI `LoadBalancer` interface\uff0cand supplies the template methods for selection related, such as select(), selector()\uff0cand gives the calculation of weight.\\n\\n2. Three implementation classes which inherit `AbstractLoadBalancer` to realize their own logic:\\n\\n   - `RandomLoadBalancer` - Weight Random\\n   - `HashLoadBalancer`  - Consistent Hashing\\n   - `RoundRobinLoadBalancer` -Weight Round Robin per-packet\\n\\n3. The factory class `LoadBalancerFactory` provides public static method to be called.\\n\\n   The implementation classes and algorithms are configurable.   According to its specification,   by adding profile in `SHENYU_DIERECTORY` directory, the data in profile should be  *key*=*value-class* format, where the *value-class* will be load by the `Apache Shenyu SPI` class loader, and *key* value should be an `name` defined in `LoadBalanceEnum.`\\n\\n```properties\\nrandom=org.apache.shenyu.loadbalancer.spi.RandomLoadBalancer\\nroundRobin=org.apache.shenyu.loadbalancer.spi.RoundRobinLoadBalancer\\nhash=org.apache.shenyu.loadbalancer.spi.HashLoadBalancer\\n```\\n\\n`The code of LoadBalanceEnum` is as follows\uff1a\\n\\n```java\\npublic enum LoadBalanceEnum {\\n    /**\\n     * Hash load balance enum.\\n     */\\n    HASH(1, \\"hash\\", true),\\n\\n    /**\\n     * Random load balance enum.\\n     */\\n    RANDOM(2, \\"random\\", true),\\n\\n    /**\\n     * Round robin load balance enum.\\n     */\\n    ROUND_ROBIN(3, \\"roundRobin\\", true);\\n\\n    private final int code;\\n    private final String name;\\n    private final boolean support;\\n}\\n```\\n\\n## AbstractLoadBalancer\\n\\nThis abstract class implements the `LoadBalancer` interface and define the abstract method `doSelect()` to be processed by the implementation classes. In the template method `select()`,  It will do validation first then call the `doSelect()` method.\\n\\n```java\\npublic abstract class AbstractLoadBalancer implements LoadBalancer {\\n    /**\\n     * Do select divide upstream.\\n     *\\n     * @param upstreamList the upstream list\\n     * @param ip           the ip\\n     * @return the divide upstream\\n     */\\n    protected abstract Upstream doSelect(List<Upstream> upstreamList, String ip);\\n\\n    @Override\\n    public Upstream select(final List<Upstream> upstreamList, final String ip) {\\n        if (CollectionUtils.isEmpty(upstreamList)) {\\n            return null;\\n        }\\n        if (upstreamList.size() == 1) {\\n            return upstreamList.get(0);\\n        }\\n        return doSelect(upstreamList, ip);\\n    }\\n}\\n```\\n\\nWhen the `timestamp` of server node  is not null, and the interval between current time and `timestamp` is within the traffic warm-up time, the formula for weight calculation is.\\n$$ {1-1}\\nww = min(1,uptime/(warmup/weight))\\n$$\\nIt can be seen from the formula that the final weight(`ww`) is proportional to the original-`weight` value. The closer the time interval is to the `warmup` time, the greater the final `ww`. That is, the longer the waiting time of the request, the higher the final `weight`. When there is no `timestamp` or other conditions, the `ww` is equal to the `weight` value of `Upstream` object.\\n\\nThe central of thinking about *warm-up*is to avoid  bad performance when adding new server and the new `JVMs` starting up.\\n\\nLet\'s see how the load balancing  with `Random`, `Hashing` and `RoundRobin` strategy is implemented.\\n\\n## RandomLoadBalancer\\n\\nThe `RandomLoadBalancer` can handle two situations:\\n\\n1. Each node without weight, or every node has the same weight, randomly choose one.\\n2. Server Nodes with different weight, choose one randomly by weight.\\n\\nFollowing is the `random()` method of `RandomLoadBalancer`. When traversing server node list, if the randomly generated value is less than the weight of node, then the current node will be chosen. If after one round traversing, there is no server node match, then it will choose one randomly. The `getWeight(final Upstream upstream)` is defined in `AbstractLoadBalancer` class.\\n\\n```java\\n    @Override\\n    public Upstream doSelect(final List<Upstream> upstreamList, final String ip) {\\n        int length = upstreamList.size();\\n        // every upstream has the same weight?\\n        boolean sameWeight = true;\\n        // the weight of every upstream\\n        int[] weights = new int[length];\\n        int firstUpstreamWeight = getWeight(upstreamList.get(0));\\n        weights[0] = firstUpstreamWeight;\\n        // init the totalWeight\\n        int totalWeight = firstUpstreamWeight;\\n        int halfLengthTotalWeight = 0;\\n        for (int i = 1; i < length; i++) {\\n            int currentUpstreamWeight = getWeight(upstreamList.get(i));\\n            if (i <= (length + 1) / 2) {\\n                halfLengthTotalWeight = totalWeight;\\n            }\\n            weights[i] = currentUpstreamWeight;\\n            totalWeight += currentUpstreamWeight;\\n            if (sameWeight && currentUpstreamWeight != firstUpstreamWeight) {\\n                // Calculate whether the weight of ownership is the same.\\n                sameWeight = false;\\n            }\\n        }\\n        if (totalWeight > 0 && !sameWeight) {\\n            return random(totalWeight, halfLengthTotalWeight, weights, upstreamList);\\n        }\\n        return random(upstreamList);\\n    }\\n\\n    private Upstream random(final int totalWeight, final int halfLengthTotalWeight, final int[] weights, final List<Upstream> upstreamList) {\\n        // If the weights are not the same and the weights are greater than 0, then random by the total number of weights.\\n        int offset = RANDOM.nextInt(totalWeight);\\n        int index = 0;\\n        int end = weights.length;\\n        if (offset >= halfLengthTotalWeight) {\\n            index = (weights.length + 1) / 2;\\n            offset -= halfLengthTotalWeight;\\n        } else {\\n            end = (weights.length + 1) / 2;\\n        }\\n        // Determine which segment the random value falls on\\n        for (; index < end; index++) {\\n            offset -= weights[index];\\n            if (offset < 0) {\\n                return upstreamList.get(index);\\n            }\\n        }\\n        return random(upstreamList);\\n    }\\n```\\n\\n## HashLoadBalancer\\n\\nIn `HashLoadBalancer`, it takes the advantages of [consistent hashing](https://en.wikipedia.org/wiki/Consistent_hashing) , that maps both the input traffic and the servers to a unit circle, or name as  *hash ring*. For the requested`ip` address, with its hash value to find the node closest in clockwise order as the node to be routed.  Let\'s see how consistent hashing is implemented in `HashLoadBalancer`.\\n\\nAs to the hash algorithms, `HashLoadBalancer` uses `MD5` hash, which has the advantage of mixing the input in an unpredictable but deterministic way. The output is a 32-bit integer.  the code is shown as follows:\\n\\n```java\\nprivate static long hash(final String key) {\\n    // md5 byte\\n    MessageDigest md5;\\n    try {\\n        md5 = MessageDigest.getInstance(\\"MD5\\");\\n    } catch (NoSuchAlgorithmException e) {\\n        throw new ShenyuException(\\"MD5 not supported\\", e);\\n    }\\n    md5.reset();\\n    byte[] keyBytes;\\n    keyBytes = key.getBytes(StandardCharsets.UTF_8);\\n    md5.update(keyBytes);\\n    byte[] digest = md5.digest();\\n    // hash code, Truncate to 32-bits\\n    long hashCode = (long) (digest[3] & 0xFF) << 24\\n            | ((long) (digest[2] & 0xFF) << 16)\\n            | ((long) (digest[1] & 0xFF) << 8)\\n            | (digest[0] & 0xFF);\\n    return hashCode & 0xffffffffL;\\n}\\n```\\n\\nImportantly, how to generate the hash ring and avoid skewness?  Let\'s the`doSelect()` method in`HashLoadBalancer` as follows:\\n\\n```java\\n    private static final int VIRTUAL_NODE_NUM = 5;\\n\\n    @Override\\n    public Upstream doSelect(final List<Upstream> upstreamList, final String ip) {\\n        final ConcurrentSkipListMap<Long, Upstream> treeMap = new ConcurrentSkipListMap<>();\\n        upstreamList.forEach(upstream -> IntStream.range(0, VIRTUAL_NODE_NUM).forEach(i -> {\\n            long addressHash = hash(\\"SHENYU-\\" + upstream.getUrl() + \\"-HASH-\\" + i);\\n            treeMap.put(addressHash, upstream);\\n        }));\\n        long hash = hash(ip);\\n        SortedMap<Long, Upstream> lastRing = treeMap.tailMap(hash);\\n        if (!lastRing.isEmpty()) {\\n            return lastRing.get(lastRing.firstKey());\\n        }\\n        return treeMap.firstEntry().getValue();\\n    }\\n```\\n\\nIn this method, duplicated labels are used which are called \\"virtual nodes\\" (i.e.  5 virtual nodes point to a single \\"real\\" server).  It will make the distribution in hash ring more evenly, and reduce the occurrence of data skewness.\\n\\nIn order to rescue the data sorted in the hash ring, and can be accessed quickly, we use [ConcurrentSkipListMap](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentSkipListMap.html) of Java to store the server node lists ( with virtual nodes) and its hash value as key.  This class a member of [Java Collections Framework](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/index.html), providing expected average *log(n)* time cost for retrieve and access operations safely execute concurrent by multiple threads.  \\n\\nFurthermore, the method tailMap(K fromKey) of  `ConcurrentSkipListMap` can return a view of portion of the map whose keys are greater or equal to the `fromKey`, and not need to navigate the whole map.\\n\\nIn the above code section, after the hash ring is generated, it uses `tailMap(K fromKey)` of `ConcurrentSkipListMap` to find the subset that the elements greater, or equal to the hash value of the requested `ip`, its first element is just the node to be routed. With the suitable data structure, the code looks particularly clear and concise.\\n\\nConsistent hashing resolved the poor scalability of the traditional hashing by modular operation.\\n\\n## RoundRobinLoadBalancer\\n\\nThe original Round-robin selection is to select server nodes one by one from the candidate list. Whenever some nodes has crash ( ex, cannot be connected after 1 minute), it will be removed from the candidate list, and do not attend the next round, until the server node is recovered and it will be add to the candidate list again.  In `RoundRobinLoadBalancer`,the weight Round Robin per-packet schema is implemented.\\n\\nIn order to work in concurrent system, it provides an inner static class `WeigthRoundRobin` to store and calculate the rolling selections of each server node. Following is the main section of this class( removed remark )\\n\\n```java\\nprotected static class WeightedRoundRobin {\\n\\n    private int weight;\\n\\n    private final AtomicLong current = new AtomicLong(0);\\n\\n    private long lastUpdate;\\n\\n    void setWeight(final int weight) {\\n        this.weight = weight;\\n        current.set(0);\\n    }\\n    long increaseCurrent() {\\n        return current.addAndGet(weight);\\n    }\\n\\n    void sel(final int total) {\\n        current.addAndGet(-1 * total);\\n    }\\n    void setLastUpdate(final long lastUpdate) {\\n        this.lastUpdate = lastUpdate;\\n    }\\n}\\n```\\n\\nPlease focus on the these method:\\n\\n- `setWeight(final int weight)` : set the current value by *weight*\\n\\n- `increaseCurrent()`: Increment the `current` value by `weight`, and `current` set to 0. \\n\\n- `sel(final int total)`: decrement  the `current` value by  *total*\\n\\n  Let\'s see how the weight factor being used in this round-robin  selection? \\n\\n  First it defines a two-level  `ConcurrentMap` type variable named as `methodWeightMap` , to cache the server node lists and the rolling selection data about each server node.\\n\\n```java\\nprivate final ConcurrentMap<String, ConcurrentMap<String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap<>(16);\\n```\\n\\nIn this map, the key of first level is  set to `upstreamUrl` of first element in server node list. The type of second object is `ConcurrentMap<String, WeightedRoundRobin>,` the key of this inner Map is  the value `upstreamUrl`variable of each server node in this server list, the value object is `WeightedRoundRobin`, used to trace the rolling selection data about each server node. As to the implementation class for the  Map object, we use `ConcurrentHashMap` of [JUC](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html),  a hash table supporting full concurrency of retrievals and high expected concurrency for updates.\\n\\nIn the second level of the map, the embedded  static class - `WeighedRoundRobin` of each node is thread-safe, implementing the weighted `RoundRobin` per bucket. The following is the code of the `doselect()` method of this class.\\n\\n```java\\n@Override\\npublic Upstream doSelect(final List<Upstream> upstreamList, final String ip) {\\n    String key = upstreamList.get(0).getUrl();\\n    ConcurrentMap<String, WeightedRoundRobin> map = methodWeightMap.get(key);\\n    if (Objects.isNull(map)) {\\n        methodWeightMap.putIfAbsent(key, new ConcurrentHashMap<>(16));\\n        map = methodWeightMap.get(key);\\n    }\\n    int totalWeight = 0;\\n    long maxCurrent = Long.MIN_VALUE;\\n    long now = System.currentTimeMillis();\\n    Upstream selectedInvoker = null;\\n    WeightedRoundRobin selectedWeightedRoundRobin = null;\\n    for (Upstream upstream : upstreamList) {\\n        String rKey = upstream.getUrl();\\n        WeightedRoundRobin weightedRoundRobin = map.get(rKey);\\n        int weight = getWeight(upstream);\\n        if (Objects.isNull(weightedRoundRobin)) {\\n            weightedRoundRobin = new WeightedRoundRobin();\\n            weightedRoundRobin.setWeight(weight);\\n            map.putIfAbsent(rKey, weightedRoundRobin);\\n        }\\n        if (weight != weightedRoundRobin.getWeight()) {\\n            // weight changed.\\n            weightedRoundRobin.setWeight(weight);\\n        }\\n        long cur = weightedRoundRobin.increaseCurrent();\\n        weightedRoundRobin.setLastUpdate(now);\\n        if (cur > maxCurrent) {\\n            maxCurrent = cur;\\n            selectedInvoker = upstream;\\n            selectedWeightedRoundRobin = weightedRoundRobin;\\n        }\\n        totalWeight += weight;\\n    }\\n    ......  //erase the section which handles the time-out upstreams. \\n    if (selectedInvoker != null) {\\n        selectedWeightedRoundRobin.sel(totalWeight);\\n        return selectedInvoker;\\n    }\\n    // should not happen here\\n    return upstreamList.get(0);\\n}\\n```\\n\\nFor example we assume `upstreamUrl` values of three server nodes is: LIST = [upstream-20, upstream-50, upstream-30]. After a round of execution, the data in newly created `methodWeightMap` is as follows:\\n\\n![methodWeightMap](/img/activities/code-analysis-loadbalance-spi/methodWeightMap.png)\\n\\nFor the above example LIST, assumes the  `weight` array is  [20,50,30].  the following figure shows the value change and polling selection process of the `current` array in `WeighedRoundRobin` object.\\n\\n![weighted-roundrobin-demo](/img/activities/code-analysis-loadbalance-spi/weighted-roundrobin-demo.png)\\n\\nIn each round, it will choose the server node with max `current` value.\\n\\n- Round1:\\n  - Traverse the server node list, initialize the `weightedRoundRobin` instance of each server node or update  the `weight` value of server nodes object `Upstream`\\n  - Traverse the server node list, initialize the `weightedRoundRobin` instance of each server node or update  the `weight` value of server nodes object `Upstream`\\n  - say, in this case,  after traverse, the `current` array  of the node list changes to  [20, 50,30]\uff0cso according to rule, the node Stream-50 would be chosen, and then the static object `WeightedRoundRobin` of  Stream-50 executes `sel(-total)` , the `current` array is now [20,-50, 30].\\n- Round 2:  after traverse, the `current` array should be [40,0,60],  so the Stream-30 node would be chosen\uff0c `current` array is now  [40,0,-40].\\n- Round 3:  after traverse, `current` array  changes to [60,50,-10],  Stream-20 would be chosen\uff0cand `current` array is now [-40,50,-10].\\n\\nWhen there is any inconsistence or some server crashed, for example, the lists size does not match with the elements in map, it would copy and modify the element with lock mechanism, and remove the timeout server node,  the data in Map updated. Following is the fault tolerance code segment.  \\n\\n```Java\\n    if (!updateLock.get() && upstreamList.size() != map.size() && updateLock.compareAndSet(false, true)) {\\n        try {\\n            // copy -> modify -> update reference.\\n            ConcurrentMap<String, WeightedRoundRobin> newMap = new ConcurrentHashMap<>(map);\\n            newMap.entrySet().removeIf(item -> now - item.getValue().getLastUpdate() > recyclePeriod);\\n            methodWeightMap.put(key, newMap);\\n        } finally {\\n            updateLock.set(false);\\n        }\\n    }\\n    if (Objects.nonNull(selectedInvoker)) {\\n        selectedWeightedRoundRobin.sel(totalWeight);\\n        return selectedInvoker;\\n    }\\n    // should not happen here.\\n    return upstreamList.get(0);\\n```\\n\\n## LoadBalancerFactory\\n\\nIn this class, a static method calling `LoadBalancer` is provided, where`ExtensionLoader` is the entry point of `Apache Shenyu SPI`. That is to say, `LoadBalancer` module is configurable and extensible. The `algorithm` variable in this static method is the `name` enumeration type defined in `LoadBalanceEnum`.\\n\\n```java\\n    /**\\n     * Selector upstream.\\n     *\\n     * @param upstreamList the upstream list\\n     * @param algorithm    the loadBalance algorithm\\n     * @param ip           the ip\\n     * @return the upstream\\n     */\\n    public static Upstream selector(final List<Upstream> upstreamList, final String algorithm, final String ip) {\\n        LoadBalancer loadBalance = ExtensionLoader.getExtensionLoader(LoadBalancer.class).getJoin(algorithm);\\n        return loadBalance.select(upstreamList, ip);\\n    }\\n```\\n\\n## Using of LoadBalancer module\\n\\nIn the above section, we describe the `LoadBalancer` `SPI` and three implementation classes. Let\'s take a look at how the `LoadBalancer` to be used in `Apache Shenyu`. [DividePlugin](http://shenyu.apache.org/docs/plugin-center/proxy/divide-plugin) is a `plugin` in `Apache Shenyu` responsible for routing `http` request. when enable to use this `plugin`, it will transfer traffic according to selection data and rule data, and deliver to next plugin downstream.\\n\\n```java\\n@Override\\nprotected Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\\n   ......\\n}\\n```\\n\\nThe type of second parameter of `doExecute()` is `ShenyuPluginChain`, which represents the execution chain of `plugins`. For details, see the mechanism of [Apache Shenyu Plugins](http://shenyu.apache.org/docs/design/flow-control). The third one is `SelectorData` type, and the fourth is `RuleData` type working as  the rule data.\\n\\nIn `doExecute()` of `DividePlugin`,  first verify the size of `header`, content length,  etc, then preparing for load balancing.\\n\\nFollowing is a code fragment using`LoadBalancer` in the `doExecute()` method:\\n\\n```java\\n    // find the routing server node list\\n    List<Upstream> upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());\\n    ... \\n    // the requested ip\\n    String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\\n\\n    //calling the Utility class and invoke the LoadBalance processing.\\n    Upstream upstream = LoadBalancerFactory.selector(upstreamList, ruleHandle.getLoadBalance(), ip);\\n```\\n\\n In the above code, the output of`ruleHandle.getLoadBalance()` is the `name` variable defined in `LoadBalanceEnum`, that is `random`, `hash`, `roundRobin`, etc.  It is very convenient to use `LoadBalancer` by `LoadBalancerFactory`. When adding more  `LoadBalancer` implementing classes,  the interface in `plugin` module will not be effect at all.\\n\\n## Summary\\n\\nAfter reading through the code of `LoadBalancer` module, from the design perspective, it is concluded that this module has the  following characteristics:\\n\\n1. Extensibility: Interface oriented design and implemented on `Apache Shenyu SPI` mechanism, it can be easily extended to other dynamic load balancing algorithms (for example, least connection, fastest mode, etc), and supports cluster processing.\\n2. Scalability\uff1a Every load balancing implementation,  weighted Random, consistency  Hashing and weighted `RoundRobin` can well support increase or decrease cluster overall capacity.\\n3. More detailed design such as *warm-up* can bring better performance and obtain better overall stability."},{"id":"/SPI-SourceCode-Analysis-MatchStrategy-SPI","metadata":{"permalink":"/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI.md","source":"@site/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI.md","title":"MatchStrategy  -- analyze the design based on SPI","description":"In most of the plugins ( such as Dubbo, gRPC,Spring-cloud, etc) of Apache Shenyu, the routingparameters are designed to support the combination of multiple conditions. In order to realize such requirements,  the parameters and behaviors are abstracted to three parts according to its SPI mechanism,  and implemented in shenyu-plugin-base  module.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"SPI","permalink":"/blog/tags/spi"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":4.56,"hasTruncateMarker":false,"authors":[{"name":"Huihui Yin","title":"Apache ShenYu Contributor"}],"frontMatter":{"title":"MatchStrategy  -- analyze the design based on SPI","author":"Huihui Yin","author_title":"Apache ShenYu Contributor","tags":["SPI","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"LoadBalancer SPI Source Code Analysis","permalink":"/blog/SPI-SourceCode-Analysis-LoadBalance-SPI"},"nextItem":{"title":"PredicateJudge -- analyze the design based on SPI","permalink":"/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI"}},"content":"In most of the `plugins` ( such as `Dubbo`, `gRPC`,`Spring-cloud`, etc) of `Apache Shenyu`, the `routing`parameters are designed to support the combination of multiple conditions. In order to realize such requirements,  the parameters and behaviors are abstracted to three parts according to its `SPI` mechanism,  and implemented in ***shenyu-plugin-base***  module.\\n\\n- `ParameterData`-parameters\\n- `PredictJudge`-predicate\\n- `MatchStrategy`-matching strategy\\n\\nRelatively speaking, the `MatchStrategy` is the part that needs the least extension points. For the combined judgement of multiple conditions, the common selection rules are: All conditions are matched, at least one is matched, at least the first is met, or most of conditions  satisfied.  As we will  need to handle various types of parameters, for example: `IP`, `header`, `uri`, etc. \\n\\nHow to make the `MatchStrategy` to be simple to use and extensible?\\n\\n## MatchStrategy\\n\\nThe implementation of `MatchStrategy` is in ***shenyu-plugin-base*** module. It is based on the SPI creation mechanism, and has used factory pattern and strategy design pattern. The class diagram of `MatchStrategy` `is` showed as follows.\\n\\n![MatchStrategy-class-diagram](/img/activities/code-analysis-matchstrategy-spi/MatchStrategy-class-diagram.PNG)\\n\\nBased on the interface `MatchStrategy` we design the implementation classes, and the  abstract class `AbstractMatchStrategy` supplies common method, while the factory class `MatchStrategyFactory` provides creation  functions.\\n\\n## MatchStrategy Interface\\n\\nFirst, let\'s look at the `MatchStrategy` `SPI` interface\\n\\n```java\\n@SPI\\npublic interface MatchStrategy {\\n\\n    Boolean match(List<ConditionData> conditionDataList, ServerWebExchange exchange);\\n}\\n```\\n\\nThe annotation `@SPI` means that this is an `SPI` interface. Where `ServerWebExchange` is `org.springframework.web.server.ServerWebExchange`, represents the request-response  interactive content of HTTP. Following is the code of `ConditionData`, the more detail about this class can refer to [code analysis](https://shenyu.apache.org/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI/) of `PredicteJudge`\\n\\n```java\\npublic class ConditionData {\\n\\n    private String paramType;\\n    private String operator;\\n\\n    private String paramName;\\n    private String paramValue;\\n}\\n```\\n\\n## AbstractMatchStrategy\\n\\nSecond, let\'s look at the abstract class `AbstractMatchStrategy`\uff0cit has defined a `buildRealData`  method\uff0cIn this method it wraps various parameters to a unified interface through the functionality of `ParameterDataFactory`,  which is the factory class of `ParameterData`. It supports a variety of types of  parameters , such as `Ip`, `Cookie`, `Header`,`uri`, etc.  Modifications of such parameters will not impact the calling of matching rules of `MatchStrategy`.\\n\\n```java\\npublic abstract class AbstractMatchStrategy {\\n\\n    public String buildRealData(final ConditionData condition, final ServerWebExchange exchange) {\\n        return ParameterDataFactory.builderData(condition.getParamType(), condition.getParamName(), exchange);\\n    }\\n}\\n```\\n\\n## Implementation class and profile\\n\\nNow, let\'s look at the two implementation class based on the above interface in  ***shenyu-plugin-base*** module , that is:\\n\\n- `AndMatchStrategy`- `AND` -All conditions are matched\\n\\n- `OrMatchStrategy`-   `OR` -at least one is match\\n\\n  The properties file containing the SPI implementation is shown as follows, which located at the `SHENYU_DIRECTORY`directory. When starting up, the top-level SPI classes will read the key-value and  load the classes and cache them.\\n\\n```properties\\nand=org.apache.shenyu.plugin.base.condition.strategy.AndMatchStrategy\\nor=org.apache.shenyu.plugin.base.condition.strategy.OrMatchStrategy\\n```\\n\\nThese two implementation classes inherit `AbstractMatchStrategy` class and implement `MatchStrategy` interface.\\n\\n### AndMatchStrategy-  \u201cAND\u201d relation\\n\\nSince the `PredicateJudge` interface can encapsulate different variety of Predicates , for example  EqualsPredicateJudge, EndsWithPredicateJudge and so on, the `ConditionData` and `ParamData` passed to it can present with variety of parameters, for treating of multiple conditions. So using`stream` and `lambda` expression, it can be very simple and efficient to process \\"AND\\" logic (all conditions must be matched).\\n\\n```java\\n@Join\\npublic class AndMatchStrategy extends AbstractMatchStrategy implements MatchStrategy {\\n\\n    @Override\\n    public Boolean match(final List<ConditionData> conditionDataList, final ServerWebExchange exchange) {\\n        return conditionDataList\\n                .stream()\\n                .allMatch(condition -> PredicateJudgeFactory.judge(condition, buildRealData(condition, exchange)));\\n    }\\n}\\n```\\n\\nThe `OrMatchStrategy` similarly implements the \\"OR\\" logic- at least one is match.\\n\\n## MatchStrategyFactory\\n\\nThis is the factory class of `MatchStrategy`\uff0cthere are  two methods,  one is `newInstance()`, which will return the `MatchStrategy` implementation class instance cached by the `SPI` `ExtensionLoader` indexed by the key-value.\\n\\n```java\\n    public static MatchStrategy newInstance(final Integer strategy) {\\n        String matchMode = MatchModeEnum.getMatchModeByCode(strategy);\\n        return ExtensionLoader.getExtensionLoader(MatchStrategy.class).getJoin(matchMode);\\n    }\\n```\\n\\nthe `matchMode` will be the name of strategy, the value will be \\"and\\" or \\"or\\". The `MatchModeEnum` defines the code and name of match strategy as follows.\\n\\n```java\\nAND(0, \\"and\\"), \\nOR(1, \\"or\\");\\n```\\n\\nAnother method is `match()` method, which will invoke the `match()` method of  implementation class. \\n\\n```java\\n    public static boolean match(final Integer strategy, final List<ConditionData> conditionDataList, final ServerWebExchange exchange) {\\n        return newInstance(strategy).match(conditionDataList, exchange);\\n    }\\n```\\n\\n## How it works\\n\\n`AbstractShenyuPlugin` is the base class of `plugins` in `shenyu-plugin` module. In this class two selection method are defined: `filterSelector()` and `filterRule()` , Both of them call the  `match()` method of `MatchStrategyFactory`. The code  of `filterSelector()` is shown as follows.\\n\\n```java\\n    private Boolean filterSelector(final SelectorData selector, final ServerWebExchange exchange) {\\n        if (selector.getType() == SelectorTypeEnum.CUSTOM_FLOW.getCode()) {\\n            if (CollectionUtils.isEmpty(selector.getConditionList())) {\\n                return false;\\n            }\\n            return MatchStrategyFactory.match(selector.getMatchMode(), selector.getConditionList(), exchange);\\n        }\\n        return true;\\n    }\\n```\\n\\nIn `filterSelector`() method, after validation of  the `SelectorData`, calls the `match` method of `MatchStrategyFactory`, and then this factory class will invokes the `match` method of corresponding implementation class. \\n\\n```java\\n    private Boolean filterRule(final RuleData ruleData, final ServerWebExchange exchange) {\\n        return ruleData.getEnabled() && MatchStrategyFactory.match(ruleData.getMatchMode(), ruleData.getConditionDataList(), exchange);\\n    }\\n```\\n\\nIn `filterRule()` it is also calls the  `match()` method of `MatchStrategyFactory`.  Does it look particularly concise or even simple?  In the [code analysis](https://shenyu.apache.org/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI/) of  `PredicteJudge` , you can  see more detail about parameter processing in `shenyu-plugin`.\\n\\n## Summary\\n\\nDue to the use of  `SPI` mechanism of `Apache Shenyu`, the parameter selection module has the characteristic of loose coupling and extensibility. In terms of  the combination of multiple conditions, `MatchStrategy` provides a good design.  Although currently only two implementation classes are present, it can be easily used to develop more complex `MatchStrategy` rules in the future,  such as \\"`firstOf`\\"-first condition must matched, or \\"`mostOf`\\"- most of the conditions must be matched, etc.\\n\\nInterested readers can read the source code of `\'shenyu-plugin\'` to learn more."},{"id":"/SPI-SourceCode-Analysis-PredicateJudge-SPI","metadata":{"permalink":"/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI.md","source":"@site/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI.md","title":"PredicateJudge -- analyze the design based on SPI","description":"Apache Shenyu has been identified as a gateway application which supports a variety of protocols and  microservice frameworks such as  Dubbo, gRPC, Spring-Cloud, etc.  To do this, the product has accomplished an elegant SPI (Service Provider Interface) as its foundation, and make the  Rule data parsing and predicting program very simple , resiliency and security. As to rule data parsing processing,  the SPI design increases the product\'s scalability. When appending new plugin, in most cases, the   existing module is enough for rule data parsing , otherwise it can be rapidly carry out with tiny effort.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"SPI","permalink":"/blog/tags/spi"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":5.435,"hasTruncateMarker":false,"authors":[{"name":"Huihui Yin","title":"Apache ShenYu Contributor"}],"frontMatter":{"title":"PredicateJudge -- analyze the design based on SPI","author":"Huihui Yin","author_title":"Apache ShenYu Contributor","tags":["SPI","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"MatchStrategy  -- analyze the design based on SPI","permalink":"/blog/SPI-SourceCode-Analysis-MatchStrategy-SPI"},"nextItem":{"title":"RateLimiter SPI code analysis","permalink":"/blog/SPI-SourceCode-Analysis-RateLimiter-SPI"}},"content":"**Apache Shenyu** has been identified as a gateway application which supports a variety of protocols and  microservice frameworks such as  Dubbo, gRPC, Spring-Cloud, etc.  To do this, the product has accomplished an elegant `SPI` (Service Provider Interface) as its foundation, and make the  Rule data parsing and predicting program very simple , resiliency and security. As to rule data parsing processing,  the `SPI` design increases the product\'s scalability. When appending new plugin, in most cases, the   existing module is enough for rule data parsing , otherwise it can be rapidly carry out with tiny effort. \\n\\n\\n## Top level design of SPI\\n\\n In `Apache Shenyu`, the `SPI` archtecure is defined in ***shenyu-spi*** module and composed of three parts:   `SPI` interface,  factory  design pattern,  and configuration file. There is  two interface defined as annotation: @SPI and @Join. When class file with  @Join annotation,  it means that it will join as an `SPI` extension class, in other words, it is an application or registration.  The  @SPI denotes that the class is an `SPI` extension class.\\n\\nFig 1 classes in the ***shenyu-spi***\\n\\n![toplevel-SPI](/img/activities/code-analysis-predicatejudge-spi/toplevel-SPI.png)\\n\\nThe SPI configuration directory is  `META-INF/shenyu/.`  that is specified:\\n\\n```java\\nSHENYU_DIRECTORY = \\"META-INF/shenyu/\\";\\n```\\n\\nWhen starting the gateway system , the `ExtensionLoader` will scan the profiles under  `SHENYU_DIRECTORY`,  in turn, load and validate and then  initialize each configed class. The configuration file uses  \\"Key = class-file\\" format.  During operation of the system,  the corresponding `SPI` implementation class will be invoked through the factory mechanism.\\n\\n## Implementation of shenyu-plugin SPI\\n\\nIn ***shenyu-plugin*** module,  various plugins for HTTP routing are implemented according to the plugin mechanism, including  request, redirect, response and rewrite, etc.  Plugins for microservice frameworks such as Dubbo, gRPC , Spring-Cloud and Tars have been developed in the gateway product.  And plugins are still increasing. If  no such  dependent module fo parsing and judge routing  parameters and data,  each plugin is necessary to implement the parsing functions, and has to frequently  modify  to support their matching rules, such as wildcard, regular expression, SpEL expression, etc. Therefore,  they made a high level abstraction for routing parameter data following the `SPI` framework in  ***shenyu-plugin*** module.  The rule analysis consists of three parts:\\n\\n- `ParameterData`- parameter data\\n\\n- `PredicatJudge`-  predicate whether the actural data match the rule\\n\\n- `MatchStrategy`- combine multiple conditions, the final used strategy\\n\\nThese implementation classes are defined in ***shenyu-plugin-base*** module. In each plugin, resolution and predication of  the routing parameter can be realized through `AbstractShenyuPlugin` using the above  `SPIs`. That is dedicated and easy to extend, in line with SOLID principle.\\n\\n\u200b      This section analyzes the  `PredictJudge` in detail. You can find the dependency to ***shenyu-spi*** in the pom.xml of this module.\\n\\n```xml\\n<dependency>\\n    <groupId>org.apache.shenyu</groupId>\\n    <artifactId>shenyu-spi</artifactId>\\n    <version>${project.version}</version>\\n</dependency>\\n```\\n\\n### Design of PredicateJudge SPI\\n\\n`PredicateJudge` `SPI`  is used to analyze and judge various routing rules configed in `Apache Shenyu` gateway.  The name and functions of this SPI are similar to [Predicate](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html)  in Java, but the acceptance behavior is further  abstracted applying for routing aspect. This `SPI` is implemented through the Factory pattern.  Let\'s look at the `Predictejudge` `SPI` interface:\\n\\n```java\\n@SPI\\n@FunctionalInterface\\npublic interface PredicateJudge {\\n\\n    /**\\n     * judge conditionData and realData is match.\\n     *\\n     * @param conditionData {@linkplain ConditionData}\\n     * @param realData       realData\\n     * @return true is pass  false is not pass.\\n     */\\n    Boolean judge(ConditionData conditionData, String realData);\\n}\\n```\\n\\nThe class diagram is as follows:\\n\\nFig 2-`Predicate` class diagram\\n\\n![predicate-class-diagram](/img/activities/code-analysis-predicatejudge-spi/predicate-class-diagram.png)\\n\\nThe important  methods of `PredicateJudgeFactory`  are shown as follows:\\n\\nWhenever need to parsing and matching routing data, you can use\\n\\n```java\\n    public static PredicateJudge newInstance(final String operator) {\\n        return ExtensionLoader.getExtensionLoader(PredicateJudge.class).getJoin(processSpecialOperator(operator));\\n    }\\n```\\n\\n```java\\n    public static Boolean judge(final ConditionData conditionData, final String realData) {\\n        if (Objects.isNull(conditionData) || StringUtils.isBlank(realData)) {\\n            return false;\\n        }\\n        return newInstance(conditionData.getOperator()).judge(conditionData, realData);\\n    }\\n```\\n\\n`ConditionData` contains of four attributes of String type: `paramType`, `operator`,`paramName`,`paramValue` \\n\\n#### ParamTypeEnum\\n\\nWhere **paramType** must be the  enumeration type  `ParamTypeEnum`. The default supported `paramType` are:\\n\\n```java\\npost, uri,query, host, ip,header, cookie,req_method\\n```\\n\\n#### OperatorEnum\\n\\n**operator** must be the enumeration type `OperatorEnum`, currently  supported operators are:\\n\\n```java\\n   match, =,regex, >,<, contains, SpEL,  Groovy, TimeBefore,TimeAfter\\n```\\n\\nBase on the above defination , the plugin module provides  the following  eight `PredicateJudge`  implemetation classes to realize the logic of these operators respectively. \\n\\n| Implementation class        | Logic description                                            | corespondece operator |\\n| --------------------------- | ------------------------------------------------------------ | --------------------- |\\n| `ContainsPredicateJudge`    | \\"contain\\" relation, the actual data needs contain the specified string | contains              |\\n| `EqualsPredicateJudge`      | equals \\"=\\"                                                   | =                     |\\n| `MatchPredicateJudge`       | used for URI context path matching                           | match                 |\\n| `TimerAfterPredicateJudge`  | Whether the local time is after the specified time           | TimeAfter             |\\n| `TimerBeforePredicateJudge` | Whether the local time is before the specified time          | TimeBefore            |\\n| `GroovyPredicateJudge`      | used Groovy syntax toe set ParamName and value data          | Groovy                |\\n| `RegexPredicateJudge`       | used Regex to match                                          | regex                 |\\n\\n### How to use PredicateJudge\\n\\nWhen you want to parse parameters, you only need to call `PredicateJudgeFactory` as follows. \\n\\n```java\\nPredicateJudgeFactory.judge(final ConditionData conditionData, final String realData);\\n```\\n\\n### SPI profile\\n\\nThe implementation class is configed in the file under directory `SHENYU_DIRECTORY` . It  will be loaded and cached at startup. \\n\\n```properties\\nequals=org.apache.shenyu.plugin.base.condition.judge.EqualsPredicateJudge\\n\\ncontains=org.apache.shenyu.plugin.base.condition.judge.ContainsPredicateJudge\\nGroovy=org.apache.shenyu.plugin.base.condition.judge.GroovyPredicateJudge\\nmatch=org.apache.shenyu.plugin.base.condition.judge.MatchPredicateJudge\\nregex=org.apache.shenyu.plugin.base.condition.judge.RegexPredicateJudge\\nSpEL=org.apache.shenyu.plugin.base.condition.judge.SpELPredicateJudge\\nTimeAfter=org.apache.shenyu.plugin.base.condition.judge.TimerAfterPredicateJudge\\nTimeBefore=org.apache.shenyu.plugin.base.condition.judge.TimerBeforePredicateJudge\\n```\\n\\n## The usage of PredicateJudge SPI in Shenyu gateway\\n\\nMost plugins in `Apache Shenyu` are inherited from `AbstractShenyuPlugin`.  In this abstract class, the filter functions (selection and matching) are achieved through  `MatchStrategy` `SPI`, and `PredicateJudge` will be invoked from `MatchStrategy`  to predicate each condition data. \\n\\nFig 3- class diagram of plugins with `PredicateJudge` and `MatchStrategy` `SPI`\\n\\n![plugin-SPI-class-diagram](/img/activities/code-analysis-predicatejudge-spi/plugin-SPI-class-diagram.png)\\n\\nThe process from client request  calling the routing parsing moodule is showed as following chart.\\n\\nFig 4- flow chart for Shenyu gateway filter  with parameter processing\\n\\n![SPI-flow-diagram](/img/activities/code-analysis-predicatejudge-spi/SPI-flow-diagram.png)\\n\\n- When startup, the system will load `SPI` classes from profile and cache them.\\n- When the client sends a new request to the Shenyu gateway,  will call the corresponding plugin within  the gateway.\\n- When analyzing real data with routing rules, the  `PredicateJudge` implementation class  will be invoked according to the contained operator.\\n\\n## Others\\n\\n### Examples of PredicateJudge  judgement\\n\\n#### ContainsPredicateJudge- \\" contains\u201c rule\\n\\nFor example, giving a `ConditionData`  with: `paramType`=\\"uri\\", `paramValue` \u662f \\"/http/**\\",  when using the \\"contains\\" relation: `ContainsPredicateJudge`, the matching result is as follows.\\n\\n| `ConditionData`  (operator=\\"contains\\") | real data             | judge result |\\n| -------------------------------------- | --------------------- | ------------ |\\n| paramType=\\"uri\\",    \\"/http/**\\"         | \\"/http/**/test\\"       | true         |\\n|                                        | \\"/test/http/**/other\\" | true         |\\n|                                        | \\"/http1/**\\"           | false        |\\n\\nAbout other `PredicateJudge` implemetantion classes, you  can  refer to the code and test classes."},{"id":"/SPI-SourceCode-Analysis-RateLimiter-SPI","metadata":{"permalink":"/blog/SPI-SourceCode-Analysis-RateLimiter-SPI","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-RateLimiter-SPI.md","source":"@site/blog/SPI-SourceCode-Analysis-RateLimiter-SPI.md","title":"RateLimiter SPI code analysis","description":"Rate limiter is a very important integral of  gateway application, to deal with  high traffic.  When the system is attacked abnormally by a large number of traffic gathered in a short time;  When there are a large number of lower priority request need to be slow down or else it  will effect your high  priority transactions;  Or sometimes your system can not afford the regular traffic; in these  scenarios, we need to start rate limiter component to protect our system,  through rejection, wait, load  shedding,etc,  limit the requests to an acceptable quantities, or only  certain domains (or services) requests can get through.","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"rate limiter","permalink":"/blog/tags/rate-limiter"},{"label":"SPI","permalink":"/blog/tags/spi"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":15.275,"hasTruncateMarker":false,"authors":[{"name":"Huihui Yin","title":"Apache ShenYu Contributor","url":"https://github.com/changanjennifer/"}],"frontMatter":{"title":"RateLimiter SPI code analysis","author":"Huihui Yin","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/changanjennifer/","tags":["rate limiter","SPI","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"PredicateJudge -- analyze the design based on SPI","permalink":"/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI"},"nextItem":{"title":"Guide for New Contributors to Start avoid Pitfalls","permalink":"/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor"}},"content":"*Rate limiter* is a very important integral of  gateway application, to deal with  high traffic.  When the system is attacked abnormally by a large number of traffic gathered in a short time;  When there are a large number of lower priority request need to be slow down or else it  will effect your high  priority transactions;  Or sometimes your system can not afford the regular traffic; in these  scenarios, we need to start *rate limiter* component to protect our system,  through rejection, wait, load  shedding,etc,  limit the requests to an acceptable quantities, or only  certain domains (or services) requests can get through.  \\n\\nFacing above scenarios, following need to be considered when designing the rate limiter component of an gateway.\\n\\n1. Supports a variety  of rate limiter algorithms and easy to extends.\\n2. Resilient resolvers  which can distinguish traffic by different way, such as  ip, url, even user group  etc.\\n3. High availability, can quickly get allow or reject result from rate limiter\\n4. With fault tolerance against when rate limiter is down, the gateway can continue work.\\n\\nThis article will first introduce the overall architecture of the rate limiter module in Apache Shenyu, and then focus on the code analysis of rate limiter SPI.\\n\\n> This article based on `shenyu-2.4.0` version of the source code analysis.\\n\\n## Overall design of RateLimiter\\n\\nSpring [WebFlux](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html) is reactive and  non-blocking web framework,  which can benefit throughput and  make applications more resilient. The plugin of `Apache Shenyu` is based on `WebFlux`\uff0cits rate limiter component is implemented in `ratelimiter-plugin`. In rate limiter process, the commonly used algorithms are token bucket, leaky bucket, etc.  To speed up concurrency performance,  the counting and calculation logic is treated in Redis, and Java code is responsible for  the transmission of parameters.  When applying Redis, the Lua script can be resident memory,  and be executed as  a whole, so it is atomic. Let alone the reducing of network overhead.  Redis commands abstraction and automatic serialization/deserialization with Redis store is provided in  [Spring Data Redis](https://spring.io/projects/spring-data-redis).   Because of based on reactive framework, the  Spring Redis Reactive is used in `ratelimiter-plugin`.\\n\\n The class diagram of this plugin is as follows, highlighting two packages related to `RateLimiter SPI`: resolver \u548calgorithm.\\n\\n![ratelimiter-package-diagram](/img/activities/code-analysis-ratelimiter-spi/ratelimiter-package-diagram.png)\\n\\n## Design of RateLimiter SPI\\n\\nHigh performance issue is  achieved through the architecture of Spring data+ Redis+Lua ,  two `SPI` are supplied in  `ratelimiter-plugin`  for the extension of algorithm and key resolver\u3002\\n\\n- RateLimiterAlgorithm\uff1aused for algorithms expansion.\\n- RateLimiterKeyResolver\uff1a used for resolver expansion, to distinguish requests by various information, including ip, url, ect.  \\n\\nThe profile of SPI is located at  directory of `SHENYU_DIRECTORY`  (default`/META-INF/shenyu`).\\n\\n### RateLimiterKeyResolver\\n\\nObtain the critical info of the request used for packet rate limiter\uff0cthe interface of `RateLimiterKeyResolver`  is follows\uff1a\\n\\n```java\\n@SPI\\npublic interface RateLimiterKeyResolver {\\n\\n    /**\\n     * get Key resolver\'s name.\\n     *\\n     * @return Key resolver\'s name\\n     */\\n    String getKeyResolverName();\\n\\n    /**\\n     * resolve.\\n     *\\n     * @param exchange exchange the current server exchange {@linkplain ServerWebExchange}\\n     * @return rate limiter key\\n     */\\n    String resolve(ServerWebExchange exchange);\\n}\\n\\n```\\n\\n`@SPI`  registers the current interface as  Apache Shenyu SPI. Method `resolve(ServerWebExchange exchange)` is used to provide  the resolution way.  Currently there are two key resolvers in  `RateLimiterKeyResolver`  `SPI`:`WholeKeyResolve` and `RemoteAddrKeyResolver`.  The  resolve method of `RemoteAddrKeyResolver`is as follows\uff1a\\n\\n```java\\n    @Override\\n    public String resolve(final ServerWebExchange exchange) {\\n        return Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\\n    }\\n```\\n\\nWhere the resolved key is ip of request.  Based on `SPI` mechanism and its factory pattern,  new resolver can be easily developed.\\n\\n### RateLimiterAlgorithm SPI\\n\\n`RateLimiterAlgorithm` `SPI` is used to identify and define different rate limiter algorithms, following is the class diagram of this module.\\n\\n![ratelimiteral-class-diagram](/img/activities/code-analysis-ratelimiter-spi/ratelimiteral-class-diagram.png)\\n\\nIn this module, factory pattern is used , providing interface, abstract class and factory class, and four implementation classes. The `lua` script corresponding to the implementation class is enumerated in `RateLimitEnum` and located in  `/META-INF/scripts`.\\n\\n```java\\n@SPI\\npublic interface RateLimiterAlgorithm<T> {\\n    \\n    RedisScript<T> getScript();\\n    List<String> getKeys(String id);\\n    \\n    /**\\n     * Callback string.\\n     *\\n     * @param script the script\\n     * @param keys the keys\\n     * @param scriptArgs the script args\\n     */\\n    default void callback(final RedisScript<?> script, final List<String> keys, final List<String> scriptArgs) {\\n    }\\n}\\n```\\n\\n`@SPI`  registers the current interface as  Apache Shenyu SPI. There are three methods:\\n\\n- `getScript()` returns a `RedisScript` object, which will be passed to Redis.\\n- `getKeys(String id)`  returns a List contains with  keys.\\n- `callback()` the callback function which will be executed asynchronously later on, and default is an empty method.\\n\\n#### AbstractRateLimiterAlgorithm\\n\\nThe template method is implemented in this abstract class, and the reified generics used is `List<Long>`. Two abstract methods getScriptName()  and getKeyName()  are left for  the implementation class. Following is the code to load `lua` script.\\n\\n```java\\n    public RedisScript<List<Long>> getScript() {\\n        if (!this.initialized.get()) {\\n            DefaultRedisScript redisScript = new DefaultRedisScript<>();\\n            String scriptPath = \\"/META-INF/scripts/\\" + getScriptName();\\n            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptPath)));\\n            redisScript.setResultType(List.class);\\n            this.script = redisScript;\\n            initialized.compareAndSet(false, true);\\n            return redisScript;\\n        }\\n        return script;\\n    }\\n```\\n\\n`initialized`  is an `AtomicBoolean`  type variable used to indicate whether the `lua` script is loaded.  If has not been loaded, the system will read specified scripts form `META-INF/scripts`;  After reading,  specify the result with `List` type, and set  `initialized=true`, then returning  `RedisScript`object.\\n\\nThe code of `getKeys()`  in `AbstractRateLimiterAlgorithm` is  as follows:\\n\\n```java\\n    @Override\\n    public List<String> getKeys(final String id) {\\n        String prefix = getKeyName() + \\".{\\" + id;\\n        String tokenKey = prefix + \\"}.tokens\\";\\n        String timestampKey = prefix + \\"}.timestamp\\";\\n        return Arrays.asList(tokenKey, timestampKey);\\n    }\\n```\\n\\nTwo strings are generated in this template method, where the `tokenKey` will work as Key to a Sorted map in Redis.  \\n\\nWe can observe from above class diagram that  `ConcurrentRateLimiterAlgorithm` and `SlidingWindowRateLimiterAlgorithm`  override `getKeys(String id)` method  but another two implementation classes not, and use template method in `AbstractRateLimiterAlgorithm`. Only  in  `ConcurrentRateLimiterAlgorithm` has override callback() method, the others not.  We will do further analysis in the following.\\n\\n#### RateLimiterAlgorithmFactory\\n\\nThe  method gets`RateLimiterAlgorithm` instance  by `name`  in  `RateLimiterAlgorithmFactory` is as follows:\\n\\n```java\\npublic static RateLimiterAlgorithm<?> newInstance(final String name) {\\n    return Optional.ofNullable(ExtensionLoader.getExtensionLoader(RateLimiterAlgorithm.class).getJoin(name)).orElse(new TokenBucketRateLimiterAlgorithm());\\n}\\n```\\n\\n`ExtensionLoader` of `SPI` is responsible for loading SPI classes by \\"name\\", if cannot find the specified algorithm class, it will return `TokenBucketRateLimiterAlgorithm` by default.\\n\\n### Data access with Redis\\n\\nAbove detailed the  extension interface in `RateLimiter` `SPI`. In Apache Shenyu, we use `ReactiveRedisTemplate`  to perform   Redis processing reactively, which is implemented  in`isAllowed()` method of `RedisRateLimiter` class.\\n\\n```java\\n    public Mono<RateLimiterResponse> isAllowed(final String id, final RateLimiterHandle limiterHandle) {\\n        // get parameters that will pass to redis from RateLimiterHandle Object\\n        double replenishRate = limiterHandle.getReplenishRate();\\n        double burstCapacity = limiterHandle.getBurstCapacity();\\n        double requestCount = limiterHandle.getRequestCount();\\n        // get the current used RateLimiterAlgorithm\\n        RateLimiterAlgorithm<?> rateLimiterAlgorithm = RateLimiterAlgorithmFactory.newInstance(limiterHandle.getAlgorithmName());\\n        \\n        ........\\n        Flux<List<Long>> resultFlux = Singleton.INST.get(ReactiveRedisTemplate.class).execute(script, keys, scriptArgs);\\n        return resultFlux.onErrorResume(throwable -> Flux.just(Arrays.asList(1L, -1L)))\\n                .reduce(new ArrayList<Long>(), (longs, l) -> {\\n                    longs.addAll(l);\\n                    return longs;\\n                }).map(results -> {\\n                    boolean allowed = results.get(0) == 1L;\\n                    Long tokensLeft = results.get(1);\\n                    return new RateLimiterResponse(allowed, tokensLeft);\\n                })\\n                .doOnError(throwable -> log.error(\\"Error occurred while judging if user is allowed by RedisRateLimiter:{}\\", throwable.getMessage()))\\n                .doFinally(signalType -> rateLimiterAlgorithm.callback(script, keys, scriptArgs));\\n    }\\n```\\n\\nThe `POJO` class `RateLimiterHandle` wraps the parameters needed in rate limiter, they are `algorithName`, `replenishRate`, `burstCapacity`, `requestCount`, etc.  First, gets the parameters  that need to be passed into Redis from `RateLimiterHandle` class. Then obtain the current implementation class from `RateLimiterAlgorithmFactory`.\\n\\nFor convenience,  we give an flow image to show the parameters I/O  and execution procedure in Java and Redis respectively.  On the left is the second half of `isAllowed`() ,  and on the right is the processing of `Lua` script.\\n\\nFollowing is the execution process of the JAVA code.\\n\\n1. Get two keys value in `List<String>` type from the `getKeys()` method, the first element  will map to a sorted set in Redis.\\n\\n2. Set four parameters,  `replenishRate` ,  `burstCapacity`,  `timestamp` (`EpochSecond`) and `requestcount`.\\n\\n3. Calling `ReactiveRedisTemplate` with the scripts, keys and parameters,  the return a  `Flux<List<Long>>`\\n\\n4. The  return value is converted from `Flux<ArrayList<Long>>` to `Mono<ArrayList<Long>>` the through `reduce()` of `Flux` \uff0cand then transform it to `Mono<RateLimiterResponse>` via `map()` function.  Returned two data, one is `allowed` (1-allow, 0- not allowed),  the other is `tokensLeft`, the number of available remaining request.  \\n\\n5. As for the fault tolerance,  due to using of reactor non-blocking model, when an error occurs, the fallback  function `onErrorResume()` will be executed and a new stream `(1L, -1L)` will  generated by `Flux.just,` which means  allow the request getting through, and log the error on the side.  \\n\\n6. After that, performs the  `doFinally()`  method, that is to execute the callback() method of the implementation class.\\n\\n![io-with-lua](/img/activities/code-analysis-ratelimiter-spi/io-with-lua.png)\\n\\n## Four rate limiter algorithms\\n\\nFrom above we  know that  how the  java code works with Redis in the gateway. In this chapter we briefly analysis some code of the  four rate limiter algorithms, to understand how to develop the interface of  `RateLimiter SPI`  and work efficiently with Redis.  \\n\\nFour rate limiter algorithms are supplied in Apache Shenyu `Ratelimit SPI`:\\n\\n| Algorithm name            | Java class                          | Lua script file                        |\\n| ------------------------- | ----------------------------------- | -------------------------------------- |\\n| Request rate limiter      | `TokenBucketRateLimiterAlgorithm`   | request_rate_limiter.lua               |\\n| Slide window rate limiter | `SlidingWindowRateLimiterAlgorithm` | liding_window_request_rate_limiter.lua |\\n| Concurrent rate limiter   | `ConcurrentRateLimiterAlgorithm`    | concurrent_request_rate_limiter.lua    |\\n| Leaky bucket algorithm    | `LeakyBucketRateLimiterAlgorithm`   | request_leaky_rate_limiter.lua         |\\n\\n1. Token bucket rate limiter\uff1a Limiting the traffic according to the number of requests. Assuming that *N* requests can be passed per second, when requests exceeding *N* will be rejected.  In implementing of the algorithm, the requests will be grouped by bucket,  the tokens will be generated at an evenly rate.  If  the number of requests is less than the tokens in the bucket, then it is allowed to pass.  The time window is 2* capacity/rate.\\n2. Slide window rate limiter:   Different from token bucket algorithm, its window size is smaller than that of token bucket rate limiter,  which is a capacity/rate.  And move backward one time window at a time. Other rate limiter principles are similar to token bucket.\\n3. Concurrent rate limiter\uff1a Strictly limit the concurrent requests to *N*. Each time when there is a new request, it will check whether the number of concurrent requests is greater than N. If it is less than `N`, it is allowed to pass through, and the count is increased by 1. When the requests call ends, the signal is released (count minus 1).\\n4. Leaky bucket rate limiter:   In contrast with token bucket algorithm, the leaky bucket algorithm can help to smooths the burst of requests and only allows a pre-defined *N* number of requests. This limiter can force the output flow at a constant rate of *N*.  It is based on a leaky bucket model, the leaky water quantity is  time interval*rate.  if the leaky water quantity is greater than the number of has used (represented by `key_bucket_count`), then clear the bucket, that is, set the `key_bucket_count` to 0. Otherwise, set `key_bucket_count`  minus the leaky water quantity.  If the number  (requests + `key_bucket_count` ) is less than the capacity, then allow the requests passing through.\\n\\nLet\'s understand the functionality of  `callback()` by reading concurrent rate limiter code, and understand the usage of `getKeys()` through reading the  Lua script of token rate limiter and slide window rate limiter.\\n\\n### callback() used in Concurrent requests limiter\\n\\nThe `getKeys()`  method of `ConcurrentRateLimiterAlgorithm` overrides the template method in `AbstractRateLimiterAlgorithm` \uff1a\\n\\n```java\\n    @Override\\n    public List<String> getKeys(final String id) {\\n        String tokenKey = getKeyName() + \\".{\\" + id + \\"}.tokens\\";\\n        String requestKey = UUIDUtils.getInstance().generateShortUuid();\\n        return Arrays.asList(tokenKey, requestKey);\\n    }\\n```\\n\\nThe second element, `requestKey`  is a long type and non-duplicate  value (generated by a distributed ID generator\uff0cit is incremented and smaller than the current time Epochsecond value). The corresponding `Lua` script in `concurrent_request_rate_limiter.lua`:\\n\\n```lua\\nlocal key = KEYS[1]\\n\\nlocal capacity = tonumber(ARGV[2])\\nlocal timestamp = tonumber(ARGV[3])\\nlocal id = KEYS[2]\\n```\\n\\nHere `id`  is `requestKey`  generated by `getKeys()` method, it is an `uuid`(unique value).  Subsequent process is as follows:\\n\\n```lua\\nlocal count = redis.call(\\"zcard\\", key)\\nlocal allowed = 0\\n\\nif count < capacity then\\n  redis.call(\\"zadd\\", key, timestamp, id)\\n  allowed = 1\\n  count = count + 1\\nend\\nreturn { allowed, count }\\n```\\n\\nFirst, using `zcard` command to obtain the cardinality  of the sorted set, and set count equals the  cardinality , if the cardinality is less than the capacity, we will add a new member `id` (it is an `uuid`) to the sorted set, with the score of current time(in seconds) . then `count =count+1`, the cardinality is also incremented by 1 in reality.\\n\\nAll of the code above is executed in Redis as an atomic transaction.  If there are a large number of concurrent requests from the same key( such as ip) , the cardinality of the sorted set of this key will increasing sharply, when then capacity limit is exceeded, the  service will be denied, that is `allowed =0`\u3002\\n\\nIn concurrent requests limiter, It is required to release the semaphore when the request is completed. However, it is not included in Lua script.\\n\\nLet\'s see the callback function of  `ConcurrentRateLimiterAlgorithm`\uff1a\\n\\n```java\\n    @Override\\n    @SuppressWarnings(\\"unchecked\\")\\n    public void callback(final RedisScript<?> script, final List<String> keys, final List<String> scriptArgs) {\\n        Singleton.INST.get(ReactiveRedisTemplate.class).opsForZSet().remove(keys.get(0), keys.get(1)).subscribe();\\n    }\\n```\\n\\nHere gives asynchronous subscription, using `ReactiveRedisTemplate` to delete the elements  (`key`,`id`)  in Redis store. That is once the request operation ends, the semaphore will be released.  This remove operation  cannot be executed in Lua script. This is just what design intention of `callback` in `RateLimiterAlgorithm` `SPI` .\\n\\n### getKeys() used  in token bucket rate limiter\\n\\nFollowing is the corresponding Lua code:\\n\\n```java\\nlocal tokens_key = KEYS[1]\\nlocal timestamp_key = KEYS[2]\\n```\\n\\nHere we omit the code that get the parameters of rate ,capacity, etc.\\n\\n```lua\\nlocal fill_time = capacity/rate\\nlocal ttl = math.floor(fill_time*2)\\n```\\n\\nThe window size variable(ttl) is approximately  two times of  capacity/rate.\\n\\n```lua\\nlocal last_tokens = tonumber(redis.call(\\"get\\", tokens_key))\\nif last_tokens == nil then\\n  last_tokens = capacity\\nend\\n```\\n\\nGet last_tokens from the sorted set, if it not exist, then last_tokens equals capacity.\\n\\n```lua\\nlocal last_refreshed = tonumber(redis.call(\\"get\\", timestamp_key))\\nif last_refreshed == nil then\\n  last_refreshed = 0\\nend\\n```\\n\\nGet the last refreshed time by the key =timestamp_key from the sorted set, and default 0.\\n\\n```lua\\nlocal delta = math.max(0, now-last_refreshed)\\nlocal filled_tokens = math.min(capacity, last_tokens+(delta*rate))\\nlocal allowed = filled_tokens >= requested\\nlocal allowed_num = 0\\nif allowed then\\n  new_tokens = filled_tokens - requested\\n  allowed_num = 1\\nend\\n\\n```\\n\\nThe filled_tokens is produced evenly by time interval * rate\uff0cif the number of tokens greater than requests, then allowed=1,  and update  new_tokens.\\n\\n```lua\\nredis.call(\\"setex\\", tokens_key, ttl, new_tokens)\\nredis.call(\\"setex\\", timestamp_key, ttl, now)\\n\\nreturn { allowed_num, new_tokens }\\n```\\n\\nHere `now` is  current time parameters passed in,  set `tokens_key` to hold the string `new_tokens` and set`tokens_key` to timeout after `ttl` of seconds.  Set  `timestamp_key` to hold the string value `now`, and expires after `ttl` seconds.\\n\\n### getKeys() used  in sliding window rate limiter\\n\\nThe  `getKeys()` in `SlidingWindowRateLimiterAlgorithm` also overrides the parent class, and the code is consistent with the method in `ConcurrentRateLimiterAlgorithm`\\n\\nFollowing is the Lua code of slide window rate limiter, the  receiving of other parameters is omitted.\\n\\n```lua\\nlocal timestamp_key = KEYS[2]\\n...... \\nlocal window_size = tonumber(capacity / rate)\\nlocal window_time = 1\\n```\\n\\nHere set the window_size to capacity/rate.\\n\\n```lua\\nlocal last_requested = 0\\nlocal exists_key = redis.call(\'exists\', tokens_key)\\nif (exists_key == 1) then\\n    last_requested = redis.call(\'zcard\', tokens_key)\\nend\\n```\\n\\nObtain the cardinality(`last_requested`) of the `tokens_key` in the sorted set.\\n\\n```lua\\nlocal remain_request = capacity - last_requested\\nlocal allowed_num = 0\\nif (last_requested < capacity) then\\n    allowed_num = 1\\n    redis.call(\'zadd\', tokens_key, now, timestamp_key)\\nend\\n```\\n\\nCalculate remaining available `remain_request` equals  capacity minus `last_requested` .  If  `last_requested` less than  capacity ,then allow current requests passing through\uff0cadd element in the sorted set with (key=`timestamp_key`, value=`now`) .\\n\\n```lua\\nredis.call(\'zremrangebyscore\', tokens_key, 0, now - window_size / window_time)\\nredis.call(\'expire\', tokens_key, window_size)\\n\\nreturn { allowed_num, remain_request }\\n```\\n\\nPreviously has set `window_time`=1, using `zremrangebyscore` command of Redis to remove all the elements in the sorted set stored at  `tokens_key` with a score in [0,now - window_size / window_time] ,  that is,  move the window a window size. Set the expire time of `tokens_key`  to `window_size`.\\n\\nIn the template method `getKeys(final String id)`  of `AbstractRateLimiterAlgorithm`\uff0cthe second key ( represented y `secondKey`)  is a  fixed string which concat  the input parameter\\\\{id}. As we can see from the above three algorithm codes, in the token bucket algorithm,  `secondKey` will be updated to the latest time in the Lua code, so it doesn\'t matter what value is passed in.  In the concurrent rate limiter, `secondKey` will be used as the key to remove Redis data in the java `callback` method.  In the sliding window algorithm, the  `secondKey` will be added to the sorted set  as the key of a new element, and will be removed during window sliding.\\n\\nThat\'s all, when in a new rate limiter algorithm, the `getKeys(final String id)`method should be carefully designed according to the logic of the algorithm.\\n\\n## How to use RateLimiter SPI\\n\\nThe three parameters in `doExecute()` method of  `RateLimiter` plugin\uff0c `exchange`  is an web request\uff0c `chain`  is the execution chain of the plugins\uff0c`selector` is the selection parameters\uff0c`rule`  is the  policies or rules of rate limiter setting in the system.\\n\\n```java\\nprotected Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\\n    //get  the `RateLimiterHandle` parameters from cache \\n    RateLimiterHandle limiterHandle = RatelimiterRuleHandleCache.getInstance()\\n        .obtainHandle(CacheKeyUtils.INST.getKey(rule));\\n    //find the resolver name \\n    String resolverKey = Optional.ofNullable(limiterHandle.getKeyResolverName())\\n        .flatMap(name -> Optional.of(\\"-\\" + RateLimiterKeyResolverFactory.newInstance(name).resolve(exchange)))\\n        .orElse(\\"\\");\\n    return redisRateLimiter.isAllowed(rule.getId() + resolverKey, limiterHandle)\\n        .flatMap(response -> {\\n            if (!response.isAllowed()) {\\n                exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);\\n                Object error = ShenyuResultWrap.error(ShenyuResultEnum.TOO_MANY_REQUESTS.getCode(), ShenyuResultEnum.TOO_MANY_REQUESTS.getMsg(), null);\\n                return WebFluxResultUtils.result(exchange, error);\\n            }\\n            return chain.execute(exchange);\\n        });\\n}\\n```\\n\\n1. Firstly get the `RateLimiterHandle`  parameters from cache.\\n2. Obtains the corresponding Key resolver by `RateLimiterHandle` instance.  \\n\\n3. Reactively executes `isAllowed()`  method of  `RedisRateLimiter`.\\n4. If not allowed, error handling is performed.\\n5. If the request is allowed, dispatch it to the next process of execution chain.\\n\\n## Summary\\n\\n`RateLimiter` plugin is based on `Spring WebFlux`,and with `Apache Shen SPI`, with Redis and Lua script to responsible for the critical algorithm and logic process, make it with characteristics of high concurrency and elastic.  As for the `RateLimiter SPI`.\\n\\n1. `RateLimiter` `SPI` provides two `SPI` interface, with interface oriented design and various design patterns, it\'s easy to develop new rate limiter algorithm and key resolver rule.\\n2. `RateLimiterAlgorithm` `SPI` supplies four rate limiter algorithms, token bucket,concurrency rate limiter, leaky bucket and sliding window rate limiter. When designing rate limiter algorithm, the KEY generation need to be carefully designed according to the algorithm characteristic.  Using Lua script to realize the logic of the algorithm, and  design callback()  method for asynchronous processing when needed.\\n3. Reactive programming, simple and efficient implementation."},{"id":"/Start-SourceCode-Analysis-Start-Demo-for-Contributor","metadata":{"permalink":"/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor.md","source":"@site/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor.md","title":"Guide for New Contributors to Start avoid Pitfalls","description":"Preface","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"first-start","permalink":"/blog/tags/first-start"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":5.415,"hasTruncateMarker":false,"authors":[{"name":"Yuxuan Zhang","title":"Apache ShenYu Contributor","url":"https://github.com/zuobiao-zhou","imageURL":"https://avatars.githubusercontent.com/u/61108539?s=400&u=f065b78a2944f2cea9160de7f7df054e2f157867&v=4"}],"frontMatter":{"title":"Guide for New Contributors to Start avoid Pitfalls","author":"Yuxuan Zhang","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/zuobiao-zhou","author_image_url":"https://avatars.githubusercontent.com/u/61108539?s=400&u=f065b78a2944f2cea9160de7f7df054e2f157867&v=4","tags":["first-start","Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"RateLimiter SPI code analysis","permalink":"/blog/SPI-SourceCode-Analysis-RateLimiter-SPI"},"nextItem":{"title":"Apache ShenYu Start Demo","permalink":"/blog/Start-SourceCode-Analysis-Start-Demo"}},"content":"## Preface\\n\\nAs a first-time developer in the `Shenyu` community, I encountered some \\"Pitfalls\\" that were not mentioned in the tutorials I followed to start and develop the project. I have documented the detailed steps I took to start `shenyu`, `shenyu-dashboard`, `shenyu-website` in this blog, hoping to help more new contributors in the community.\\n\\n## Environmental Preparation\\n\\n- Correct local installation of `JDK17+`\\n- Properly install `Git` locally\\n- Correctly install Maven `3.6.3+`\\n- Choose a development tool, this article uses `IDEA` as an example\\n\\n## ShenYu Backend Startup Guide\\n\\n### Install and Configure Maven\\n\\nMaven is a cross-platform project management tool . As the Apache organization\'s top open source projects , its main service for Java-based platform project creation , dependency management and project information management.\\n\\n1. [Download maven](https://maven.apache.org/download.cgi) and extract it to a path with no Chinese and no spaces.\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/maven-install.png\\" width=\\"100%\\" height=\\"100%\\" />\\n\\n2. Add the `bin` directory under the `maven` directory to the environment variables. For `Windows`, if the download directory is `E:\\\\apache-maven-3.9.1`, add `E:\\\\apache-maven-3.9.1\\\\bin` to the `Path` system variable.\\n\\n3. Verify that the installation was successful. Type `mvn -v` in the cmd window, and if the Maven version and Java version appear, the installation is successful. This is shown below:\\n\\n    ```shell\\n    C:\\\\Users\\\\pc>mvn -v\\n    Apache Maven 3.9.1 (2e178502fcdbffc201671fb2537d0cb4b4cc58f8)\\n    Maven home: E:\\\\apache-maven-3.9.1\\n    Java version: 18.0.1.1, vendor: Oracle Corporation, runtime: C:\\\\Program Files\\\\Java\\\\jdk-18.0.1.1\\n    Default locale: zh_CN, platform encoding: UTF-8\\n    OS name: \\"windows 10\\", version: \\"10.0\\", arch: \\"amd64\\", family: \\"windows\\"\\n    ```\\n\\n4. To speed up the download of project-related dependencies, you need to change the Maven mirrors, here add Aliyun and other mirrors. Change the `<mirrors> </mirrors>` tag pair in `conf/settings.xml` to the following:\\n\\n    ```xml\\n    <mirrors>\\n        <mirror>\\n        <id>alimaven</id>\\n        <name>aliyun maven</name>\\n        <url>http://maven.aliyun.com/nexus/content/groups/public/</url>\\n        <mirrorOf>central</mirrorOf>\\n        </mirror>\\n\\n        <mirror>\\n        <id>alimaven</id>\\n        <mirrorOf>central</mirrorOf>\\n        <name>aliyun maven</name>\\n        <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>\\n        </mirror>\\n\\n        <mirror>\\n        <id>maven</id>\\n        <mirrorOf>central</mirrorOf>\\n        <name>name_</name>\\n        <url>http://repo1.maven.org/maven2</url>\\n        </mirror> \\n\\n        <mirror>\\n        <id>junit</id>\\n        <mirrorOf>central</mirrorOf>\\n        <name>junit address/</name>\\n        <url>http://jcenter.bintray.com/</url>\\n        </mirror>\\n    </mirrors>\\n    ```\\n\\n    and add `<localRepository>E:/maven_local_repository</localRepository>` to the next line of `</mirrors>` to set the location of Maven local repository. You can specify the exact location yourself.\\n\\n### Pull ShenYu Code\\n\\n1. Fork [ShenYu](https://github.com/apache/shenyu) repository on Github to your own repository, where you can develop and commit PRs in the future\\n2. Use Git to download the repository from the previous step locally:\\n\\n    ```shell\\n    git clone git@github.com:${YOUR_USERNAME}/${TARGET_REPO}.git\\n    ```\\n\\n    If prompted for a long file name, execute the following command via the command line:\\n\\n    ```shell\\n    git config --global core.longpaths true\\n    ```\\n\\n   Tips: If you encounter the following error or have network issues preventing you from pulling all the code:\\n\\n   ``` tex\\n   RPC failed; curl 92 HTTP/2 stream 5 was not closed cleanly: CANCEL (err 8) 2057 bytes of body are still expected fetch-pack: unexpected disconnect while reading sideband packet early EOF fetch-pack: invalid index-pack output\\n   ```\\n\\n   You can execute the following commands to first pull a single version of the code, then fetch the full code:\\n\\n   ``` shell\\n   git clone https://github.com/apache/shenyu.git --depth 1\\n   cd ./shenyu\\n   git fetch --unshallow\\n   ```\\n\\n### ShenYu First Start\\n\\n#### Preparation\\n\\n1. Compile with Maven in the `shenyu` directory:\\n\\n    ```shell\\n    mvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests\\n    ```\\n\\n2. Configure IDEA environment. Open `shenyu` project with IDEA, click `File` -> `Settings` in the top left corner, and configure Maven as shown below. Where `User settings file` select your `settings.xml` directory, and then `Local repository` will automatically load the `localRepository` path set in `settings.xml`:\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/idea-config.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n3. At this point, IDEA will automatically download the project-related dependencies, you need to wait for a while, when finished, as shown in the following figure:\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/project-without-example.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n    As you can see, `shenyu-e2e`, `shenyu-examples`, `shenyu-integrated-test` are not marked as Maven projects by IDEA and need to be added manually. Select the `pom.xml` file in the package and right-click `Add as Maven Project`. \\n    If the shenyu-e2e build fails, then add the `<relativePath>. /pom.xml</relativePath>` to `<relativePath/>`.\\n\\n#### Start Gateway Service\\n\\n1. Start the `shenyu-admin` console (H2 database is used by default)\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/admin.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n2. start `shenyu-bootstrap`\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/bootstrap.png\\" width=\\"100%\\" height=\\"100%\\" />\\n\\n> By this point, the shenyu gateway has been started.\\n>\\n> We can open the browser and access the admin console: [http://localhost:9095/](http://localhost:9095/)\\n>\\n> Default account: admin , default password: 123456\\n\\n#### Start Application Service\\n\\nApache ShenYu provides samples of Http, Dubbo, SpringCloud and other applications to access the shenyu gateway, located in the `shenyu-example` module, here the `Http service` is used as an example.\\n\\nStart `shenyu-examples-http`\u3002\\n\\n<img src=\\"/img/activities/start-demo-for-contributor/shenyu-examples-http.png\\" width=\\"80%\\" height=\\"80%\\" />\\n\\nAt this point, `shenyu-examples-http` will automatically register the interface methods annotated with `@ShenyuSpringMvcClient` and the relevant configuration in application.yml to the gateway. We can open the [admin console](http://localhost:9095/) and see the configuration in `Client List -> Proxy -> divide`.\\n\\n#### Test Http Request\\n\\nThe following uses the `IDEA HTTP Client Plugin` to mock http to access http services.\\n- Local access without using shenyu proxy\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/shenyu-http-test-api-local.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n- Use shenyu proxy\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/shenyu-http-test-api.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n### Use more plugins\\n\\nWe can refer to the [official documentation](https://shenyu.apache.org/docs/index) to the left of `Plugins collection` to use the required plugins.\\n\\n## Shenyu Front End Startup Guide\\n\\n### Install Node.js\\n\\n#### Download\\n\\n1. Download and install Node.js from [official website](https://nodejs.org/en) and select `LTS` version.\\n2. When installing, except for setting the installation path, just keep clicking `Next`.\\n3. After the installation is complete, verify at the command line:\\n    \\n    ```shell\\n    C:\\\\Users\\\\pc>node -v\\n    v12.22.12\\n\\n    C:\\\\Users\\\\pc>npm -v\\n    6.14.16\\n    ```\\n\\n### Pull ShenYu Dashboard Code\\n\\n1. Fork [ShenYu Dashboard](https://github.com/apache/shenyu-dashboard) repository\\n2. Using Git to download locally\\n\\n    ```shell\\n    git clone git@github.com:${YOUR_USERNAME}/${TARGET_REPO}.git\\n    ```\\n\\n### Front and Back End Co-development\\n\\n1. Add `enablePrintApiLog: true` to the `shenyu-admin/src/main/resources/application.yml` file in the backend repository `shenyu` as shown below to show the log of frontend interface calls in the backend console.\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/enable-api-log.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n2. Start `ShenyuAdminBootstrap`\\n\\n3. Switch to the front-end repository `shenyu-dashboard`, open `README`, click `npm install`, `npm start` or enter the above command from cmd to access the front-end interface via [http://localhost:8000](http://localhost:8000), and display the log of the front-end interface called in the back-end console. Realize the co-development of front-end and back-end.\\n\\n    <img src=\\"/img/activities/start-demo-for-contributor/admin-log.png\\" width=\\"60%\\" height=\\"60%\\" />\\n\\n### Package Front-end Code\\n\\nExecute the `npm build` command in `README` and copy all the generated files from the `dist` folder to the `shenyu-admin/src/main/resources/static/` directory in the backend repository.\\n\\n## Contribute to Shenyu Official Website\\n\\nJust follow the `README` in [shenyu-website](https://github.com/apache/shenyu-website).\\n\\n### Tips\\n\\n1. I recommend downloading the `LTS` version from the `Node` [website](https://nodejs.org/en).\\n2. `Windows` systems cannot be deployed, if you want to verify your changes, you can deploy on a Linux virtual machine or server."},{"id":"/Start-SourceCode-Analysis-Start-Demo","metadata":{"permalink":"/blog/Start-SourceCode-Analysis-Start-Demo","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/Start-SourceCode-Analysis-Start-Demo.md","source":"@site/blog/Start-SourceCode-Analysis-Start-Demo.md","title":"Apache ShenYu Start Demo","description":"Environmental preparation","date":"2025-12-03T09:35:04.000Z","formattedDate":"December 3, 2025","tags":[{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":1.395,"hasTruncateMarker":false,"authors":[{"name":"Kunshuai Zhu","title":"Apache ShenYu Contributor","url":"https://github.com/JooKS-me","imageURL":"https://avatars1.githubusercontent.com/u/62384022?v=4"}],"frontMatter":{"title":"Apache ShenYu Start Demo","author":"Kunshuai Zhu","author_title":"Apache ShenYu Contributor","author_url":"https://github.com/JooKS-me","author_image_url":"https://avatars1.githubusercontent.com/u/62384022?v=4","tags":["Apache ShenYu"]},"unlisted":false,"prevItem":{"title":"Guide for New Contributors to Start avoid Pitfalls","permalink":"/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor"},"nextItem":{"title":"SPI Source Code Analysis","permalink":"/blog/SPI-SourceCode-Analysis-SPI"}},"content":"### Environmental preparation\\n\\n- Install JDK1.8+ locally\\n- Install Git locally\\n- Install Maven locally\\n- Choose a development tool, such as IDEA\\n\\n### Pull ShenYu code\\n\\nUse Git to clone code\\n\\n```shell\\ngit clone https://github.com/apache/shenyu.git\\n```\\n\\n### Compile code\\n\\nCompile with Maven\\n\\n```shell\\ncd shenyu\\nmvn clean install -Dmaven.javadoc.skip=true -B -Drat.skip=true -Djacoco.skip=true -DskipITs -DskipTests\\n```\\n\\n### Start the gateway service\\n\\nUse development tools, take IDEA as an example.\\n\\nStart `shenyu-admin` (use H2 database by default)\\n\\n![start-demo-admin](/img/activities/start-demo/start-demo-admin.png)\\n\\nStart `shenyu-bootstrap`\\n\\n![start-demo-bootstrap](/img/activities/start-demo/start-demo-bootstrap.png)\\n\\n> At this point, shenyu gateway has been activated.\\n>\\n> We can open the browser and access the admin console: [http://localhost:9095/](http://localhost:9095/)\\n\\n### Start application service\\n\\nApache ShenYu provides examples for Http, Dubbo, SpringCloud and other applications to access the shenyu gateway, located in the `shenyu-example` module. Here we take the Http service as an example.\\n\\nIf `shenyu-example` is not marked as a Maven project by IDEA, you can right-click the `pom.xml` file in the `shenyu-example` directory to add it as a Maven project.\\n\\n![start-demo-maven](/img/activities/start-demo/start-demo-maven.png)\\n\\nStart `shenyu-examples-http`\u3002\\n\\n![start-demo-examples-http](/img/activities/start-demo/start-demo-examples-http.png)\\n\\nAt this time, `shenyu-examples-http` will automatically register the interface method annotated with `@ShenyuSpringMvcClient` and the related configuration in application.yml to the gateway. When we open the admin console, you can see the relevant configuration in divide and context-path.\\n\\n### Test Http request\\n\\nNow use `postman` to simulate `http` to request your `http` service:\\n\\n![start-demo-post-http](/img/activities/start-demo/start-demo-post-http.png)\\n\\n### Use more plugins\\n\\nWe can refer to [Official Document](https://shenyu.apache.org/docs/index) to use other plugins.\\n\\nHere is an example of using the param-mapping plugin.\\n\\nEdit the param-mapping plugin in `BasicConfig -> Plugin` and set `status`.\\n\\n![start-demo-plugin](/img/activities/start-demo/start-demo-plugin.png)\\n\\nConfigure selectors and rules in `PluginList -> http process`.\\n\\n![start-demo-selector](/img/activities/start-demo/start-demo-selector.png)\\n\\n![start-demo-rules](/img/activities/start-demo/start-demo-rules.png)\\n\\nThen use `postman` to make an http request to `/http/test/payment`.\\n\\n![start-demo-post-param-mapping](/img/activities/start-demo/start-demo-post-param-mapping.png)"},{"id":"/SPI-SourceCode-Analysis-SPI","metadata":{"permalink":"/blog/SPI-SourceCode-Analysis-SPI","editUrl":"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-SPI.md","source":"@site/blog/SPI-SourceCode-Analysis-SPI.md","title":"SPI Source Code Analysis","description":"Apache ShenYu is an asynchronous, high-performance, cross-language, responsive API gateway.","date":"2022-09-12T00:00:00.000Z","formattedDate":"September 12, 2022","tags":[{"label":"SPI","permalink":"/blog/tags/spi"},{"label":"Apache ShenYu","permalink":"/blog/tags/apache-shen-yu"}],"readingTime":17.335,"hasTruncateMarker":false,"authors":[{"name":"Throwable","url":"https://github.com/zjcscut/"}],"frontMatter":{"title":"SPI Source Code Analysis","author":"Throwable","author_url":"https://github.com/zjcscut/","tags":["SPI","Apache ShenYu"],"date":"2022-09-12T00:00:00.000Z"},"unlisted":false,"prevItem":{"title":"Apache ShenYu Start Demo","permalink":"/blog/Start-SourceCode-Analysis-Start-Demo"}},"content":"> [Apache ShenYu](https://shenyu.apache.org/zh/docs/index) is an asynchronous, high-performance, cross-language, responsive API gateway.\\n\\n## background\\n\\nRecently,when I read the source code of open source project Apache Shenyu API gateway,I find and many core components of the gateway are loaded with the SPI module. Here I will analyzes the source code of `SPI` module in `Shenyu` gateway.\\n\\n## what is SPI\\n\\n`SPI` means \'Service Provider Interface\', which is a dynamic Service discovery mechanism. We can dynamically load the implementation class of the Interface based on the runtime of the Interface (that is, a development mode of Interface programming + strategy  pattern + configuration file) with it. The most common is the built-in database Driver interface \'java.sql.Driver\' in JDK. Different vendors can implement this interface differently. For example, \'MySQL\' (\'com.mysql.jdbc.Driver\' in the \'MySQL\' Driver package),\' PostgreSQL\' (\'org.postgresql.driver\' in the \'PostgreSQL\' Driver package), etc.\\n\\n![spi-jdk-api-diagram](/img/activities/code-analysis-spi/spi-jdk-api-diagram-en.png)\\n\\nThe JDK\'s built-in \'SPI\' can be used as follows:\\n\\n- In the \'META-INF/services\' directory of the classpath, create a file named with the fully qualified name of the interface (essentially a \'properties\' file) whose implementation classes you want the SPI loader to load , for example if you want to load the SQL driver implementation classes mentioned above then create a file named \'java.sql.Driver\' since those classes implement the \'java.sql.driver\' interface.\\n\\n- In this file we can add entries for all the specific implementations of the interface . For example for the above driver class scenario we would add entries as shown in below code snippet in the file `META-INF/services/java.sql.Driver`\\n\\n```java\\n# content of file META-INF/services/java.sql.Driver\\ncom.mysql.jdbc.Driver\\norg.postgresql.Driver\\n```\\n\\n- Finally load the file with \'java.util.ServiceLoader\' to instantiate the corresponding implementation class of the interface\\n\\n```\\n\\nServiceLoader<Driver> loader = ServiceLoader.load(Driver.class)\\n```\\n\\nThe underlying implementation involves classloading, the parent delegate model, and so on, which I won\'t expand here. Based on this design idea, many mainstream frameworks self-implemented a set of \'SPI\' extension, such as \'Dubbo SPI\' extension module, which would read the \'META-INF/services/dubbo\' directory file content in the classppath for class loading. The \'shenyu-spi\' module also follows this similar design idea.\\n\\n## source code of shenyu-spi\\n\\nThe \'shenyu-spi\' module is very concise, and the code structure is as follows:\\n\\n```properties\\n- shenyu-spi[module]\\n  - org.apache.shenyu.spi[package]\\n    -- ExtensionFactory\\n    -- ExtensionLoader\\n    -- Join\\n    -- SPI\\n    -- SpiExtensionFactory\\n```\\n\\n\u8fd9\u4e9b\u7c7b\u529f\u80fd\u5982\u4e0b\uff1a\\n\\n- \'ExtensionFactory\' : \'SPI\' loader Factory, used to load an \'ExtensionLoader\' instance based on the \'SPI\' mechanism and to obtain the default \'SPI\' identity implementation based on the \'ExtensionLoader\' instance\\n- \'SpiExtensionFactory\' : is an implementation of \'ExtensionFactory\'\\n- \'SPI\' : identification annotation, used to identify \'SPI\', used on the interface\\n- \'Join\' : identification annotation, used on the implementation class, used to identify the class joining the SPI system\\n- \'ExtensionLoader\' : \'SPI\' loader, analogous to \'java.util.ServiceLoader\', used to load the implementation class of the interface in \'SPI\'\\n\\n### @SPI\\n\\n`org.apache.shenyu.spi.SPI` is an identification annotation which is used for identifying an interface as a \'SPI\' interface.That is, only interfaces that use \'@SPI\' annotation can be loaded by \'shenyu-spi\'. The class\'s annotation describes the implementation of Apache Dubbo, a reference to all the SPI systems (which makes sense, since the SPI extension is already a mature scheme with much the same implementation). This annotation has only one method:\\n\\n```java\\n@Documented\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target(ElementType.TYPE)\\npublic @interface SPI {\\n\\n    /**\\n     * Value string.\\n     *\\n     * @return the string\\n     */\\n    String value() default \\"\\";\\n}\\n```\\n\\nThe unique \'value()\' method is used to specify the default \'SPI\' implementation (optional), as will be shown later when analyzing \'ExtensionLoader\'.\\n\\n### @Join\\n\\n`org.apache.shenyu.spi.Join` is an identification annotation too. When this annotation is used on a class it specifies that  the class contains \'SPI\' implementation and to indicate that the class is added to the SPI system and can be loaded by ExtensionLoader. This annotation has two methods:\\n\\n```java\\n@Documented\\n@Retention(RetentionPolicy.RUNTIME)\\n@Target(ElementType.TYPE)\\npublic @interface Join {\\n    \\n    /**\\n     * It will be sorted according to the current serial number..\\n     * @return int.\\n     */\\n    int order() default 0;\\n\\n    /**\\n     * Indicates that the object joined by @Join is a singleton,\\n     * otherwise a completely new instance is created each time.\\n     * @return true or false.\\n     */\\n    boolean isSingleton() default true;\\n}\\n```\\n\\nThe unique \'order()\' method is used to specify the specific sequence number. If a single interface that annotated with \'@SPI\' has multiple implementation classes that annotated with \'@Join\', the sequence number determines the order of these implementation class instances (the smaller one comes first).\\n\\nThe isSingleton() method indicates whether the class that the implementation class is a singleton class or not. That is if it is a singleton class it will be instantiated only once else it will create a new instance everytime . \\n\\n### ExtensionLoader\\n\\n\'ExtensionLoader\' is the core of the \'SPI\' module. Look at it\'s attributes first:\\n\\n```java\\npublic final class ExtensionLoader<T> {\\n    \\n    // SLF4J\u65e5\u5fd7\u53e5\u67c4\\n    private static final Logger LOG = LoggerFactory.getLogger(ExtensionLoader.class);\\n    \\n    // SPI\u914d\u7f6e\u6587\u4ef6\u57fa\u4e8e\u7c7b\u8def\u5f84\u4e0b\u7684\u76f8\u5bf9\u76ee\u5f55\\n    private static final String SHENYU_DIRECTORY = \\"META-INF/shenyu/\\";\\n    \\n    // @SPI\u6807\u8bc6\u63a5\u53e3\u7c7b\u578b -> ExtensionLoader\u5b9e\u4f8b\u7684\u7f13\u5b58 => \u6ce8\u610f\u8fd9\u4e2a\u662f\u4e00\u4e2a\u5168\u5c40\u7684\u9759\u6001\u53d8\u91cf\\n    private static final Map<Class<?>, ExtensionLoader<?>> LOADERS = new ConcurrentHashMap<>();\\n    \\n    // \u5f53\u524d@SPI\u6807\u8bc6\u63a5\u53e3\u7c7b\u578b\\n    private final Class<T> clazz;\\n    \\n    // \u7c7b\u52a0\u8f7d\u5668\u5b9e\u4f8b\\n    private final ClassLoader classLoader;\\n    \\n    // \u5f53\u524dExtensionLoader\u7f13\u5b58\u7684\u5df2\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u4fe1\u606f\uff0c\u4f7f\u7528\u503c\u6301\u6709\u5668\u5305\u88c5\uff0c\u662f\u4e00\u4e2aHashMap\uff0c\u6620\u5c04\u5173\u7cfb\uff1a\u5b9e\u73b0\u7c7b\u522b\u540d -> \u5b9e\u73b0\u7c7b\u4fe1\u606f\\n    private final Holder<Map<String, ClassEntity>> cachedClasses = new Holder<>();\\n    \\n    // \u5f53\u524dExtensionLoader\u7f13\u5b58\u7684\u5df2\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\u7684\u503c\u5305\u88c5\u5668\uff0c\u4f7f\u7528\u503c\u6301\u6709\u5668\u5305\u88c5\uff0c\u6620\u5c04\u5173\u7cfb\uff1a\u5b9e\u73b0\u7c7b\u522b\u540d -> \u503c\u6301\u6709\u5668\u5305\u88c5\u7684\u5b9e\u73b0\u7c7b\u5b9e\u4f53\\n    private final Map<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<>();\\n    \\n    // \u5f53\u524dExtensionLoader\u7f13\u5b58\u7684\u5df2\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\uff0c\u4f7f\u7528\u503c\u6301\u6709\u5668\u5305\u88c5\uff0c\u6620\u5c04\u5173\u7cfb\uff1a\u5b9e\u73b0\u7c7b\u7c7b\u578b -> \u5b9e\u73b0\u7c7b\u5b9e\u4f53\\n    private final Map<Class<?>, Object> joinInstances = new ConcurrentHashMap<>();\\n    \\n    // \u7f13\u5b58\u9ed8\u8ba4\u540d\u79f0\uff0c\u6765\u6e90\u4e8e@SPI\u6ce8\u89e3\u7684value()\u65b9\u6cd5\u975e\u7a7a\u767d\u8fd4\u56de\u503c\uff0c\u7528\u4e8e\u52a0\u8f7d\u9ed8\u8ba4\u7684\u63a5\u53e3\u5b9e\u73b0\\n    private String cachedDefaultName;\\n    \\n    // Holder\u6bd4\u8f83\u5668\uff0c\u6309\u7167Holder\u7684order\u964d\u5e8f\uff0c\u4e5f\u5c31\u662f\u987a\u5e8f\u53f7\u5c0f\u7684\u6392\u5728\u524d\u9762\\n    private final Comparator<Holder<Object>> holderComparator = Comparator.comparing(Holder::getOrder);\\n    \\n    // ClassEntity\u6bd4\u8f83\u5668\uff0c\u6309\u7167ClassEntity\u7684order\u964d\u5e8f\uff0c\u4e5f\u5c31\u662f\u987a\u5e8f\u53f7\u5c0f\u7684\u6392\u5728\u524d\u9762\\n    private final Comparator<ClassEntity> classEntityComparator = Comparator.comparing(ClassEntity::getOrder);\\n    \\n    // \u6682\u65f6\u7701\u7565\u5176\u4ed6\u4ee3\u7801\\n\\n    // \u503c\u6301\u6709\u5668\uff0c\u7b80\u5355VO\uff0c\u7528\u6765\u5b58\u50a8\u6cdb\u578b\u503c\u548c\u503c\u52a0\u8f7d\u987a\u5e8f\\n    public static class Holder<T> {\\n        \\n        // \u8fd9\u91cc\u7684\u503c\u5f15\u7528\u662fvolatile\u4fee\u9970\uff0c\u4fbf\u4e8e\u67d0\u7ebf\u7a0b\u66f4\u53d8\u53e6\u4e00\u7ebf\u7a0b\u9a6c\u4e0a\u8bfb\u5230\u6700\u65b0\u7684\u503c\\n        private volatile T value;\\n        \\n        private Integer order;\\n\\n        private boolean isSingleton;\\n        \\n        // \u7701\u7565setter\u548cgetter\u4ee3\u7801\\n    }\\n    \\n    // \u7c7b\u5b9e\u4f53\uff0c\u4e3b\u8981\u5b58\u653e\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u7684\u4fe1\u606f\\n    static final class ClassEntity {\\n        \\n        // \u540d\u79f0\uff0c\u8fd9\u91cc\u662f\u6307SPI\u5b9e\u73b0\u7c7b\u7684\u522b\u540d\uff0c\u4e0d\u662f\u7c7b\u540d\\n        private String name;\\n        \\n        // \u52a0\u8f7d\u987a\u5e8f\u53f7\\n        private Integer order;\\n\\n        private Boolean isSingleton;\\n        \\n        // SPI\u5b9e\u73b0\u7c7b\\n        private Class<?> clazz;\\n\\n        private ClassEntity(final String name, final Integer order, final Class<?> clazz, final boolean isSingleton) {\\n            this.name = name;\\n            this.order = order;\\n            this.clazz = clazz;\\n            this.isSingleton = isSingleton;\\n        }\\n        \\n        // \u7701\u7565setter\u548cgetter\u4ee3\u7801\\n    }\\n}\\n```\\n\\nAfter analyzing the attributes, it is not difficult to find the following points:\\n\\n- \'ExtensionLoader\' There will be a global static cache \'LOADERS\' to cache already created instances of \'ExtensionLoader\' to prevent the performance overhead of repeated creation\\n- Each \'@SPI\' interface that is loaded using \'ExtensionLoader\' generates a new instance of \'ExtensionLoader\'\\n- \'@SPI\' interfaces that have multiple implementations are eventually acquired in order\\n\\nThen look at it\'s constructors and static factory methods:\\n\\n```java\\n// \u79c1\u6709\u6784\u9020\u51fd\u6570\uff0c\u9700\u8981\u5165\u53c2\u4e3a@SPI\u6807\u8bc6\u7684\u63a5\u53e3\u7c7b\u578b\u548c\u7c7b\u52a0\u8f7d\u5668\u5b9e\u4f8b\\nprivate ExtensionLoader(final Class<T> clazz, final ClassLoader cl) {\\n    // \u6210\u5458\u53d8\u91cfclazz\u8d4b\u503c\\n    this.clazz = clazz;\\n    // \u6210\u5458\u53d8\u91cfclassLoader\u8d4b\u503c\\n    this.classLoader = cl;\\n    // \u8fd9\u91cc\u5bf9\u4e8e\u975eExtensionFactory\u63a5\u53e3\u7c7b\u578b\u4f1a\u61d2\u52a0\u8f7d\u4e00\u4e2a\u7528\u4e8e\u52a0\u8f7dExtensionFactory\u7684ExtensionLoader\\n    if (!Objects.equals(clazz, ExtensionFactory.class)) {\\n        ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getExtensionClassesEntity();\\n    }\\n}\\n\\n// \u5b9e\u4f8b\u5316getExtensionLoader\uff0c\u9759\u6001\u5de5\u5382\u65b9\u6cd5\uff0c\u9700\u8981\u5165\u53c2\u4e3a@SPI\u6807\u8bc6\u7684\u63a5\u53e3\u7c7b\u578b\u548c\u7c7b\u52a0\u8f7d\u5668\u5b9e\u4f8b\\npublic static <T> ExtensionLoader<T> getExtensionLoader(final Class<T> clazz, final ClassLoader cl) {\\n    // \u524d\u7f00\u6821\u9a8c\uff0c\u63a5\u53e3\u7c7b\u578b\u5fc5\u987b\u975e\u7a7a\u5e76\u4e14\u5fc5\u987b\u5b58\u5728@SPI\u6ce8\u89e3\uff0c\u5426\u5219\u629b\u51fa\u5f02\u5e38\u4e2d\u65ad\\n    Objects.requireNonNull(clazz, \\"extension clazz is null\\");\\n    if (!clazz.isInterface()) {\\n        throw new IllegalArgumentException(\\"extension clazz (\\" + clazz + \\") is not interface!\\");\\n    }\\n    if (!clazz.isAnnotationPresent(SPI.class)) {\\n        throw new IllegalArgumentException(\\"extension clazz (\\" + clazz + \\") without @\\" + SPI.class + \\" Annotation\\");\\n    }\\n    // \u4ece\u7f13\u5b58LOADERS\u4e2d\u52a0\u8f7dExtensionLoader\u5b9e\u4f8b\uff0c\u4e0d\u5b58\u5728\u5219\u521b\u5efa\uff0c\u5178\u578b\u7684\u61d2\u52a0\u8f7d\u6a21\u5f0f\\n    ExtensionLoader<T> extensionLoader = (ExtensionLoader<T>) LOADERS.get(clazz);\\n    if (Objects.nonNull(extensionLoader)) {\\n        return extensionLoader;\\n    }\\n    LOADERS.putIfAbsent(clazz, new ExtensionLoader<>(clazz, cl));\\n    return (ExtensionLoader<T>) LOADERS.get(clazz);\\n}\\n\\n// \u5b9e\u4f8b\u5316getExtensionLoader\uff0c\u9759\u6001\u5de5\u5382\u65b9\u6cd5\uff0c\u9700\u8981\u5165\u53c2\u4e3a@SPI\u6807\u8bc6\u7684\u63a5\u53e3\u7c7b\u578b\uff0c\u4f7f\u7528ExtensionLoader\u7c7b\u7684\u7c7b\u52a0\u8f7d\u5668\\npublic static <T> ExtensionLoader<T> getExtensionLoader(final Class<T> clazz) {\\n    return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader());\\n}\\n```\\n\\n\'ExtensionLoader\' uses a private constructor, static factory methods, and lazy loading mode. Class loading is not triggered after initializing \'ExtensionLoader\'. The actual scanning and loading is delayed until the \'getJoin\' series methods are called, where the code is swept and all the method call chains that implement class information are loaded:\\n\\n```java\\n// \u52a0\u8f7d\u6240\u6709\u6269\u5c55\u7c7b\u4fe1\u606f\uff0c\u8fd9\u91cc\u91c7\u7528\u4e86DCL\uff08\u53cc\u91cd\u9501\u6821\u9a8c\uff09\u9632\u6b62\u5e76\u53d1\u52a0\u8f7d\\nprivate Map<String, ClassEntity> getExtensionClassesEntity() {\\n    // \u7f13\u5b58\u4e0d\u5b58\u5728\\n    Map<String, ClassEntity> classes = cachedClasses.getValue();\\n    if (Objects.isNull(classes)) {\\n        // \u52a0\u9501\u540e\u518d\u68c0\u67e5\u4e00\u6b21\u7f13\u5b58\\n        synchronized (cachedClasses) {\\n            classes = cachedClasses.getValue();\\n            if (Objects.isNull(classes)) {\\n                // \u6700\u7ec8\u786e\u8ba4\u7f13\u5b58\u4e0d\u5b58\u5728\uff0c\u5219\u8fdb\u884c\u52a0\u8f7d\uff0c\u5e76\u4e14\u6807\u8bb0\u987a\u5e8f\u53f7\u4e3a0\\n                classes = loadExtensionClass();\\n                cachedClasses.setValue(classes);\\n                cachedClasses.setOrder(0);\\n            }\\n        }\\n    }\\n    return classes;\\n}\\n\\n// \u52a0\u8f7d\u5f53\u524dExtensionLoader\u4e2dclazz\u7684\u6240\u6709SPI\u7cfb\u7edf\u5185\u7684\u5b9e\u73b0\u7c7b\\nprivate Map<String, ClassEntity> loadExtensionClass() {\\n    SPI annotation = clazz.getAnnotation(SPI.class);\\n    if (Objects.nonNull(annotation)) {\\n        // \u8fd9\u91cc\u5c31\u662f\u524d\u9762\u63d0\u5230\uff0c\u5982\u679c@SPI\u6ce8\u89e3\u7684value()\u65b9\u6cd5\u975e\u7a7a\u767d\u8fd4\u56de\u503c\u4f1a\u4f5c\u4e3a\u9ed8\u8ba4\u5b9e\u73b0\u7684\u522b\u540d\\n        // \u4e5f\u5c31\u662f\u5982\u679c\u53ea\u4f7f\u7528\u4e86@SPI\uff0c\u90a3\u4e48\u5c31\u65e0\u6cd5\u83b7\u53d6\u9ed8\u8ba4\u5b9e\u73b0\\n        // \u5982\u679c\u4f7f\u7528\u4e86@SPI(\\"foo\\")\uff0c\u53ef\u4ee5\u901a\u8fc7\u522b\u540dfoo\u53bb\u6620\u5c04\u548c\u83b7\u53d6\u9ed8\u8ba4\u5b9e\u73b0\\n        String value = annotation.value();\\n        if (StringUtils.isNotBlank(value)) {\\n            cachedDefaultName = value;\\n        }\\n    }\\n    // \u521d\u59cb\u5316\u4e00\u4e2aHashmap\u5bb9\u5668\u7528\u4e8e\u5b58\u50a8\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u4fe1\u606f\uff0c\u8fd9\u4e2a\u53d8\u91cf\u4f1a\u900f\u4f20\u5230\u4e0b\u4e00\u4e2a\u65b9\u6cd5\u94fe\\n    Map<String, ClassEntity> classes = new HashMap<>(16);\\n    // \u52a0\u8f7d\u76ee\u5f55\u4e2d\u7684\u5c5e\u6027\u6587\u4ef6\\n    loadDirectory(classes);\\n    return classes;\\n}\\n\\n// \u52a0\u8f7d\u76ee\u5f55\u4e2d\u7684\u5c5e\u6027\u6587\u4ef6\uff0c\u5e76\u4e14\u52a0\u8f7d\u6587\u4ef6\u4e2d\u7684\u5b9e\u73b0\u7c7b\uff0c\u76ee\u6807\u76ee\u5f55\uff1aMETA-INF/shenyu/\\nprivate void loadDirectory(final Map<String, ClassEntity> classes) {\\n    // \u6587\u4ef6\u540d => META-INF/shenyu/$className\\n    String fileName = SHENYU_DIRECTORY + clazz.getName();\\n    try {\\n        // \u8fd9\u91cc\u4f7f\u7528\u7c7b\u52a0\u8f7d\u5668\u52a0\u8f7d\u6587\u4ef6\u8d44\u6e90\uff0c\u5982\u679c\u4f20\u5165\u7684\u7c7b\u52a0\u8f7d\u5668\u4e3a\u7a7a\u4f1a\u4f7f\u7528\u7cfb\u7edf\u7c7b\u52a0\u8f7d\u5668\\n        Enumeration<URL> urls = Objects.nonNull(this.classLoader) ? classLoader.getResources(fileName)\\n                : ClassLoader.getSystemResources(fileName);\\n        // \u904d\u5386\u89e3\u6790\u7684\u6587\u4ef6URL\u96c6\u5408\\n        if (Objects.nonNull(urls)) {\\n            while (urls.hasMoreElements()) {\\n                URL url = urls.nextElement();\\n                // \u901a\u8fc7\u6587\u4ef6URL\u52a0\u8f7d\u8d44\u6e90\\n                loadResources(classes, url);\\n            }\\n        }\\n    } catch (IOException t) {\\n        LOG.error(\\"load extension class error {}\\", fileName, t);\\n    }\\n}\\n\\n// \u52a0\u8f7d\u6587\u4ef6\u8d44\u6e90\uff0c\u89e3\u6790\u6587\u4ef6\u5e76\u4e14\u52a0\u8f7d\u5b9e\u73b0\u7c7b\u5b58\u50a8\u5230classes\u4e2d\\nprivate void loadResources(final Map<String, ClassEntity> classes, final URL url) throws IOException {\\n    // \u8bfb\u53d6URL\u6587\u4ef6\u8d44\u6e90\uff0c\u52a0\u8f7d\u5230Properties\u4e2d\uff0c\u6bcf\u884c\u683c\u5f0f\u4e3aname=classPath\\n    try (InputStream inputStream = url.openStream()) {\\n        Properties properties = new Properties();\\n        properties.load(inputStream);\\n        properties.forEach((k, v) -> {\\n            String name = (String) k;\\n            String classPath = (String) v;\\n            if (StringUtils.isNotBlank(name) && StringUtils.isNotBlank(classPath)) {\\n                try {\\n                    // \u57fa\u4e8ename\u548cclassPath\u8fdb\u884c\u7c7b\u52a0\u8f7d\\n                    loadClass(classes, name, classPath);\\n                } catch (ClassNotFoundException e) {\\n                    throw new IllegalStateException(\\"load extension resources error\\", e);\\n                }\\n            }\\n        });\\n    } catch (IOException e) {\\n        throw new IllegalStateException(\\"load extension resources error\\", e);\\n    }\\n}\\n\\n// \u57fa\u4e8ename\uff08\u522b\u540d\uff09\u548cclassPath\uff08\u7c7b\u5168\u9650\u5b9a\u540d\u79f0\uff09\u8fdb\u884c\u7c7b\u52a0\u8f7d\\nprivate void loadClass(final Map<String, ClassEntity> classes,\\n                        final String name, final String classPath) throws ClassNotFoundException {\\n    // \u7c7b\u521d\u59cb\u5316\uff0c\u5e76\u4e14\u786e\u5b9a\u5b9e\u73b0\u7c7b\u5fc5\u987b\u662f\u5f53\u524d@SPI\u6ce8\u89e3\u6807\u8bc6\u63a5\u53e3\u7684\u5b50\u7c7b\\n    Class<?> subClass = Objects.nonNull(this.classLoader) ? Class.forName(classPath, true, this.classLoader) : Class.forName(classPath);\\n    if (!clazz.isAssignableFrom(subClass)) {\\n        throw new IllegalStateException(\\"load extension resources error,\\" + subClass + \\" subtype is not of \\" + clazz);\\n    }\\n    // \u5b9e\u73b0\u7c7b\u5fc5\u987b\u5b58\u5728\u6ce8\u89e3@Join\\n    if (!subClass.isAnnotationPresent(Join.class)) {\\n        throw new IllegalStateException(\\"load extension resources error,\\" + subClass + \\" without @\\" + Join.class + \\" annotation\\");\\n    }\\n    // \u5982\u679c\u7f13\u5b58\u4e2d\u4e0d\u5b58\u5728\u540c\u6837\u522b\u540d\u7684\u5b9e\u73b0\u7c7b\u624d\u8fdb\u884c\u7f13\u5b58\uff0c\u5df2\u7ecf\u5b58\u5728\u5219\u6821\u9a8c\u65e7\u7684\u7c7b\u578b\u548c\u5f53\u524d\u5b9e\u73b0\u7c7b\u578b\u662f\u5426\u4e00\u81f4\\n    ClassEntity oldClassEntity = classes.get(name);\\n    if (Objects.isNull(oldClassEntity)) {\\n        // \u521b\u5efa\u7c7b\u4fe1\u606f\u5b9e\u4f53\u4fdd\u5b58\u522b\u540d\u3001\u987a\u5e8f\u53f7\u548c\u5b9e\u73b0\u7c7b\u5e76\u4e14\u7f13\u5b58\uff0c\u6620\u5c04\u5173\u7cfb\uff1a\u522b\u540d -> \u7c7b\u4fe1\u606f\u5b9e\u4f53\\n        Join joinAnnotation = subClass.getAnnotation(Join.class);\\n        ClassEntity classEntity = new ClassEntity(name, joinAnnotation.order(), subClass);\\n        classes.put(name, classEntity);\\n    } else if (!Objects.equals(oldClassEntity.getClazz(), subClass)) {\\n        throw new IllegalStateException(\\"load extension resources error,Duplicate class \\" + clazz.getName() + \\" name \\"\\n                + name + \\" on \\" + oldClassEntity.getClazz().getName() + \\" or \\" + subClass.getName());\\n    }\\n}\\n```\\n\\nProcessing with the chain of method \'getExtensionClassesEntity - > loadExtensionClass - > loadDirectory - > loadResources - > LoadClass\',it will create a mapping of \'alias\' to \'implementation class information\' for subsequent instantiations, as shown in the \'getJoin()\' method:\\n\\n```java\\n// \u57fa\u4e8e\u522b\u540d\u83b7\u53d6\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\\npublic T getJoin(final String name) {\\n    // \u522b\u540d\u5fc5\u987b\u4e3a\u975e\u7a7a\u767d\u5b57\u7b26\u4e32\\n    if (StringUtils.isBlank(name)) {\\n        throw new NullPointerException(\\"get join name is null\\");\\n    }\\n    // \u8fd9\u91cc\u4e5f\u4f7f\u7528DCL\u53bbcachedInstances\u7f13\u5b58\u4e2d\u53d6\u522b\u540d\u5bf9\u5e94\u7684\u503c\u6301\u6709\u5668\uff0c\u503c\u6301\u6709\u5668\u4e3a\u7a7a\u5219\u521b\u5efa\\n    Holder<Object> objectHolder = cachedInstances.get(name);\\n    if (Objects.isNull(objectHolder)) {\\n        cachedInstances.putIfAbsent(name, new Holder<>());\\n        objectHolder = cachedInstances.get(name);\\n    }\\n    Object value = objectHolder.getValue();\\n    if (Objects.isNull(value)) {\\n        synchronized (cachedInstances) {\\n            // \u52a0\u9501\u540e\u518d\u6b21\u5224\u65ad\u503c\u6301\u6709\u5668\u4e2d\u7684\u503c\u662f\u5426\u5b58\u5728\uff0c\u4e0d\u5b58\u5728\u7684\u65f6\u5019\u5219\u8fdb\u884c\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\u5316\\n            value = objectHolder.getValue();\\n            if (Objects.isNull(value)) {\\n                Holder<T> pair = createExtension(name);\\n                value = pair.getValue();\\n                int order = pair.getOrder();\\n                // \u5b9e\u4f8b\u5316\u5b8c\u6210\u540e\u66f4\u65b0\u503c\u6301\u6709\u5668\u7f13\u5b58\\n                objectHolder.setValue(value);\\n                objectHolder.setOrder(order);\\n            }\\n        }\\n    }\\n    return (T) value;\\n}\\n\\n// \u57fa\u4e8e\u522b\u540d\u641c\u7d22\u5df2\u7ecf\u52a0\u8f7d\u7684\u5b9e\u73b0\u7c7b\u4fe1\u606f\uff0c\u5e76\u4e14\u5b9e\u4f8b\u5316\u5bf9\u5e94\u7684\u5b9e\u73b0\u7c7b\u8fdb\u884c\u503c\u5305\u88c5\\nprivate Holder<T> createExtension(final String name) {\\n    // \u52a0\u8f7d\u8be5@SPI\u6807\u8bc6\u63a5\u53e3\u7684\u6240\u6709\u5b9e\u73b0\u7c7b\u4fe1\u606f\u5e76\u4e14\u83b7\u53d6\u5bf9\u5e94\u522b\u540d\u7684\u5b9e\u73b0\u7c7b\u4fe1\u606f\\n    ClassEntity classEntity = getExtensionClassesEntity().get(name);\\n    if (Objects.isNull(classEntity)) {\\n        throw new IllegalArgumentException(\\"name is error\\");\\n    }\\n    Class<?> aClass = classEntity.getClazz();\\n    // \u5982\u679c\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\u7f13\u5b58\u4e2d\u5df2\u7ecf\u5b58\u5728\uff0c\u5219\u76f4\u63a5\u5c01\u88c5\u4e3a\u503c\u5305\u88c5\u5668\u8fd4\u56de\uff0c\u5426\u5219\u8fdb\u884c\u5b9e\u4f8b\u5316\\n    Object o = joinInstances.get(aClass);\\n    if (Objects.isNull(o)) {\\n        try {\\n            // \u53cd\u5c04\u5b9e\u4f8b\u5316\u5e76\u4e14\u7f13\u5b58\u8be5\u5b9e\u73b0\u7c7b\u5b9e\u4f8b\\n            joinInstances.putIfAbsent(aClass, aClass.newInstance());\\n            o = joinInstances.get(aClass);\\n        } catch (InstantiationException | IllegalAccessException e) {\\n            throw new IllegalStateException(\\"Extension instance(name: \\" + name + \\", class: \\"\\n                    + aClass + \\")  could not be instantiated: \\" + e.getMessage(), e);\\n            \\n        }\\n    }\\n    Holder<T> objectHolder = new Holder<>();\\n    objectHolder.setOrder(classEntity.getOrder());\\n    objectHolder.setValue((T) o);\\n    return objectHolder;\\n}\\n```\\n\\nAs you can see from the \'createExtension()\' method, we end up using reflection to instantiate the implementation class. The reflection method \'newInstance()\' requires that the class must provide a no-argument constructor because of an implicit convention: The \'SPI\' implementation class **must provide a no-argument constructor** or the instantiation will fail. The rest methods, such as \'getDefaultJoin()\' and \'getJoins()\' are uncomplicated extensions of \'getJoin()\', so we won\'t analyze them here. In addition, the \'getJoin()\' method uses a multilevel cache:\\n\\n- \'cachedInstances\' : Search for the corresponding implementation class instance by alias\\n- \'joinInstances\' : If the alias lookup fails, load all the implementation class information, locate the implementation class type by the alias, and update the\' cachedInstances\' cache by either finding the implementation class type or creating and caching the implementation class instance\\n\\nThis completes the source code analysis of \'ExtensionLoader\'. Here\'s another example of an \'ExtensionLoader\' instance member property memory layout diagram to help you understand:\\n\\n![spi-attr-memory-debug](/img/activities/code-analysis-spi/spi-attr-memory-debug.png)\\n\\n### ExtensionFactory\\n\\n\'ExtensionFactory\' is the factory interface inside the factory pattern, which defines a method to get an instance of the \'SPI\' implementation (the **default implementation, or the only implementation**) :\\n\\n```java\\n@SPI(\\"spi\\")\\npublic interface ExtensionFactory {\\n\\n    /**\\n     * Gets Extension.\\n     *\\n     * @param <T>   the type parameter\\n     * @param key   \u6b64\u53c2\u6570\u6682\u65f6\u6ca1\u6709\u4f7f\u7528\uff0c\u731c\u6d4b\u662f\u9884\u7559\u7528\u4e8e\u6620\u5c04@SPI\u7684value()\\n     * @param clazz @SPI\u6807\u8bc6\u7684\u63a5\u53e3\u7c7b\u578b\\n     * @return the extension\\n     */\\n    <T> T getExtension(String key, Class<T> clazz);\\n}\\n```\\n\\nLet\'s look the class \'SpiExtensionFactory\' :\\n\\n```java\\n@Join\\npublic class SpiExtensionFactory implements ExtensionFactory {\\n\\n    @Override\\n    public <T> T getExtension(final String key, final Class<T> clazz) {\\n        return Optional.ofNullable(clazz)   // \u5165\u53c2clazz\u975e\u7a7a\\n                .filter(Class::isInterface)  // \u5165\u53c2clazz\u5fc5\u987b\u662f\u63a5\u53e3\\n                .filter(cls -> cls.isAnnotationPresent(SPI.class))  // \u5165\u53c2clazz\u5fc5\u987b\u88ab@SPI\u6807\u8bc6\\n                .map(ExtensionLoader::getExtensionLoader)  // \u57fa\u4e8eclazz\u8fd9\u4e2a\u63a5\u53e3\u7c7b\u578b\u5b9e\u4f8b\u5316ExtensionLoader\\n                .map(ExtensionLoader::getDefaultJoin)  // \u83b7\u53d6\u8be5@SPI\u6807\u8bc6\u63a5\u53e3\u7684\u9ed8\u8ba4\u5b9e\u73b0\uff0c\u4e0d\u5b58\u5728\u5219\u8fd4\u56deNULL\\n                .orElse(null);\\n    }\\n}\\n```\\n\\nIt\'s worth noting here that the \'ExtensionFactory\' itself is part of the \'SPI\' system. So when using \'ExtensionFactory\' you can instantiate it directly:\\n\\n```java\\nExtensionFactory extensionFactory = new SpiExtensionFactory();\\n```\\n\\nIt can also be loaded based on an \'ExtensionLoader\':\\n\\n```java\\n# the content of META-INF/services/shenyu/org.apache.shenyu.spi.ExtensionFactory\\nspi=org.apache.shenyu.spi.SpiExtensionFactory\\n\\n# then load it with ExtensionLoader\\nExtensionFactory extensionFactory = ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getDefaultJoin();\\n```\\n\\nOnce you have an \'ExtensionFactory\' instance, you can load an instance of its default implementation class based on the \'@SPI\' interface.\\n\\n## \u5c0f\u7ed3\\n\\nThe \'SPI\' extension framework based on the design idea of \'Java\' native \'SPI\' has the characteristics of loose coupling, high usability and high scalability, a loading instance cache system, concurrency security and other features to fill some defects of \'SPI\' in the native \'JDK\', Shenyu SPI module is the same. Base on this powerful \'SPI\' module, other modules in \'Shenyu\' such as the \'Plugin\' module can be configured quickly and pluggable, making it easier to load a newly developed Plugin instance."}]}')}}]);