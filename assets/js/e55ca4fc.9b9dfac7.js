"use strict";(self.webpackChunkshenyu_website=self.webpackChunkshenyu_website||[]).push([[88535],{9782:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/ratelimiter-package-diagram-b041571cdf2f8592c23ab33bf07fbc71.png"},14385:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/ratelimiteral-class-diagram-24df4785848602bdc5b321cf609d5cda.png"},15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>u});var i=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach(function(t){a(e,t,n[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))})}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},m="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef(function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),m=p(n),c=a,u=m["".concat(s,".").concat(c)]||m[c]||g[c]||r;return n?i.createElement(u,l(l({ref:t},d),{},{components:n})):i.createElement(u,l({ref:t},d))});function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[m]="string"==typeof e?e:a,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},28763:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var i=n(58168),a=(n(96540),n(15680));const r={title:"RateLimiter SPI code analysis",author:"Huihui Yin",author_title:"Apache ShenYu Contributor",author_url:"https://github.com/changanjennifer/",tags:["rate limiter","SPI","Apache ShenYu"]},l=void 0,o={permalink:"/blog/SPI-SourceCode-Analysis-RateLimiter-SPI",editUrl:"https://github.com/apache/shenyu-website/edit/main/blog/SPI-SourceCode-Analysis-RateLimiter-SPI.md",source:"@site/blog/SPI-SourceCode-Analysis-RateLimiter-SPI.md",title:"RateLimiter SPI code analysis",description:"Rate limiter is a very important integral of  gateway application, to deal with  high traffic.  When the system is attacked abnormally by a large number of traffic gathered in a short time;  When there are a large number of lower priority request need to be slow down or else it  will effect your high  priority transactions;  Or sometimes your system can not afford the regular traffic; in these  scenarios, we need to start rate limiter component to protect our system,  through rejection, wait, load  shedding,etc,  limit the requests to an acceptable quantities, or only  certain domains (or services) requests can get through.",date:"2025-07-20T12:52:30.086Z",formattedDate:"July 20, 2025",tags:[{label:"rate limiter",permalink:"/blog/tags/rate-limiter"},{label:"SPI",permalink:"/blog/tags/spi"},{label:"Apache ShenYu",permalink:"/blog/tags/apache-shen-yu"}],readingTime:15.275,truncated:!1,prevItem:{title:"PredicateJudge -- analyze the design based on SPI",permalink:"/blog/SPI-SourceCode-Analysis-PredicateJudge-SPI"},nextItem:{title:"Guide for New Contributors to Start avoid Pitfalls",permalink:"/blog/Start-SourceCode-Analysis-Start-Demo-for-Contributor"}},s=[{value:"Overall design of RateLimiter",id:"overall-design-of-ratelimiter",children:[]},{value:"Design of RateLimiter SPI",id:"design-of-ratelimiter-spi",children:[{value:"RateLimiterKeyResolver",id:"ratelimiterkeyresolver",children:[]},{value:"RateLimiterAlgorithm SPI",id:"ratelimiteralgorithm-spi",children:[]},{value:"Data access with Redis",id:"data-access-with-redis",children:[]}]},{value:"Four rate limiter algorithms",id:"four-rate-limiter-algorithms",children:[{value:"callback() used in Concurrent requests limiter",id:"callback-used-in-concurrent-requests-limiter",children:[]},{value:"getKeys() used  in token bucket rate limiter",id:"getkeys-used--in-token-bucket-rate-limiter",children:[]},{value:"getKeys() used  in sliding window rate limiter",id:"getkeys-used--in-sliding-window-rate-limiter",children:[]}]},{value:"How to use RateLimiter SPI",id:"how-to-use-ratelimiter-spi",children:[]},{value:"Summary",id:"summary",children:[]}],p={toc:s},d="wrapper";function m({components:e,...t}){return(0,a.yg)(d,(0,i.A)({},p,t,{components:e,mdxType:"MDXLayout"}),(0,a.yg)("p",null,(0,a.yg)("em",{parentName:"p"},"Rate limiter")," is a very important integral of  gateway application, to deal with  high traffic.  When the system is attacked abnormally by a large number of traffic gathered in a short time;  When there are a large number of lower priority request need to be slow down or else it  will effect your high  priority transactions;  Or sometimes your system can not afford the regular traffic; in these  scenarios, we need to start ",(0,a.yg)("em",{parentName:"p"},"rate limiter")," component to protect our system,  through rejection, wait, load  shedding,etc,  limit the requests to an acceptable quantities, or only  certain domains (or services) requests can get through.  "),(0,a.yg)("p",null,"Facing above scenarios, following need to be considered when designing the rate limiter component of an gateway."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Supports a variety  of rate limiter algorithms and easy to extends."),(0,a.yg)("li",{parentName:"ol"},"Resilient resolvers  which can distinguish traffic by different way, such as  ip, url, even user group  etc."),(0,a.yg)("li",{parentName:"ol"},"High availability, can quickly get allow or reject result from rate limiter"),(0,a.yg)("li",{parentName:"ol"},"With fault tolerance against when rate limiter is down, the gateway can continue work.")),(0,a.yg)("p",null,"This article will first introduce the overall architecture of the rate limiter module in Apache Shenyu, and then focus on the code analysis of rate limiter SPI."),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"This article based on ",(0,a.yg)("inlineCode",{parentName:"p"},"shenyu-2.4.0")," version of the source code analysis.")),(0,a.yg)("h2",{id:"overall-design-of-ratelimiter"},"Overall design of RateLimiter"),(0,a.yg)("p",null,"Spring ",(0,a.yg)("a",{parentName:"p",href:"https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html"},"WebFlux")," is reactive and  non-blocking web framework,  which can benefit throughput and  make applications more resilient. The plugin of ",(0,a.yg)("inlineCode",{parentName:"p"},"Apache Shenyu")," is based on ",(0,a.yg)("inlineCode",{parentName:"p"},"WebFlux"),"\uff0cits rate limiter component is implemented in ",(0,a.yg)("inlineCode",{parentName:"p"},"ratelimiter-plugin"),". In rate limiter process, the commonly used algorithms are token bucket, leaky bucket, etc.  To speed up concurrency performance,  the counting and calculation logic is treated in Redis, and Java code is responsible for  the transmission of parameters.  When applying Redis, the Lua script can be resident memory,  and be executed as  a whole, so it is atomic. Let alone the reducing of network overhead.  Redis commands abstraction and automatic serialization/deserialization with Redis store is provided in  ",(0,a.yg)("a",{parentName:"p",href:"https://spring.io/projects/spring-data-redis"},"Spring Data Redis"),".   Because of based on reactive framework, the  Spring Redis Reactive is used in ",(0,a.yg)("inlineCode",{parentName:"p"},"ratelimiter-plugin"),"."),(0,a.yg)("p",null," The class diagram of this plugin is as follows, highlighting two packages related to ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter SPI"),": resolver \u548calgorithm."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"ratelimiter-package-diagram",src:n(9782).A})),(0,a.yg)("h2",{id:"design-of-ratelimiter-spi"},"Design of RateLimiter SPI"),(0,a.yg)("p",null,"High performance issue is  achieved through the architecture of Spring data+ Redis+Lua ,  two ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI")," are supplied in  ",(0,a.yg)("inlineCode",{parentName:"p"},"ratelimiter-plugin"),"  for the extension of algorithm and key resolver\u3002"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},"RateLimiterAlgorithm\uff1aused for algorithms expansion."),(0,a.yg)("li",{parentName:"ul"},"RateLimiterKeyResolver\uff1a used for resolver expansion, to distinguish requests by various information, including ip, url, ect.  ")),(0,a.yg)("p",null,"The profile of SPI is located at  directory of ",(0,a.yg)("inlineCode",{parentName:"p"},"SHENYU_DIRECTORY"),"  (default",(0,a.yg)("inlineCode",{parentName:"p"},"/META-INF/shenyu"),")."),(0,a.yg)("h3",{id:"ratelimiterkeyresolver"},"RateLimiterKeyResolver"),(0,a.yg)("p",null,"Obtain the critical info of the request used for packet rate limiter\uff0cthe interface of ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterKeyResolver"),"  is follows\uff1a"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@SPI\npublic interface RateLimiterKeyResolver {\n\n    /**\n     * get Key resolver's name.\n     *\n     * @return Key resolver's name\n     */\n    String getKeyResolverName();\n\n    /**\n     * resolve.\n     *\n     * @param exchange exchange the current server exchange {@linkplain ServerWebExchange}\n     * @return rate limiter key\n     */\n    String resolve(ServerWebExchange exchange);\n}\n\n")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"@SPI"),"  registers the current interface as  Apache Shenyu SPI. Method ",(0,a.yg)("inlineCode",{parentName:"p"},"resolve(ServerWebExchange exchange)")," is used to provide  the resolution way.  Currently there are two key resolvers in  ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterKeyResolver"),"  ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI"),":",(0,a.yg)("inlineCode",{parentName:"p"},"WholeKeyResolve")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"RemoteAddrKeyResolver"),".  The  resolve method of ",(0,a.yg)("inlineCode",{parentName:"p"},"RemoteAddrKeyResolver"),"is as follows\uff1a"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"    @Override\n    public String resolve(final ServerWebExchange exchange) {\n        return Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();\n    }\n")),(0,a.yg)("p",null,"Where the resolved key is ip of request.  Based on ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI")," mechanism and its factory pattern,  new resolver can be easily developed."),(0,a.yg)("h3",{id:"ratelimiteralgorithm-spi"},"RateLimiterAlgorithm SPI"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterAlgorithm")," ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI")," is used to identify and define different rate limiter algorithms, following is the class diagram of this module."),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"ratelimiteral-class-diagram",src:n(14385).A})),(0,a.yg)("p",null,"In this module, factory pattern is used , providing interface, abstract class and factory class, and four implementation classes. The ",(0,a.yg)("inlineCode",{parentName:"p"},"lua")," script corresponding to the implementation class is enumerated in ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimitEnum")," and located in  ",(0,a.yg)("inlineCode",{parentName:"p"},"/META-INF/scripts"),"."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"@SPI\npublic interface RateLimiterAlgorithm<T> {\n    \n    RedisScript<T> getScript();\n    List<String> getKeys(String id);\n    \n    /**\n     * Callback string.\n     *\n     * @param script the script\n     * @param keys the keys\n     * @param scriptArgs the script args\n     */\n    default void callback(final RedisScript<?> script, final List<String> keys, final List<String> scriptArgs) {\n    }\n}\n")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"@SPI"),"  registers the current interface as  Apache Shenyu SPI. There are three methods:"),(0,a.yg)("ul",null,(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"getScript()")," returns a ",(0,a.yg)("inlineCode",{parentName:"li"},"RedisScript")," object, which will be passed to Redis."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"getKeys(String id)"),"  returns a List contains with  keys."),(0,a.yg)("li",{parentName:"ul"},(0,a.yg)("inlineCode",{parentName:"li"},"callback()")," the callback function which will be executed asynchronously later on, and default is an empty method.")),(0,a.yg)("h4",{id:"abstractratelimiteralgorithm"},"AbstractRateLimiterAlgorithm"),(0,a.yg)("p",null,"The template method is implemented in this abstract class, and the reified generics used is ",(0,a.yg)("inlineCode",{parentName:"p"},"List<Long>"),". Two abstract methods getScriptName()  and getKeyName()  are left for  the implementation class. Following is the code to load ",(0,a.yg)("inlineCode",{parentName:"p"},"lua")," script."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    public RedisScript<List<Long>> getScript() {\n        if (!this.initialized.get()) {\n            DefaultRedisScript redisScript = new DefaultRedisScript<>();\n            String scriptPath = "/META-INF/scripts/" + getScriptName();\n            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(scriptPath)));\n            redisScript.setResultType(List.class);\n            this.script = redisScript;\n            initialized.compareAndSet(false, true);\n            return redisScript;\n        }\n        return script;\n    }\n')),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"initialized"),"  is an ",(0,a.yg)("inlineCode",{parentName:"p"},"AtomicBoolean"),"  type variable used to indicate whether the ",(0,a.yg)("inlineCode",{parentName:"p"},"lua")," script is loaded.  If has not been loaded, the system will read specified scripts form ",(0,a.yg)("inlineCode",{parentName:"p"},"META-INF/scripts"),";  After reading,  specify the result with ",(0,a.yg)("inlineCode",{parentName:"p"},"List")," type, and set  ",(0,a.yg)("inlineCode",{parentName:"p"},"initialized=true"),", then returning  ",(0,a.yg)("inlineCode",{parentName:"p"},"RedisScript"),"object."),(0,a.yg)("p",null,"The code of ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()"),"  in ",(0,a.yg)("inlineCode",{parentName:"p"},"AbstractRateLimiterAlgorithm")," is  as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    @Override\n    public List<String> getKeys(final String id) {\n        String prefix = getKeyName() + ".{" + id;\n        String tokenKey = prefix + "}.tokens";\n        String timestampKey = prefix + "}.timestamp";\n        return Arrays.asList(tokenKey, timestampKey);\n    }\n')),(0,a.yg)("p",null,"Two strings are generated in this template method, where the ",(0,a.yg)("inlineCode",{parentName:"p"},"tokenKey")," will work as Key to a Sorted map in Redis.  "),(0,a.yg)("p",null,"We can observe from above class diagram that  ",(0,a.yg)("inlineCode",{parentName:"p"},"ConcurrentRateLimiterAlgorithm")," and ",(0,a.yg)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiterAlgorithm"),"  override ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys(String id)")," method  but another two implementation classes not, and use template method in ",(0,a.yg)("inlineCode",{parentName:"p"},"AbstractRateLimiterAlgorithm"),". Only  in  ",(0,a.yg)("inlineCode",{parentName:"p"},"ConcurrentRateLimiterAlgorithm")," has override callback() method, the others not.  We will do further analysis in the following."),(0,a.yg)("h4",{id:"ratelimiteralgorithmfactory"},"RateLimiterAlgorithmFactory"),(0,a.yg)("p",null,"The  method gets",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterAlgorithm")," instance  by ",(0,a.yg)("inlineCode",{parentName:"p"},"name"),"  in  ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterAlgorithmFactory")," is as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"public static RateLimiterAlgorithm<?> newInstance(final String name) {\n    return Optional.ofNullable(ExtensionLoader.getExtensionLoader(RateLimiterAlgorithm.class).getJoin(name)).orElse(new TokenBucketRateLimiterAlgorithm());\n}\n")),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"ExtensionLoader")," of ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI"),' is responsible for loading SPI classes by "name", if cannot find the specified algorithm class, it will return ',(0,a.yg)("inlineCode",{parentName:"p"},"TokenBucketRateLimiterAlgorithm")," by default."),(0,a.yg)("h3",{id:"data-access-with-redis"},"Data access with Redis"),(0,a.yg)("p",null,"Above detailed the  extension interface in ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter")," ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI"),". In Apache Shenyu, we use ",(0,a.yg)("inlineCode",{parentName:"p"},"ReactiveRedisTemplate"),"  to perform   Redis processing reactively, which is implemented  in",(0,a.yg)("inlineCode",{parentName:"p"},"isAllowed()")," method of ",(0,a.yg)("inlineCode",{parentName:"p"},"RedisRateLimiter")," class."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    public Mono<RateLimiterResponse> isAllowed(final String id, final RateLimiterHandle limiterHandle) {\n        // get parameters that will pass to redis from RateLimiterHandle Object\n        double replenishRate = limiterHandle.getReplenishRate();\n        double burstCapacity = limiterHandle.getBurstCapacity();\n        double requestCount = limiterHandle.getRequestCount();\n        // get the current used RateLimiterAlgorithm\n        RateLimiterAlgorithm<?> rateLimiterAlgorithm = RateLimiterAlgorithmFactory.newInstance(limiterHandle.getAlgorithmName());\n        \n        ........\n        Flux<List<Long>> resultFlux = Singleton.INST.get(ReactiveRedisTemplate.class).execute(script, keys, scriptArgs);\n        return resultFlux.onErrorResume(throwable -> Flux.just(Arrays.asList(1L, -1L)))\n                .reduce(new ArrayList<Long>(), (longs, l) -> {\n                    longs.addAll(l);\n                    return longs;\n                }).map(results -> {\n                    boolean allowed = results.get(0) == 1L;\n                    Long tokensLeft = results.get(1);\n                    return new RateLimiterResponse(allowed, tokensLeft);\n                })\n                .doOnError(throwable -> log.error("Error occurred while judging if user is allowed by RedisRateLimiter:{}", throwable.getMessage()))\n                .doFinally(signalType -> rateLimiterAlgorithm.callback(script, keys, scriptArgs));\n    }\n')),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"POJO")," class ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterHandle")," wraps the parameters needed in rate limiter, they are ",(0,a.yg)("inlineCode",{parentName:"p"},"algorithName"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"replenishRate"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"burstCapacity"),", ",(0,a.yg)("inlineCode",{parentName:"p"},"requestCount"),", etc.  First, gets the parameters  that need to be passed into Redis from ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterHandle")," class. Then obtain the current implementation class from ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterAlgorithmFactory"),"."),(0,a.yg)("p",null,"For convenience,  we give an flow image to show the parameters I/O  and execution procedure in Java and Redis respectively.  On the left is the second half of ",(0,a.yg)("inlineCode",{parentName:"p"},"isAllowed"),"() ,  and on the right is the processing of ",(0,a.yg)("inlineCode",{parentName:"p"},"Lua")," script."),(0,a.yg)("p",null,"Following is the execution process of the JAVA code."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Get two keys value in ",(0,a.yg)("inlineCode",{parentName:"p"},"List<String>")," type from the ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()")," method, the first element  will map to a sorted set in Redis.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Set four parameters,  ",(0,a.yg)("inlineCode",{parentName:"p"},"replenishRate")," ,  ",(0,a.yg)("inlineCode",{parentName:"p"},"burstCapacity"),",  ",(0,a.yg)("inlineCode",{parentName:"p"},"timestamp")," (",(0,a.yg)("inlineCode",{parentName:"p"},"EpochSecond"),") and ",(0,a.yg)("inlineCode",{parentName:"p"},"requestcount"),".")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Calling ",(0,a.yg)("inlineCode",{parentName:"p"},"ReactiveRedisTemplate")," with the scripts, keys and parameters,  the return a  ",(0,a.yg)("inlineCode",{parentName:"p"},"Flux<List<Long>>"))),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"The  return value is converted from ",(0,a.yg)("inlineCode",{parentName:"p"},"Flux<ArrayList<Long>>")," to ",(0,a.yg)("inlineCode",{parentName:"p"},"Mono<ArrayList<Long>>")," the through ",(0,a.yg)("inlineCode",{parentName:"p"},"reduce()")," of ",(0,a.yg)("inlineCode",{parentName:"p"},"Flux")," \uff0cand then transform it to ",(0,a.yg)("inlineCode",{parentName:"p"},"Mono<RateLimiterResponse>")," via ",(0,a.yg)("inlineCode",{parentName:"p"},"map()")," function.  Returned two data, one is ",(0,a.yg)("inlineCode",{parentName:"p"},"allowed")," (1-allow, 0- not allowed),  the other is ",(0,a.yg)("inlineCode",{parentName:"p"},"tokensLeft"),", the number of available remaining request.  ")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"As for the fault tolerance,  due to using of reactor non-blocking model, when an error occurs, the fallback  function ",(0,a.yg)("inlineCode",{parentName:"p"},"onErrorResume()")," will be executed and a new stream ",(0,a.yg)("inlineCode",{parentName:"p"},"(1L, -1L)")," will  generated by ",(0,a.yg)("inlineCode",{parentName:"p"},"Flux.just,")," which means  allow the request getting through, and log the error on the side.  ")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"After that, performs the  ",(0,a.yg)("inlineCode",{parentName:"p"},"doFinally()"),"  method, that is to execute the callback() method of the implementation class."))),(0,a.yg)("p",null,(0,a.yg)("img",{alt:"io-with-lua",src:n(62723).A})),(0,a.yg)("h2",{id:"four-rate-limiter-algorithms"},"Four rate limiter algorithms"),(0,a.yg)("p",null,"From above we  know that  how the  java code works with Redis in the gateway. In this chapter we briefly analysis some code of the  four rate limiter algorithms, to understand how to develop the interface of  ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter SPI"),"  and work efficiently with Redis.  "),(0,a.yg)("p",null,"Four rate limiter algorithms are supplied in Apache Shenyu ",(0,a.yg)("inlineCode",{parentName:"p"},"Ratelimit SPI"),":"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Algorithm name"),(0,a.yg)("th",{parentName:"tr",align:null},"Java class"),(0,a.yg)("th",{parentName:"tr",align:null},"Lua script file"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Request rate limiter"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"TokenBucketRateLimiterAlgorithm")),(0,a.yg)("td",{parentName:"tr",align:null},"request_rate_limiter.lua")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Slide window rate limiter"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"SlidingWindowRateLimiterAlgorithm")),(0,a.yg)("td",{parentName:"tr",align:null},"liding_window_request_rate_limiter.lua")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Concurrent rate limiter"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"ConcurrentRateLimiterAlgorithm")),(0,a.yg)("td",{parentName:"tr",align:null},"concurrent_request_rate_limiter.lua")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Leaky bucket algorithm"),(0,a.yg)("td",{parentName:"tr",align:null},(0,a.yg)("inlineCode",{parentName:"td"},"LeakyBucketRateLimiterAlgorithm")),(0,a.yg)("td",{parentName:"tr",align:null},"request_leaky_rate_limiter.lua")))),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},"Token bucket rate limiter\uff1a Limiting the traffic according to the number of requests. Assuming that ",(0,a.yg)("em",{parentName:"li"},"N")," requests can be passed per second, when requests exceeding ",(0,a.yg)("em",{parentName:"li"},"N")," will be rejected.  In implementing of the algorithm, the requests will be grouped by bucket,  the tokens will be generated at an evenly rate.  If  the number of requests is less than the tokens in the bucket, then it is allowed to pass.  The time window is 2* capacity/rate."),(0,a.yg)("li",{parentName:"ol"},"Slide window rate limiter:   Different from token bucket algorithm, its window size is smaller than that of token bucket rate limiter,  which is a capacity/rate.  And move backward one time window at a time. Other rate limiter principles are similar to token bucket."),(0,a.yg)("li",{parentName:"ol"},"Concurrent rate limiter\uff1a Strictly limit the concurrent requests to ",(0,a.yg)("em",{parentName:"li"},"N"),". Each time when there is a new request, it will check whether the number of concurrent requests is greater than N. If it is less than ",(0,a.yg)("inlineCode",{parentName:"li"},"N"),", it is allowed to pass through, and the count is increased by 1. When the requests call ends, the signal is released (count minus 1)."),(0,a.yg)("li",{parentName:"ol"},"Leaky bucket rate limiter:   In contrast with token bucket algorithm, the leaky bucket algorithm can help to smooths the burst of requests and only allows a pre-defined ",(0,a.yg)("em",{parentName:"li"},"N")," number of requests. This limiter can force the output flow at a constant rate of ",(0,a.yg)("em",{parentName:"li"},"N"),".  It is based on a leaky bucket model, the leaky water quantity is  time interval*rate.  if the leaky water quantity is greater than the number of has used (represented by ",(0,a.yg)("inlineCode",{parentName:"li"},"key_bucket_count"),"), then clear the bucket, that is, set the ",(0,a.yg)("inlineCode",{parentName:"li"},"key_bucket_count")," to 0. Otherwise, set ",(0,a.yg)("inlineCode",{parentName:"li"},"key_bucket_count"),"  minus the leaky water quantity.  If the number  (requests + ",(0,a.yg)("inlineCode",{parentName:"li"},"key_bucket_count")," ) is less than the capacity, then allow the requests passing through.")),(0,a.yg)("p",null,"Let's understand the functionality of  ",(0,a.yg)("inlineCode",{parentName:"p"},"callback()")," by reading concurrent rate limiter code, and understand the usage of ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()")," through reading the  Lua script of token rate limiter and slide window rate limiter."),(0,a.yg)("h3",{id:"callback-used-in-concurrent-requests-limiter"},"callback() used in Concurrent requests limiter"),(0,a.yg)("p",null,"The ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()"),"  method of ",(0,a.yg)("inlineCode",{parentName:"p"},"ConcurrentRateLimiterAlgorithm")," overrides the template method in ",(0,a.yg)("inlineCode",{parentName:"p"},"AbstractRateLimiterAlgorithm")," \uff1a"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    @Override\n    public List<String> getKeys(final String id) {\n        String tokenKey = getKeyName() + ".{" + id + "}.tokens";\n        String requestKey = UUIDUtils.getInstance().generateShortUuid();\n        return Arrays.asList(tokenKey, requestKey);\n    }\n')),(0,a.yg)("p",null,"The second element, ",(0,a.yg)("inlineCode",{parentName:"p"},"requestKey"),"  is a long type and non-duplicate  value (generated by a distributed ID generator\uff0cit is incremented and smaller than the current time Epochsecond value). The corresponding ",(0,a.yg)("inlineCode",{parentName:"p"},"Lua")," script in ",(0,a.yg)("inlineCode",{parentName:"p"},"concurrent_request_rate_limiter.lua"),":"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local key = KEYS[1]\n\nlocal capacity = tonumber(ARGV[2])\nlocal timestamp = tonumber(ARGV[3])\nlocal id = KEYS[2]\n")),(0,a.yg)("p",null,"Here ",(0,a.yg)("inlineCode",{parentName:"p"},"id"),"  is ",(0,a.yg)("inlineCode",{parentName:"p"},"requestKey"),"  generated by ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()")," method, it is an ",(0,a.yg)("inlineCode",{parentName:"p"},"uuid"),"(unique value).  Subsequent process is as follows:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},'local count = redis.call("zcard", key)\nlocal allowed = 0\n\nif count < capacity then\n  redis.call("zadd", key, timestamp, id)\n  allowed = 1\n  count = count + 1\nend\nreturn { allowed, count }\n')),(0,a.yg)("p",null,"First, using ",(0,a.yg)("inlineCode",{parentName:"p"},"zcard")," command to obtain the cardinality  of the sorted set, and set count equals the  cardinality , if the cardinality is less than the capacity, we will add a new member ",(0,a.yg)("inlineCode",{parentName:"p"},"id")," (it is an ",(0,a.yg)("inlineCode",{parentName:"p"},"uuid"),") to the sorted set, with the score of current time(in seconds) . then ",(0,a.yg)("inlineCode",{parentName:"p"},"count =count+1"),", the cardinality is also incremented by 1 in reality."),(0,a.yg)("p",null,"All of the code above is executed in Redis as an atomic transaction.  If there are a large number of concurrent requests from the same key( such as ip) , the cardinality of the sorted set of this key will increasing sharply, when then capacity limit is exceeded, the  service will be denied, that is ",(0,a.yg)("inlineCode",{parentName:"p"},"allowed =0"),"\u3002"),(0,a.yg)("p",null,"In concurrent requests limiter, It is required to release the semaphore when the request is completed. However, it is not included in Lua script."),(0,a.yg)("p",null,"Let's see the callback function of  ",(0,a.yg)("inlineCode",{parentName:"p"},"ConcurrentRateLimiterAlgorithm"),"\uff1a"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'    @Override\n    @SuppressWarnings("unchecked")\n    public void callback(final RedisScript<?> script, final List<String> keys, final List<String> scriptArgs) {\n        Singleton.INST.get(ReactiveRedisTemplate.class).opsForZSet().remove(keys.get(0), keys.get(1)).subscribe();\n    }\n')),(0,a.yg)("p",null,"Here gives asynchronous subscription, using ",(0,a.yg)("inlineCode",{parentName:"p"},"ReactiveRedisTemplate")," to delete the elements  (",(0,a.yg)("inlineCode",{parentName:"p"},"key"),",",(0,a.yg)("inlineCode",{parentName:"p"},"id"),")  in Redis store. That is once the request operation ends, the semaphore will be released.  This remove operation  cannot be executed in Lua script. This is just what design intention of ",(0,a.yg)("inlineCode",{parentName:"p"},"callback")," in ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterAlgorithm")," ",(0,a.yg)("inlineCode",{parentName:"p"},"SPI")," ."),(0,a.yg)("h3",{id:"getkeys-used--in-token-bucket-rate-limiter"},"getKeys() used  in token bucket rate limiter"),(0,a.yg)("p",null,"Following is the corresponding Lua code:"),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},"local tokens_key = KEYS[1]\nlocal timestamp_key = KEYS[2]\n")),(0,a.yg)("p",null,"Here we omit the code that get the parameters of rate ,capacity, etc."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local fill_time = capacity/rate\nlocal ttl = math.floor(fill_time*2)\n")),(0,a.yg)("p",null,"The window size variable(ttl) is approximately  two times of  capacity/rate."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},'local last_tokens = tonumber(redis.call("get", tokens_key))\nif last_tokens == nil then\n  last_tokens = capacity\nend\n')),(0,a.yg)("p",null,"Get last_tokens from the sorted set, if it not exist, then last_tokens equals capacity."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},'local last_refreshed = tonumber(redis.call("get", timestamp_key))\nif last_refreshed == nil then\n  last_refreshed = 0\nend\n')),(0,a.yg)("p",null,"Get the last refreshed time by the key =timestamp_key from the sorted set, and default 0."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local delta = math.max(0, now-last_refreshed)\nlocal filled_tokens = math.min(capacity, last_tokens+(delta*rate))\nlocal allowed = filled_tokens >= requested\nlocal allowed_num = 0\nif allowed then\n  new_tokens = filled_tokens - requested\n  allowed_num = 1\nend\n\n")),(0,a.yg)("p",null,"The filled_tokens is produced evenly by time interval * rate\uff0cif the number of tokens greater than requests, then allowed=1,  and update  new_tokens."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},'redis.call("setex", tokens_key, ttl, new_tokens)\nredis.call("setex", timestamp_key, ttl, now)\n\nreturn { allowed_num, new_tokens }\n')),(0,a.yg)("p",null,"Here ",(0,a.yg)("inlineCode",{parentName:"p"},"now")," is  current time parameters passed in,  set ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens_key")," to hold the string ",(0,a.yg)("inlineCode",{parentName:"p"},"new_tokens")," and set",(0,a.yg)("inlineCode",{parentName:"p"},"tokens_key")," to timeout after ",(0,a.yg)("inlineCode",{parentName:"p"},"ttl")," of seconds.  Set  ",(0,a.yg)("inlineCode",{parentName:"p"},"timestamp_key")," to hold the string value ",(0,a.yg)("inlineCode",{parentName:"p"},"now"),", and expires after ",(0,a.yg)("inlineCode",{parentName:"p"},"ttl")," seconds."),(0,a.yg)("h3",{id:"getkeys-used--in-sliding-window-rate-limiter"},"getKeys() used  in sliding window rate limiter"),(0,a.yg)("p",null,"The  ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys()")," in ",(0,a.yg)("inlineCode",{parentName:"p"},"SlidingWindowRateLimiterAlgorithm")," also overrides the parent class, and the code is consistent with the method in ",(0,a.yg)("inlineCode",{parentName:"p"},"ConcurrentRateLimiterAlgorithm")),(0,a.yg)("p",null,"Following is the Lua code of slide window rate limiter, the  receiving of other parameters is omitted."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local timestamp_key = KEYS[2]\n...... \nlocal window_size = tonumber(capacity / rate)\nlocal window_time = 1\n")),(0,a.yg)("p",null,"Here set the window_size to capacity/rate."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local last_requested = 0\nlocal exists_key = redis.call('exists', tokens_key)\nif (exists_key == 1) then\n    last_requested = redis.call('zcard', tokens_key)\nend\n")),(0,a.yg)("p",null,"Obtain the cardinality(",(0,a.yg)("inlineCode",{parentName:"p"},"last_requested"),") of the ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens_key")," in the sorted set."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"local remain_request = capacity - last_requested\nlocal allowed_num = 0\nif (last_requested < capacity) then\n    allowed_num = 1\n    redis.call('zadd', tokens_key, now, timestamp_key)\nend\n")),(0,a.yg)("p",null,"Calculate remaining available ",(0,a.yg)("inlineCode",{parentName:"p"},"remain_request")," equals  capacity minus ",(0,a.yg)("inlineCode",{parentName:"p"},"last_requested")," .  If  ",(0,a.yg)("inlineCode",{parentName:"p"},"last_requested")," less than  capacity ,then allow current requests passing through\uff0cadd element in the sorted set with (key=",(0,a.yg)("inlineCode",{parentName:"p"},"timestamp_key"),", value=",(0,a.yg)("inlineCode",{parentName:"p"},"now"),") ."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-lua"},"redis.call('zremrangebyscore', tokens_key, 0, now - window_size / window_time)\nredis.call('expire', tokens_key, window_size)\n\nreturn { allowed_num, remain_request }\n")),(0,a.yg)("p",null,"Previously has set ",(0,a.yg)("inlineCode",{parentName:"p"},"window_time"),"=1, using ",(0,a.yg)("inlineCode",{parentName:"p"},"zremrangebyscore")," command of Redis to remove all the elements in the sorted set stored at  ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens_key")," with a score in ","[0,now - window_size / window_time]"," ,  that is,  move the window a window size. Set the expire time of ",(0,a.yg)("inlineCode",{parentName:"p"},"tokens_key"),"  to ",(0,a.yg)("inlineCode",{parentName:"p"},"window_size"),"."),(0,a.yg)("p",null,"In the template method ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys(final String id)"),"  of ",(0,a.yg)("inlineCode",{parentName:"p"},"AbstractRateLimiterAlgorithm"),"\uff0cthe second key ( represented y ",(0,a.yg)("inlineCode",{parentName:"p"},"secondKey"),")  is a  fixed string which concat  the input parameter{id}. As we can see from the above three algorithm codes, in the token bucket algorithm,  ",(0,a.yg)("inlineCode",{parentName:"p"},"secondKey")," will be updated to the latest time in the Lua code, so it doesn't matter what value is passed in.  In the concurrent rate limiter, ",(0,a.yg)("inlineCode",{parentName:"p"},"secondKey")," will be used as the key to remove Redis data in the java ",(0,a.yg)("inlineCode",{parentName:"p"},"callback")," method.  In the sliding window algorithm, the  ",(0,a.yg)("inlineCode",{parentName:"p"},"secondKey")," will be added to the sorted set  as the key of a new element, and will be removed during window sliding."),(0,a.yg)("p",null,"That's all, when in a new rate limiter algorithm, the ",(0,a.yg)("inlineCode",{parentName:"p"},"getKeys(final String id)"),"method should be carefully designed according to the logic of the algorithm."),(0,a.yg)("h2",{id:"how-to-use-ratelimiter-spi"},"How to use RateLimiter SPI"),(0,a.yg)("p",null,"The three parameters in ",(0,a.yg)("inlineCode",{parentName:"p"},"doExecute()")," method of  ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter")," plugin\uff0c ",(0,a.yg)("inlineCode",{parentName:"p"},"exchange"),"  is an web request\uff0c ",(0,a.yg)("inlineCode",{parentName:"p"},"chain"),"  is the execution chain of the plugins\uff0c",(0,a.yg)("inlineCode",{parentName:"p"},"selector")," is the selection parameters\uff0c",(0,a.yg)("inlineCode",{parentName:"p"},"rule"),"  is the  policies or rules of rate limiter setting in the system."),(0,a.yg)("pre",null,(0,a.yg)("code",{parentName:"pre",className:"language-java"},'protected Mono<Void> doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {\n    //get  the `RateLimiterHandle` parameters from cache \n    RateLimiterHandle limiterHandle = RatelimiterRuleHandleCache.getInstance()\n        .obtainHandle(CacheKeyUtils.INST.getKey(rule));\n    //find the resolver name \n    String resolverKey = Optional.ofNullable(limiterHandle.getKeyResolverName())\n        .flatMap(name -> Optional.of("-" + RateLimiterKeyResolverFactory.newInstance(name).resolve(exchange)))\n        .orElse("");\n    return redisRateLimiter.isAllowed(rule.getId() + resolverKey, limiterHandle)\n        .flatMap(response -> {\n            if (!response.isAllowed()) {\n                exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);\n                Object error = ShenyuResultWrap.error(ShenyuResultEnum.TOO_MANY_REQUESTS.getCode(), ShenyuResultEnum.TOO_MANY_REQUESTS.getMsg(), null);\n                return WebFluxResultUtils.result(exchange, error);\n            }\n            return chain.execute(exchange);\n        });\n}\n')),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Firstly get the ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterHandle"),"  parameters from cache.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Obtains the corresponding Key resolver by ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiterHandle")," instance.  ")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"Reactively executes ",(0,a.yg)("inlineCode",{parentName:"p"},"isAllowed()"),"  method of  ",(0,a.yg)("inlineCode",{parentName:"p"},"RedisRateLimiter"),".")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"If not allowed, error handling is performed.")),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("p",{parentName:"li"},"If the request is allowed, dispatch it to the next process of execution chain."))),(0,a.yg)("h2",{id:"summary"},"Summary"),(0,a.yg)("p",null,(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter")," plugin is based on ",(0,a.yg)("inlineCode",{parentName:"p"},"Spring WebFlux"),",and with ",(0,a.yg)("inlineCode",{parentName:"p"},"Apache Shen SPI"),", with Redis and Lua script to responsible for the critical algorithm and logic process, make it with characteristics of high concurrency and elastic.  As for the ",(0,a.yg)("inlineCode",{parentName:"p"},"RateLimiter SPI"),"."),(0,a.yg)("ol",null,(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"RateLimiter")," ",(0,a.yg)("inlineCode",{parentName:"li"},"SPI")," provides two ",(0,a.yg)("inlineCode",{parentName:"li"},"SPI")," interface, with interface oriented design and various design patterns, it's easy to develop new rate limiter algorithm and key resolver rule."),(0,a.yg)("li",{parentName:"ol"},(0,a.yg)("inlineCode",{parentName:"li"},"RateLimiterAlgorithm")," ",(0,a.yg)("inlineCode",{parentName:"li"},"SPI")," supplies four rate limiter algorithms, token bucket,concurrency rate limiter, leaky bucket and sliding window rate limiter. When designing rate limiter algorithm, the KEY generation need to be carefully designed according to the algorithm characteristic.  Using Lua script to realize the logic of the algorithm, and  design callback()  method for asynchronous processing when needed."),(0,a.yg)("li",{parentName:"ol"},"Reactive programming, simple and efficient implementation.")))}m.isMDXComponent=!0},62723:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/io-with-lua-eefcd28d4b59a8bd0e69e29400018c50.png"}}]);