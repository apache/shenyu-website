<!doctype html>
<html lang="zh" dir="ltr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.4">
<link rel="alternate" type="application/rss+xml" href="/zh/blog/rss.xml" title="Apache ShenYu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/blog/atom.xml" title="Apache ShenYu Blog Atom Feed">
<link rel="search" type="application/opensearchdescription+xml" title="Apache ShenYu" href="/zh/opensearch.xml">
<link rel="alternate" type="application/rss+xml" href="/zh/news/rss.xml" title="Apache ShenYu Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh/news/atom.xml" title="Apache ShenYu Blog Atom Feed"><title data-react-helmet="true">Blog | Apache ShenYu</title><meta data-react-helmet="true" property="og:title" content="Blog | Apache ShenYu"><meta data-react-helmet="true" name="description" content="Blog"><meta data-react-helmet="true" property="og:description" content="Blog"><meta data-react-helmet="true" property="og:url" content="https://shenyu.apache.org//zh/blog/page/2"><meta data-react-helmet="true" name="docsearch:language" content="zh"><meta data-react-helmet="true" name="docsearch:docusaurus_tag" content="blog_posts_list"><link data-react-helmet="true" rel="shortcut icon" href="/zh/img/favicon.svg"><link data-react-helmet="true" rel="canonical" href="https://shenyu.apache.org//zh/blog/page/2"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog/page/2" hreflang="en"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//zh/blog/page/2" hreflang="zh"><link data-react-helmet="true" rel="alternate" href="https://shenyu.apache.org//blog/page/2" hreflang="x-default"><link data-react-helmet="true" rel="preconnect" href="https://BH4D9OD16A-dsn.algolia.net" crossorigin="anonymous"><link rel="stylesheet" href="/zh/assets/css/styles.6bd5fa92.css">
<link rel="preload" href="/zh/assets/js/runtime~main.45f1436c.js" as="script">
<link rel="preload" href="/zh/assets/js/main.61e23882.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div><a href="#" class="skipToContent_OuoZ">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh/"><img src="/zh/img/logo.svg" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--light_4Vu1 navbar__logo"><img src="/zh/img/logo-light.svg" alt="Apache ShenYu Logo" class="themedImage_TMUO themedImage--dark_uzRr navbar__logo"></a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href="/zh/download">下载</a><a class="navbar__item navbar__link" href="/zh/document">文档</a><a class="navbar__item navbar__link" href="/zh/community/contributor-guide">社区</a><a class="navbar__item navbar__link" href="/zh/team">团队</a><a class="navbar__item navbar__link" href="/zh/event">事件</a><a class="navbar__item navbar__link" href="/zh/news">新闻</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh/blog">博客</a><a class="navbar__item navbar__link" href="/zh/users">用户</a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__item navbar__link">ASF</a><ul class="dropdown__menu"><li><a href="https://www.apache.org/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Foundation</a></li><li><a href="https://www.apache.org/licenses/" target="_blank" rel="noopener noreferrer" class="dropdown__link">License</a></li><li><a href="https://www.apache.org/events/current-event" target="_blank" rel="noopener noreferrer" class="dropdown__link">Events</a></li><li><a href="https://www.apache.org/security/" target="_blank" rel="noopener noreferrer" class="dropdown__link">Security</a></li><li><a href="https://www.apache.org/foundation/sponsorship.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Sponsorship</a></li><li><a href="https://www.apache.org/foundation/policies/privacy.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Privacy</a></li><li><a href="https://www.apache.org/foundation/thanks.html" target="_blank" rel="noopener noreferrer" class="dropdown__link">Thanks</a></li></ul></div><a href="https://github.com/apache/shenyu" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link"><span>GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_wgqa"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></span></a><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" class="navbar__item navbar__link"><span><svg t="1631348384596" class="icon" viewBox="0 0 1024 1024" version="1.1" style="vertical-align:text-bottom;margin-right:5px" p-id="557" width="20" height="20"><path d="M547.797333 638.208l-104.405333-103.168 1.237333-1.28a720.170667 720.170667 0 0 0 152.490667-268.373333h120.448V183.082667h-287.744V100.906667H347.605333v82.218666H59.818667V265.386667h459.178666a648.234667 648.234667 0 0 1-130.304 219.946666 643.242667 643.242667 0 0 1-94.976-137.728H211.541333a722.048 722.048 0 0 0 122.453334 187.434667l-209.194667 206.378667 58.368 58.368 205.525333-205.525334 127.872 127.829334 31.232-83.84m231.424-208.426667h-82.218666l-184.96 493.312h82.218666l46.037334-123.306667h195.242666l46.464 123.306667h82.218667l-185.002667-493.312m-107.690666 287.744l66.56-178.005333 66.602666 178.005333z" fill="currentColor" p-id="558"></path></svg><span>简体中文</span></span></a><ul class="dropdown__menu"><li><a href="/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link" style="text-transform:capitalize">English</a></li><li><a href="/zh/blog/page/2" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" style="text-transform:capitalize">简体中文</a></li></ul></div><div class="react-toggle toggle_2i4l react-toggle--disabled"><div class="react-toggle-track" role="button" tabindex="-1"><div class="react-toggle-track-check"><span class="toggle_iYfV">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_iYfV">🌞</span></div><div class="react-toggle-thumb"></div></div><input type="checkbox" class="react-toggle-screenreader-only" aria-label="Switch between dark and light mode"></div><div class="searchBox_Bc3W"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper blog-wrapper blog-list-page"><div class="container margin-vert--lg"><div class="row"><main class="col col--9 col--offset-1"><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-Http-Data-Sync">Http长轮询数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>Http长轮询</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.5.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-http长轮询"></a>1. Http长轮询<a class="hash-link" href="#1-http长轮询" title="Direct link to heading">#</a></h3><p>这里直接引用官网的相关描述：</p><blockquote><p><code>Zookeeper</code>和<code>WebSocket</code> 数据同步的机制比较简单，而 <code>Http长轮询</code>则比较复杂。 <code>Apache ShenYu</code> 借鉴了 <code>Apollo</code>、<code>Nacos</code> 的设计思想，取其精华，自己实现了 <code>Http长轮询</code>数据同步功能。注意，这里并非传统的 <code>ajax</code> 长轮询！</p></blockquote><p><img src="/zh/assets/images/http-long-polling-zh-bc8bd8fe6c4aa883a959f59fce05078a.png"></p><p><code>Http长轮询</code> 机制如上所示，<code>Apache ShenYu</code>网关主动请求 <code>shenyu-admin</code> 的配置服务，读取超时时间为 <code>90s</code>，意味着网关层请求配置服务最多会等待 <code>90s</code>，这样便于 <code>shenyu-admin</code> 配置服务及时响应变更数据，从而实现准实时推送。</p><p><code>Http长轮询</code> 机制是由网关主动请求 <code>shenyu-admin</code> ，所以这次的源码分析，我们从网关这一侧开始。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-网关数据同步"></a>2. 网关数据同步<a class="hash-link" href="#2-网关数据同步" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-加载配置"></a>2.1 加载配置<a class="hash-link" href="#21-加载配置" title="Direct link to heading">#</a></h4><p><code>Http长轮询</code> 数据同步配置的加载是通过<code>spring boot</code>的<code>starter</code>机制，当我们引入相关依赖和在配置文件中有如下配置时，就会加载。</p><p>在<code>pom</code>文件中引入依赖：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!--shenyu data sync start use http--&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">org.apache.shenyu</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">shenyu-spring-boot-starter-sync-data-http</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>application.yml</code>配置文件中添加配置：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">       </span><span class="token key atrule" style="color:#00a4db">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">url</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//localhost</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">9095</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当网关启动时，配置类<code>HttpSyncDataConfiguration</code>就会执行，加载相应的<code>Bean</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Http sync data configuration for spring boot.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnClass(HttpSyncDataService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(prefix = &quot;shenyu.sync.http&quot;, name = &quot;url&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@EnableConfigurationProperties(value = HttpConfig.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private static final Logger LOGGER = LoggerFactory.getLogger(HttpSyncDataConfiguration.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * Rest template.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 创建RestTemplate</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param httpConfig the http config       http配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @return the rest template</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public RestTemplate restTemplate(final HttpConfig httpConfig) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    OkHttp3ClientHttpRequestFactory factory = new OkHttp3ClientHttpRequestFactory();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factory.setConnectTimeout(Objects.isNull(httpConfig.getConnectionTimeout()) ? (int) HttpConstants.CLIENT_POLLING_CONNECT_TIMEOUT : httpConfig.getConnectionTimeout());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factory.setReadTimeout(Objects.isNull(httpConfig.getReadTimeout()) ? (int) HttpConstants.CLIENT_POLLING_READ_TIMEOUT : httpConfig.getReadTimeout());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    factory.setWriteTimeout(Objects.isNull(httpConfig.getWriteTimeout()) ? (int) HttpConstants.CLIENT_POLLING_WRITE_TIMEOUT : httpConfig.getWriteTimeout());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new RestTemplate(factory);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * AccessTokenManager.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 创建AccessTokenManager,专门用户对admin进行http请求时access token的处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param httpConfig   the http config.      </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param restTemplate the rest template.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @return the access token manager.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public AccessTokenManager accessTokenManager(final HttpConfig httpConfig, final RestTemplate restTemplate) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new AccessTokenManager(restTemplate, httpConfig);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * Http sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 创建 HttpSyncDataService </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param httpConfig         the http config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param pluginSubscriber   the plugin subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param restTemplate       the rest template</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param metaSubscribers    the meta subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param authSubscribers    the auth subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param accessTokenManager the access token manager</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @return the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public SyncDataService httpSyncDataService(final ObjectProvider&lt;HttpConfig&gt; httpConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             final ObjectProvider&lt;RestTemplate&gt; restTemplate,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                             final ObjectProvider&lt;AccessTokenManager&gt; accessTokenManager) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOGGER.info(&quot;you use http long pull sync shenyu data&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return new HttpSyncDataService(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(httpConfig.getIfAvailable()),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(pluginSubscriber.getIfAvailable()),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(restTemplate.getIfAvailable()),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            metaSubscribers.getIfAvailable(Collections::emptyList),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            authSubscribers.getIfAvailable(Collections::emptyList),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            Objects.requireNonNull(accessTokenManager.getIfAvailable())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>HttpSyncDataConfiguration</code>是<code>Http长轮询</code>数据同步的配置类，负责创建<code>HttpSyncDataService</code>（负责<code>http</code>数据同步的具体实现）、<code>RestTemplate</code>和<code>AccessTokenManager</code> （负责与<code>admin</code>http调用时access token的处理）。它的注解如下：</p><ul><li><code>@Configuration</code>：表示这是一个配置类；</li><li><code>@ConditionalOnClass(HttpSyncDataService.class)</code>：条件注解，表示要有<code>HttpSyncDataService</code>这个类；</li><li><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.http&quot;, name = &quot;url&quot;)</code>：条件注解，要有<code>shenyu.sync.http.url</code>这个属性配置。</li><li><code>@EnableConfigurationProperties(value = HttpConfig.class)</code>：表示让HttpConfig上的注解<code>@ConfigurationProperties(prefix = &quot;shenyu.sync.http&quot;)</code>生效，将<code>HttpConfig</code>这个配置类注入Ioc容器中。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-属性初始化"></a>2.2 属性初始化<a class="hash-link" href="#22-属性初始化" title="Direct link to heading">#</a></h4><ul><li>HttpSyncDataService</li></ul><p>在<code>HttpSyncDataService</code>的构造函数中，完成属性初始化。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了属性字段......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public HttpSyncDataService(final HttpConfig httpConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               final RestTemplate restTemplate,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               final List&lt;AuthDataSubscriber&gt; authDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                               final AccessTokenManager accessTokenManager) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 1.设置accessTokenManager</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          this.accessTokenManager = accessTokenManager;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 2.创建数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          this.factory = new DataRefreshFactory(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 3.shenyu-admin的url， 多个用逗号(,)分割</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          this.serverList = Lists.newArrayList(Splitter.on(&quot;,&quot;).split(httpConfig.getUrl()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 4.只用于http长轮询的restTemplate</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          this.restTemplate = restTemplate;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 5.开始执行长轮询任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          this.start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面代码中省略了其他函数和相关字段，在构造函数中完成属性的初始化，主要是：</p><ul><li><p>设置<code>accessTokenManager</code>，定时向<code>admin</code>请求更新<code>accessToken</code>的值。然后每次向<code>admin</code>发起请求时都必须将<code>header</code>的<code>X-Access-Token</code>属性设置成<code>accessToken</code>对应的值；</p></li><li><p>创建数据处理器，用于后续缓存各种类型的数据（插件、选择器、规则、元数据和认证数据）；</p></li><li><p>获取<code>admin</code>属性配置，主要是获取<code>admin</code>的<code>url</code>，<code>admin</code>有可能是集群，多个用逗号<code>(,)</code>分割；</p></li><li><p>设置<code>RestTemplate</code>，用于向<code>admin</code>发起请求；</p></li><li><p>开始执行长轮询任务。</p></li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-开始长轮询"></a>2.3 开始长轮询<a class="hash-link" href="#23-开始长轮询" title="Direct link to heading">#</a></h4><ul><li>HttpSyncDataService#start()</li></ul><p>在<code>start()</code>方法中，干了两件事情，一个是获取全量数据，即请求<code>admin</code>端获取所有需要同步的数据，然后将获取到的数据缓存到网关内存中。另一个是开启多线程执行长轮询任务。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // // 只初始化一次，通过原子类实现。 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (RUNNING.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 初次启动，获取全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.fetchGroupConfig(ConfigGroupEnum.values());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 一个后台服务，一个线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int threadSize = serverList.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 自定义线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                new LinkedBlockingQueue&lt;&gt;(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ShenyuThreadFactory.create(&quot;http-long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 开始长轮询，一个admin服务，创建一个线程用于数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.info(&quot;shenyu http long polling was started, executor=[{}]&quot;, executor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="231-获取全量数据"></a>2.3.1 获取全量数据<a class="hash-link" href="#231-获取全量数据" title="Direct link to heading">#</a></h5><ul><li>HttpSyncDataService#fetchGroupConfig()</li></ul><p><code>ShenYu</code>将所有需要同步的数据进行了分组，一共有5种数据类型，分别是插件、选择器、规则、元数据和认证数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public enum ConfigGroupEnum {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    APP_AUTH, // 认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    PLUGIN, //插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    RULE, // 规则</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    SELECTOR, // 选择器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    META_DATA; // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>admin</code>有可能是集群，这里通过循环的方式向每个<code>admin</code>发起请求，有一个执行成功了，那么向<code>admin</code>获取全量数据并缓存到网关的操作就执行成功。如果出现了异常，就向下一个<code>admin</code>发起请求。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void fetchGroupConfig(final ConfigGroupEnum... groups) throws ShenyuException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // admin有可能是集群，这里通过循环的方式向每个admin发起请求</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (int index = 0; index &lt; this.serverList.size(); index++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      String server = serverList.get(index);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 真正去执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.doFetchGroupConfig(server, groups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 有一个成功，就成功了，可以退出循环</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } catch (ShenyuException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 出现异常，尝试执行下一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 最后一个也执行失败了，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (index &gt;= serverList.size() - 1) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          throw e;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.warn(&quot;fetch config fail, try another one: {}&quot;, serverList.get(index + 1));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpSyncDataService#doFetchGroupConfig()</li></ul><p>在此方法中，首先拼装请求参数，然后通过<code>httpClient</code>发起请求，到<code>admin</code>中获取数据，最后将获取到的数据更新到网关内存中。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void doFetchGroupConfig(final String server, final ConfigGroupEnum... groups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 拼请求参数，所有分组枚举类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    StringBuilder params = new StringBuilder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ConfigGroupEnum groupKey : groups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      params.append(&quot;groupKeys&quot;).append(&quot;=&quot;).append(groupKey.name()).append(&quot;&amp;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // admin端提供的接口  /configs/fetch</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String url = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_FETCH + &quot;?&quot; + StringUtils.removeEnd(params.toString(), &quot;&amp;&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;request configs: [{}]&quot;, url);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String json;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      HttpHeaders headers = new HttpHeaders();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 设置accessToken</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      HttpEntity&lt;String&gt; httpEntity = new HttpEntity&lt;&gt;(headers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 2. 发起请求，获取变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      json = this.restTemplate.exchange(url, HttpMethod.GET, httpEntity, String.class).getBody();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (RestClientException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      String message = String.format(&quot;fetch config fail from server[%s], %s&quot;, url, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.warn(message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new ShenyuException(message, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 3. 更新网关内存中数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean updated = this.updateCacheWithJson(json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (updated) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.debug(&quot;get latest configs: [{}]&quot;, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新成功，此方法就执行完成了</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;The config of the server[{}] has not been updated or is out of date. Wait for 30s to listen for changes again.&quot;, server);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 服务端没有数据更新，就等30s</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ThreadUtils.sleep(TimeUnit.SECONDS, 30);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从代码中，可以看到 <code>admin</code>端提供的获取全量数据接口是  <code>/configs/fetch</code>，这里先不进一步深入，放在后文再分析。</p><p>获取到<code>admin</code>返回结果数据，并成功更新，那么此方法就执行结束了。如果没有更新成功，那么有可能是服务端没有数据更新，就等待<code>30s</code>。</p><p>这里需要提前说明一下，网关在判断是否更新成功时，有比对数据的操作，马上就会提到。</p><ul><li>HttpSyncDataService#updateCacheWithJson()</li></ul><p>更新网关内存中的数据。使用<code>GSON</code>进行反序列化，从属性<code>data</code>中拿真正的数据，然后交给<code>DataRefreshFactory</code>去做更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean updateCacheWithJson(final String json) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 使用GSON进行反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        JsonObject jsonObject = GSON.fromJson(json, JsonObject.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // if the config cache will be updated?</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return factory.executor(jsonObject.getAsJsonObject(&quot;data&quot;));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>DataRefreshFactory#executor()</li></ul><p>根据不同数据类型去更新数据，返回更新结果。具体更新逻辑交给了<code>dataRefresh.refresh()</code>方法。在更新结果中，有一种数据类型进行了更新，就表示此次操作发生了更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean executor(final JsonObject data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //并行更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;Boolean&gt; result = ENUM_MAP.values().parallelStream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .map(dataRefresh -&gt; dataRefresh.refresh(data))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //有一个更新就表示此次发生了更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return result.stream().anyMatch(Boolean.TRUE::equals);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataRefresh#refresh()</li></ul><p>数据更新逻辑采用的是模板方法设计模式，通用操作在抽象方法中完成，不同的实现逻辑由子类完成。5种数据类型具体的更新逻辑有些差异，但是也存在通用的更新逻辑，类图关系如下：</p><p><img src="/zh/assets/images/data-refresh-a5628c71ea221ffb0a7a45f4ed40ae0e.png"></p><p>在通用的<code>refresh()</code>方法中，负责数据类型转换，判断是否需要更新，和实际的数据刷新操作。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataRefresh&lt;T&gt; implements DataRefresh {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public Boolean refresh(final JsonObject data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 数据类型转换</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    JsonObject jsonObject = convert(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(jsonObject)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean updated = false;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 得到数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigData&lt;T&gt; result = fromJson(jsonObject);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 是否需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (this.updateCacheIfNeed(result)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      updated = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 真正的更新逻辑，数据刷新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      refresh(result.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return updated;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataRefresh#updateCacheIfNeed()</li></ul><p>数据转换的过程，就是根据不同的数据类型进行转换，我们就不再进一步追踪了，看看数据是否需要更新的逻辑。方法名是<code>updateCacheIfNeed()</code>，通过方法重载实现。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataRefresh&lt;T&gt; implements DataRefresh {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // result是数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected abstract boolean updateCacheIfNeed(ConfigData&lt;T&gt; result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // newVal是获取到的最新的值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // groupEnum 是哪种数据类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected boolean updateCacheIfNeed(final ConfigData&lt;T&gt; newVal, final ConfigGroupEnum groupEnum) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果是第一次，那么直接放到cache中，返回 true，表示此次进行了更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (GROUP_CACHE.putIfAbsent(groupEnum, newVal) == null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ResultHolder holder = new ResultHolder(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    GROUP_CACHE.merge(groupEnum, newVal, (oldVal, value) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // md5 值相同，不需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (StringUtils.equals(oldVal.getMd5(), newVal.getMd5())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.info(&quot;Get the same config, the [{}] config cache will not be updated, md5:{}&quot;, groupEnum, oldVal.getMd5());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return oldVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 当前缓存的数据修改时间大于 新来的数据，不需要更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // must compare the last update time</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (oldVal.getLastModifyTime() &gt;= newVal.getLastModifyTime()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.info(&quot;Last update time earlier than the current configuration, the [{}] config cache will not be updated&quot;, groupEnum);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return oldVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.info(&quot;update {} config: {}&quot;, groupEnum, newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      holder.result = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return newVal;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return holder.result;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从上面的源码中可以看到，有两种情况不需要更新：</p><ul><li>两个的数据的<code>md5</code> 值相同，不需要更新;</li><li>当前缓存的数据修改时间大于 新来的数据，不需要更新。</li></ul><p>其他情况需要更新数据。</p><p>分析到这里，就将<code>start()</code> 方法中初次启动，获取全量数据的逻辑分析完了，接下来是长轮询的操作。为了方便，我将<code>start()</code>方法再粘贴一次：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // // 只初始化一次，通过原子类实现。 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (RUNNING.compareAndSet(false, true)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 初次启动，获取全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.fetchGroupConfig(ConfigGroupEnum.values());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 一个后台服务，一个线程</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      int threadSize = serverList.size();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 自定义线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.executor = new ThreadPoolExecutor(threadSize, threadSize, 60L, TimeUnit.SECONDS,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              new LinkedBlockingQueue&lt;&gt;(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              ShenyuThreadFactory.create(&quot;http-long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 开始长轮询，一个admin服务，创建一个线程用于数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.serverList.forEach(server -&gt; this.executor.execute(new HttpLongPollingTask(server)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.info(&quot;shenyu http long polling was started, executor=[{}]&quot;, executor);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h5><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="232-执行长轮询任务"></a>2.3.2 执行长轮询任务<a class="hash-link" href="#232-执行长轮询任务" title="Direct link to heading">#</a></h5><ul><li>HttpLongPollingTask#run()</li></ul><p>长轮询任务是<code>HttpLongPollingTask</code>，它实现了<code>Runnable</code>接口，任务逻辑在<code>run()</code>方法中。通过<code>while()</code>循环实现不断执行任务，即长轮询。在每一次的轮询中有三次重试逻辑，一次轮询任务失败了，等 <code>5s</code> 再继续，<code>3</code> 次都失败了，等<code>5</code> 分钟再试。</p><p>开始长轮询，一个<code>admin</code>服务，创建一个线程用于数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class HttpLongPollingTask implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final String server;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  HttpLongPollingTask(final String server) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.server = server;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 一直轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    while (RUNNING.get()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 默认重试 3 次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      int retryTimes = 3;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (int time = 1; time &lt;= retryTimes; time++) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          doLongPolling(server);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          if (time &lt; retryTimes) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOG.warn(&quot;Long polling failed, tried {} times, {} times left, will be suspended for a while! {}&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    time, retryTimes - time, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 长轮询失败了，等 5s 再继续</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ThreadUtils.sleep(TimeUnit.SECONDS, 5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          LOG.error(&quot;Long polling failed, try again after 5 minutes!&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          // 3 次都失败了，等 5 分钟再试</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          ThreadUtils.sleep(TimeUnit.MINUTES, 5);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.warn(&quot;Stop http long polling.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpSyncDataService#doLongPolling()</li></ul><p>执行长轮询任务的核心逻辑：</p><ul><li>根据数据类型组装请求参数：<code>md5</code> 和 <code>lastModifyTime</code>；</li><li>组装请求头和请求体；</li><li>向<code>admin</code>发起请求，判断组数据是否发生变更；</li><li>根据发生变更的组，再去获取数据。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpSyncDataService implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void doLongPolling(final String server) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 组装请求参数：md5 和 lastModifyTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;&gt;(8);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (ConfigGroupEnum group : ConfigGroupEnum.values()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ConfigData&lt;?&gt; cacheConfig = factory.cacheConfigData(group);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (cacheConfig != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String value = String.join(&quot;,&quot;, cacheConfig.getMd5(), String.valueOf(cacheConfig.getLastModifyTime()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        params.put(group.name(), Lists.newArrayList(value));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 组装请求头和请求体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    HttpHeaders headers = new HttpHeaders();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 设置accessToken</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    headers.set(Constants.X_ACCESS_TOKEN, this.accessTokenManager.getAccessToken());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; httpEntity = new HttpEntity&lt;&gt;(params, headers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String listenerUrl = server + Constants.SHENYU_ADMIN_PATH_CONFIGS_LISTENER;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    JsonArray groupJson;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //向admin发起请求，判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //这里只是判断了某个组是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      String json = this.restTemplate.postForEntity(listenerUrl, httpEntity, String.class).getBody();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.info(&quot;listener result: [{}]&quot;, json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      JsonObject responseFromServer = GsonUtils.getGson().fromJson(json, JsonObject.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      groupJson = responseFromServer.getAsJsonArray(&quot;data&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (RestClientException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      String message = String.format(&quot;listener configs fail, server:[%s], %s&quot;, server, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      throw new ShenyuException(message, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 根据发生变更的组，再去获取数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 官网对此处的解释：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这里可能会存在一个疑问：为什么不是直接将变更的数据写出？</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 我们在开发的时候，也深入讨论过该问题，因为 http 长轮询机制只能保证准实时，如果在网关层处理不及时，</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 个人理解：</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果将变更数据直接写出，当管理员频繁更新配置时，第一次更新了，将client移除阻塞队列，返回响应信息给网关。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果这个时候进行了第二次更新，那么当前的client是不在阻塞队列中，所以这一次的变更就会错过。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 网关层处理不及时，也是同理。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 这是一个长轮询，一个网关一个同步线程，可能存在耗时的过程。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 如果admin有数据变更，当前网关client是没有在阻塞队列中，就不到数据。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.nonNull(groupJson) &amp;&amp; groupJson.size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // fetch group configuration async.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      ConfigGroupEnum[] changedGroups = GsonUtils.getGson().fromJson(groupJson, ConfigGroupEnum[].class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.info(&quot;Group config changed: {}&quot;, Arrays.toString(changedGroups));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.doFetchGroupConfig(server, changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里需要特别解释一点的是：在长轮询任务中，为什么不直接拿到变更的数据？而是先判断哪个分组数据发生了变更，然后再次请求<code>admin</code>，获取变更数据？</p><p>官网对此处的解释是：</p><blockquote><p>网关收到响应信息之后，只知道是哪个 Group 发生了配置变更，还需要再次请求该 Group 的配置数据。
这里可能会存在一个疑问：为什么不是直接将变更的数据写出？
我们在开发的时候，也深入讨论过该问题，因为 <code>http</code> 长轮询机制只能保证准实时，如果在网关层处理不及时，
或者管理员频繁更新配置，很有可能便错过了某个配置变更的推送，安全起见，我们只告知某个 Group 信息发生了变更。</p></blockquote><p>个人理解是：</p><blockquote><p>如果将变更数据直接写出，管理员频繁更新配置时，第一次更新了，将<code>client</code>移除阻塞队列，返回响应信息给网关。如果这个时候进行了第二次更新，那么当前的<code>client</code>是不在阻塞队列中，所以这一次的变更就会错过。网关层处理不及时，也是同理。 这是一个长轮询，一个网关一个同步线程，可能存在耗时的过程。如果<code>admin</code>有数据变更，当前网关client是没有在阻塞队列中，就会更新不到数据。</p></blockquote><p>我们还没有分析到<code>admin</code>端的处理逻辑，先大概说一下。在<code>admin</code>端，会将网关<code>client</code>放到阻塞队列，有数据变更，网关<code>client</code>就会出队列，发送变更数据。所以，如果有数据变更时，网关<code>client</code>不在阻塞队列，那么就无法得到当前变更的数据。</p><p>知道哪个分组数据发生变更时，主动再向<code>admin</code>获取变更的数据，根据分组不同，全量拿数据。调用方法是<code>doFetchGroupConfig()</code>，这个在前面已经分析过了。</p><p>分析到这里，网关端的数据同步操作就完成了。长轮询任务就是不断向<code>admin</code>发起请求，看看数据是否发生变更，如果有分组数据发生变更，那么就再主动向<code>admin</code>发起请求，获取变更数据，然后更新网关内存中的数据。</p><p>网关端长轮询任务流程：</p><p><img src="/zh/assets/images/http-long-polling-sequence-zh-9d03d97d038b1f3348c31b9eb0133086.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-admin数据同步"></a>3. admin数据同步<a class="hash-link" href="#3-admin数据同步" title="Direct link to heading">#</a></h3><p>从前面分析的过程中，可以看到，网关端主要调用<code>admin</code>的两个接口：</p><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li><li><code>/configs/fetch</code>：获取变更组数据。</li></ul><p>直接从这两个接口分析的话，可能有的地方不好理解，所以我们还是从<code>admin</code>启动流程开始分析数据同步过程。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-加载配置"></a>3.1 加载配置<a class="hash-link" href="#31-加载配置" title="Direct link to heading">#</a></h4><p>如果在配置文件<code>application.yml</code>中，进行了如下配置，就表示通过<code>http长轮询</code>的方式进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>程序启动时，通过<code>springboot</code>条件装配实现数据同步类的配置加载。在这个过程中，会创建<code>HttpLongPollingDataChangedListener</code>，负责处理长轮询的相关实现逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * http长轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * http long polling.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(name = &quot;shenyu.sync.http.enabled&quot;, havingValue = &quot;true&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableConfigurationProperties(HttpSyncProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class HttpLongPollingListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public HttpLongPollingDataChangedListener httpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new HttpLongPollingDataChangedListener(httpSyncProperties);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-数据变更监听器实例化"></a>3.2 数据变更监听器实例化<a class="hash-link" href="#32-数据变更监听器实例化" title="Direct link to heading">#</a></h4><ul><li>HttpLongPollingDataChangedListener</li></ul><p>数据变更监听器通过构造函数的方式完成实例化和初始化操作。在构造函数中会创建阻塞队列，用于存放客户端；创建线程池，用于执行延迟任务，周期任务；保存长轮询相关属性信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public HttpLongPollingDataChangedListener(final HttpSyncProperties httpSyncProperties) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 默认客户端（这里是网关）1024个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.clients = new ArrayBlockingQueue&lt;&gt;(1024);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // ScheduledThreadPoolExecutor 可以执行延迟任务，周期任务，普通任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.scheduler = new ScheduledThreadPoolExecutor(1,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ShenyuThreadFactory.create(&quot;long-polling&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 长轮询的属性信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.httpSyncProperties = httpSyncProperties;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>另外，它的类图关系如下：</p><p><img src="/zh/assets/images/data-changed-listener-1c8e4c0f4279cdb33b27c52cc933cac5.png"></p><p>实现了<code>InitializingBean</code>接口，所以在<code>bean</code>的初始化过程中执行<code>afterInitialize()</code>方法。通过线程池执行周期任务：更新内存中<code>（CACHE）</code>的数据每隔<code>5</code>分钟执行一次，<code>5</code>分钟后开始执行。刷新本地缓存就是从数据库读取数据到本地缓存（这里就是内存），通过<code>refreshLocalCache()</code>完成。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 在 InitializingBean接口中的afterPropertiesSet()方法中被调用，即在bean的初始化过程中执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected void afterInitialize() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    long syncInterval = httpSyncProperties.getRefreshInterval().toMillis();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 执行周期任务：更新内存中（CACHE）的数据每隔5分钟执行一次，5分钟后开始执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 防止admin先启动一段时间后，产生了数据；然后网关初次连接时，没有拿到全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scheduler.scheduleWithFixedDelay(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      LOG.info(&quot;http sync strategy refresh config start.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 从数据库读取数据到本地缓存（这里就是内存）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.refreshLocalCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.info(&quot;http sync strategy refresh config success.&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      } catch (Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.error(&quot;http sync strategy refresh config error!&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, syncInterval, syncInterval, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;http sync strategy refresh interval: {}ms&quot;, syncInterval);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>refreshLocalCache()</li></ul><p>分别对5种数据类型进行更新。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 从数据库读取数据到本地缓存（这里就是内存）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void refreshLocalCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.updateAppAuthCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.updatePluginCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.updateRuleCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.updateSelectorCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.updateMetaDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>5个更新方法的逻辑是类似的，调用<code>service</code>方法获取数据，然后放到内存<code>CACHE</code>中。以更新规则数据方法<code>updateRuleCache()</code>为例，传入规则枚举类型，调用<code>ruleService.listAll()</code>从数据库获取所有规则数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Update rule cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void updateRuleCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updateCache(ConfigGroupEnum.RULE, ruleService.listAll());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>updateCache()</li></ul><p>使用数据库中的数据更新内存中的数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 缓存数据的 Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected static final ConcurrentMap&lt;String, ConfigDataCache&gt; CACHE = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * if md5 is not the same as the original, then update lcoal cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 更新缓存中的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param group ConfigGroupEnum</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param &lt;T&gt; the type of class</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param data the new config data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  protected &lt;T&gt; void updateCache(final ConfigGroupEnum group, final List&lt;T&gt; data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //数据序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String json = GsonUtils.getInstance().toJson(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //传入md5值和修改时间</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigDataCache newVal = new ConfigDataCache(group.name(), json, Md5Utils.md5(json), System.currentTimeMillis());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //更新分组数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigDataCache oldVal = CACHE.put(newVal.getGroup(), newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOG.info(&quot;update config cache[{}], old: {}, updated: {}&quot;, group, oldVal, newVal);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>初始化的过程就是启动周期性任务，定时从数据库获取数据更新内存数据。</p><p>接下来开始对两个接口开始分析：</p><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li><li><code>/configs/fetch</code>：获取变更组数据。</li></ul><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33--数据变更轮询接口"></a>3.3  数据变更轮询接口<a class="hash-link" href="#33--数据变更轮询接口" title="Direct link to heading">#</a></h4><ul><li><code>/configs/listener</code>：判断组数据是否发生变更；</li></ul><p>接口类是<code>ConfigController</code>，只有使用<code>http长轮询</code>进行数据同步时才会生效。接口方法<code>listener()</code>没有其他逻辑，直接调用<code>doLongPolling()</code>方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">   </span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * This Controller only when HttpLongPollingDataChangedListener exist, will take effect.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/configs&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConfigController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final HttpLongPollingDataChangedListener longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.longPollingListener = longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 监听数据变更，执行长轮询</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request  the request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param response the response</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(value = &quot;/listener&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void listener(final HttpServletRequest request, final HttpServletResponse response) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        longPollingListener.doLongPolling(request, response);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpLongPollingDataChangedListener#doLongPolling()</li></ul><p>执行长轮询任务：如果有数据变更，将会立即响应给客户端（这里就是网关端）。否则，客户端会一直被阻塞，直到有数据变更或者超时。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class HttpLongPollingDataChangedListener extends AbstractDataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 执行长轮询：如果有数据变更，会立即响应给客户端（这里就是网关端）。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 否则，否则客户端会一直被阻塞，直到有数据变更或者超时。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param response</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void doLongPolling(final HttpServletRequest request, final HttpServletResponse response) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // compare group md5</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 比较md5，判断网关的数据和admin端的数据是否一致，得到发生变更的数据组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;ConfigGroupEnum&gt; changedGroup = compareChangedGroup(request);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String clientIp = getRemoteIp(request);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // response immediately.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 有变更的数据，则立即向网关响应</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (CollectionUtils.isNotEmpty(changedGroup)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.generateResponse(response, changedGroup);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      Log.info(&quot;send response with the changed group, ip={}, group={}&quot;, clientIp, changedGroup);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 没有变更，则将客户端（这里就是网关）放进阻塞队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final AsyncContext asyncContext = request.startAsync();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    asyncContext.setTimeout(0L);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    scheduler.execute(new LongPollingClient(asyncContext, clientIp, HttpConstants.SERVER_MAX_HOLD_TIMEOUT));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>HttpLongPollingDataChangedListener#compareChangedGroup()</li></ul><p>判断组数据是否发生变更，判断逻辑是比较网关端和<code>admin</code>端的<code>md5</code>值和<code>lastModifyTime</code>。</p><ul><li>如果<code>md5</code>值不一样，那么需要更新；</li><li>如果<code>admin</code>端的<code>lastModifyTime</code>大于网关端的<code>lastModifyTime</code>，那么需要更新。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param request</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private List&lt;ConfigGroupEnum&gt; compareChangedGroup(final HttpServletRequest request) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConfigGroupEnum&gt; changedGroup = new ArrayList&lt;&gt;(ConfigGroupEnum.values().length);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (ConfigGroupEnum group : ConfigGroupEnum.values()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 网关端数据的md5值和lastModifyTime</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String[] params = StringUtils.split(request.getParameter(group.name()), &#x27;,&#x27;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (params == null || params.length != 2) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                throw new ShenyuException(&quot;group param invalid:&quot; + request.getParameter(group.name()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String clientMd5 = params[0];</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            long clientModifyTime = NumberUtils.toLong(params[1]);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigDataCache serverCache = CACHE.get(group.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // do check. 判断组数据是否发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (this.checkCacheDelayAndUpdate(serverCache, clientMd5, clientModifyTime)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                changedGroup.add(group);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return changedGroup;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>LongPollingClient</li></ul><p>没有变更数据，则将客户端（这里就是网关）放进阻塞队列。阻塞时间是60秒，即60秒后移除，并响应客户端。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class LongPollingClient implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 先设置定时任务：60秒后移除，并响应客户端</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                this.asyncTimeoutFuture = scheduler.schedule(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    clients.remove(LongPollingClient.this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;ConfigGroupEnum&gt; changedGroups = compareChangedGroup((HttpServletRequest) asyncContext.getRequest());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sendResponse(changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }, timeoutTime, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 添加到阻塞队列</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.add(this);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (Exception ex) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;add long polling client error&quot;, ex);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Send response.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param changedGroups the changed groups</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        void sendResponse(final List&lt;ConfigGroupEnum&gt; changedGroups) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // cancel scheduler</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (null != asyncTimeoutFuture) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                asyncTimeoutFuture.cancel(false);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 响应变更的组</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            generateResponse((HttpServletResponse) asyncContext.getResponse(), changedGroups);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            asyncContext.complete();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34--获取变更数据接口"></a>3.4  获取变更数据接口<a class="hash-link" href="#34--获取变更数据接口" title="Direct link to heading">#</a></h4><ul><li><code>/configs/fetch</code>：获取变更数据；</li></ul><p>根据网关传入的参数，获取分组数据，返回结果。主要实现方法是<code>longPollingListener.fetchConfig()</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnBean(HttpLongPollingDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/configs&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ConfigController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final HttpLongPollingDataChangedListener longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConfigController(final HttpLongPollingDataChangedListener longPollingListener) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      this.longPollingListener = longPollingListener;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Fetch configs shenyu result.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量获取分组数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param groupKeys the group keys</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the shenyu result</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @GetMapping(&quot;/fetch&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult fetchConfigs(@NotNull final String[] groupKeys) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Map&lt;String, ConfigData&lt;?&gt;&gt; result = Maps.newHashMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String groupKey : groupKeys) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            ConfigData&lt;?&gt; data = longPollingListener.fetchConfig(ConfigGroupEnum.valueOf(groupKey));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            result.put(groupKey, data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.SUCCESS, result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 省略了其他接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>AbstractDataChangedListener#fetchConfig()</li></ul><p>数据获取直接从<code>CACHE</code>中拿，然后根据不同分组类型进行匹配，封装。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataChangedListener implements DataChangedListener, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * fetch configuration from cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * 获取分组下的全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @param groupKey the group key</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * @return the configuration data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public ConfigData&lt;?&gt; fetchConfig(final ConfigGroupEnum groupKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 直接从 CACHE 中拿数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ConfigDataCache config = CACHE.get(groupKey.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    switch (groupKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      case APP_AUTH: // 认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return buildConfigData(config, AppAuthData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      case PLUGIN: // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return buildConfigData(config, PluginData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      case RULE:   // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return buildConfigData(config, RuleData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      case SELECTOR:  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return buildConfigData(config, SelectorData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      case META_DATA: // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return buildConfigData(config, MetaData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException(&quot;Unexpected groupKey: &quot; + groupKey);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="35-数据变更"></a>3.5 数据变更<a class="hash-link" href="#35-数据变更" title="Direct link to heading">#</a></h4><p>在之前的<code>websocket</code>数据同步和<code>zookeeper</code>数据同步源码分析文章中，我们知道<code>admin</code>端数据同步设计结构如下：</p><p><img src="/zh/assets/images/data-changed-listener-admin-2f384e703652e9e28db8447b1cbdaea7.png"></p><p>各种数据变更监听器都是<code>DataChangedListener</code>的子类。</p><p>当在<code>admin</code>端修改数据后，通过<code>Spring</code>的事件处理机制，发送事件通知。发送逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Event forwarders, which forward the changed events to each ConfigEventListener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据变更事件分发器：当admin端有数据发生变更时，将变更数据同步到 ShenYu 网关</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据变更依赖于Spring的事件监听机制：ApplicationEventPublisher --&gt; ApplicationEvent --&gt; ApplicationListener</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 当选择器数据更新时，更新API文档信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    applicationContext.getBean(LoadServiceDocEntry.class).loadDocOnSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>假设，对插件信息进行了修改，通过<code>http长轮询</code>的方式进行数据同步，那么<code>listener.onPluginChanged()</code>的实际调用的是<code>org.apache.shenyu.admin.listener.AbstractDataChangedListener#onPluginChanged</code>：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 在admin的操作，有插件发生了更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param changed   the changed</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param eventType the event type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isEmpty(changed)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新内存CACHE</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.updatePluginCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 执行变更任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.afterPluginChanged(changed, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>有两个处理操作，一是更新内存<code>CACHE</code>，这个在前面分析过了；另一个是执行变更任务，在线程池中执行。</p><ul><li>HttpLongPollingDataChangedListener#afterPluginChanged()</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void afterPluginChanged(final List&lt;PluginData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 在线程池中执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        scheduler.execute(new DataChangeTask(ConfigGroupEnum.PLUGIN));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>DataChangeTask</li></ul><p>数据变更任务：将阻塞队列中的客户端依次移除，并发送响应，通知网关有组数据发生变更。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">class DataChangeTask implements Runnable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //省略了其他逻辑 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void run() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 阻塞队列中的客户端超过了给定的值100，则分批执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (clients.size() &gt; httpSyncProperties.getNotifyBatchSize()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;LongPollingClient&gt; targetClients = new ArrayList&lt;&gt;(clients.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.drainTo(targetClients);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                List&lt;List&lt;LongPollingClient&gt;&gt; partitionClients = Lists.partition(targetClients, httpSyncProperties.getNotifyBatchSize());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">               // 分批执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                partitionClients.forEach(item -&gt; scheduler.execute(() -&gt; doRun(item)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行任务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                doRun(clients);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private void doRun(final Collection&lt;LongPollingClient&gt; clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通知所有客户端发生了数据变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (Iterator&lt;LongPollingClient&gt; iter = clients.iterator(); iter.hasNext();) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LongPollingClient client = iter.next();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                iter.remove();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 发送响应</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.sendResponse(Collections.singletonList(groupKey));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                LOG.info(&quot;send response with the changed group,ip={}, group={}, changeTime={}&quot;, client.ip, groupKey, changeTime);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>至此，<code>admin</code>端数据同步逻辑就分析完了。在基于<code>http长轮询</code>数据同步是，它主要有三个功能：</p><ul><li>提供数据变更监听接口；</li><li>提供获取变更数据接口；</li><li>有数据变更时，移除阻塞队列中的客户端，并响应结果。</li></ul><p>最后，用三张图描述下<code>admin</code>端长轮询任务流程：</p><ul><li><code>/configs/listener</code>数据变更监听接口：</li></ul><p><img src="/zh/assets/images/http-long-polling-listener-zh-a0458f05d312cb977f000662b3791567.png"></p><ul><li><code>/configs/fetch</code>获取变更数据接口：</li></ul><p><img src="/zh/assets/images/http-long-polling-fetch-zh-59963a9119cc79d08e95aa5f4442f413.png"></p><ul><li>在admin后台管理系统更新数据，进行数据同步：</li></ul><p><img src="/zh/assets/images/http-long-polling-admin-update-zh-97645cfabead723acf9243cfae2d2dbc.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-总结"></a>4. 总结<a class="hash-link" href="#4-总结" title="Direct link to heading">#</a></h3><p>本文主要对<code>ShenYu</code>网关中的<code>http长轮询</code>数据同步进行了源码分析。涉及到的主要知识点如下：</p><ul><li><code>http长轮询</code>由网关端主动发起请求，不断请求<code>admin</code>端；</li><li>变更数据以组为粒度（认证信息、插件、选择器、规则、元数据）；</li><li><code>http长轮询</code>结果只拿到了变更组，还需要再次发起请求获取组数据；</li><li>数据是否更新由<code>md5</code>值和修改时间<code>lastModifyTime</code>决定。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/http">http</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/Plugin-SourceCode-Analysis-Context-Path-Plugin">Context-Path插件源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars1.githubusercontent.com/u/62384022?v=4" alt="Kunshuai Zhu"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer">Kunshuai Zhu</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><blockquote><p>开始前，可以参考 <a href="/zh/blog/page/Start-SourceCode-Analysis-Start-Demo">这篇文章</a> 运行shenyu网关</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="正文"></a>正文<a class="hash-link" href="#正文" title="Direct link to heading">#</a></h3><p>首先，看<code>ContextPathPlugin#doExecute</code>方法，这是这个插件的核心。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final ShenyuPluginChain chain, final SelectorData selector, final RuleData rule) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 从JVM缓存中取得contextMappingHandle</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ContextMappingHandle contextMappingHandle = ContextPathPluginDataHandler.CACHED_HANDLE.get().obtainHandle(CacheKeyUtils.INST.getKey(rule));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 2. 根据contextMappingHandle设置shenyu上下文</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    buildContextPath(shenyuContext, contextMappingHandle);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return chain.execute(exchange);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ol><li><p>从JVM缓存中取得<code>contextMappingHandle</code></p><p>这里的<code>contextMappingHandle</code>是<code>ContextMappingHandle</code>类的实例，里面有两个成员变量：<code>contextPath</code>和<code>addPrefix</code></p><p>这两个变量在之前Admin里面的Rules表单里有出现过，是在数据同步的时候更新的。</p></li><li><p>根据contextMappingHandle设置shenyu上下文</p><p>下面是<code>ContextPathPlugin#buildContextPath</code>方法的源代码</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private void buildContextPath(final ShenyuContext context, final ContextMappingHandle handle) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String realURI = &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 1. 设置shenyu的context path，根据contextPath的长度将真实URI的前缀去掉</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isNoneBlank(handle.getContextPath())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        context.setContextPath(handle.getContextPath());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        context.setModule(handle.getContextPath());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        realURI = context.getPath().substring(handle.getContextPath().length());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加上前缀</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isNoneBlank(handle.getAddPrefix())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotBlank(realURI)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            realURI = handle.getAddPrefix() + realURI;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            realURI = handle.getAddPrefix() + context.getPath();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    context.setRealUrl(realURI);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><p>设置shenyu的context path，<strong>根据contextPath的长度将真实URI的前缀去掉</strong></p><p>你可能会有疑问，<strong>这里所谓的「根据contextPath的长度」会不会有问题呢？</strong></p><p>实际上这样的判断是没有问题的，因为请求在被Selector和Rules匹配到之后，才会被插件处理。所以在设置好Selector和Rules的前提下，是完全可以满足转换特定contextPath的需求的。</p></li></ul></li></ol><p>然后，<code>ContextPathPlugin</code>类还有一个比较重要的方法<code>skip</code>，下面展示了部分代码。我们可以发现：<strong>如果是对RPC服务的调用，就会直接跳过context_path插件。</strong></p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public Boolean skip(final ServerWebExchange exchange) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return Objects.equals(rpcType, RpcTypeEnum.DUBBO.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.GRPC.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.TARS.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.MOTAN.getName())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            || Objects.equals(rpcType, RpcTypeEnum.SOFA.getName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后，context_path插件还有另一个类<code>ContextPathPluginDataHandler</code>。这个类的作用是订阅插件的数据，当插件配置被修改、删除、增加时，就往JVM缓存里面修改、删除、新增数据。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/context-path">Context-Path</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/IntegrationTest-Analysis">集成测试剖析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars1.githubusercontent.com/u/62384022?v=4" alt="Kunshuai Zhu"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/JooKS-me" target="_blank" rel="noopener noreferrer">Kunshuai Zhu</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><p>这篇文章将会对Apache ShenYu的集成测试进行深入剖析。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="什么是集成测试"></a>什么是集成测试？<a class="hash-link" href="#什么是集成测试" title="Direct link to heading">#</a></h3><p>集成测试在一些项目里也叫E2E (End To End)测试，主要用于测试各个模块组装成一个系统后是否能符合预期。</p><p>Apache ShenYu将集成测试放在了持续集成中，利用GitHub Action，在每次向主分支提交Pull Request或是Merge时触发。这样可以大大降低项目的维护成本，提升Apache ShenYu的稳定性。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="自动化的集成测试如何实现"></a>自动化的集成测试如何实现？<a class="hash-link" href="#自动化的集成测试如何实现" title="Direct link to heading">#</a></h3><p>Apache ShenYu中，集成测试的主要步骤体现在GitHub Action工作流的脚本中，如下所示，该脚本位于 <a href="https://github.com/apache/incubator-shenyu/tree/master/.github/workflows" target="_blank" rel="noopener noreferrer">~/.github/workflows</a>目录下。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> it</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">pull_request</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">push</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">branches</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> master</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">jobs</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">build</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">strategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">matrix</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">case</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">alibaba</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">dubbo</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">runs-on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ubuntu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">latest</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">steps</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/checkout@v2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">with</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">submodules</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">...</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>下面我将从这个yaml文件出发，带你剖析整个自动化集成测试的流程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="工作流的触发"></a>工作流的触发<a class="hash-link" href="#工作流的触发" title="Direct link to heading">#</a></h3><p>由于我们在 <code>on</code> 中指定了 <code>pull_request</code> 和 <code>push.branch: master</code>，那么当我们提交pull_request或是merge分支到master（push）的时候，就会触发这个工作流。</p><p>关于更多GitHub Action的用法，可以参考 <a href="https://docs.github.com/en/actions" target="_blank" rel="noopener noreferrer">GitHub Action</a> 的文档，这里不会做详细的介绍。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="初始化环境"></a>初始化环境<a class="hash-link" href="#初始化环境" title="Direct link to heading">#</a></h3><ul><li>拉取代码</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/checkout@v2</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">with</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">submodules</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>设置跳过标志</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Set Skip Env Var</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./.github/actions/skip</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">ci</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当发生的是一些对功能无关的改动（如改动文档）时，会跳过集成测试，以节约资源。</p><ul><li>缓存maven依赖、安装Java</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Cache Maven Repos</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/setup</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">java@v1</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="构建整个项目同时构建docker镜像"></a>构建整个项目，同时构建docker镜像<a class="hash-link" href="#构建整个项目同时构建docker镜像" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI shell"><pre tabindex="0" class="prism-code language-shell codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">./mvnw -B clean </span><span class="token function" style="color:#d73a49">install</span><span class="token plain"> -Prelease,docker -Dmaven.javadoc.skip</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">true -Dmaven.test.skip</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面这行命令中，-P后面跟着<code>release,docker</code>，表示会激活pom文件中相关的profile配置。</p><p>而release和docker这两个profile，目前只在 <code>shenyu-dist</code> 下的几个子模块中存在。下面将以 <a href="https://github.com/apache/incubator-shenyu/tree/master/shenyu-dist/shenyu-admin-dist" target="_blank" rel="noopener noreferrer">shenyu-dist-admin</a> 模块为例，介绍profile为release和docker的配置的具体内容。另外，集成测试只使用了这一步构建的 <code>shenyu-admin</code> 镜像。</p><ul><li><p>首先是release</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">profile</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">release</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">activation</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">activeByDefault</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">false</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">activeByDefault</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">activation</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">build</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">finalName</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">apache-shenyu-incubating-${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">finalName</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">plugins</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">org.apache.maven.plugins</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">maven-assembly-plugin</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">executions</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">admin-bin</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">phase</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">package</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">phase</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">single</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">executions</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">descriptors</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">descriptor</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.basedir}/src/main/assembly/binary.xml</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">descriptor</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">descriptors</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">tarLongFileMode</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">posix</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">tarLongFileMode</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">plugins</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">build</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">profile</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当-P后面跟着release时，就会激活上面的 <code>maven-assembly-plugin</code> 插件。而executions中将插件的执行时机绑定在了maven生命周期package中，这也就意味着，当我们执行 <code>mvn install</code> 的时候就会触发。</p><p>configuration中指定了我们编写好的 <code>binary.xml</code>，<code>maven-assembly-plugin</code> 插件将会按照这个文件，将需要的文件复制进来，并打包。你可以点击链接查看该文件：<a href="https://github.com/apache/incubator-shenyu/blob/master/shenyu-dist/shenyu-admin-dist/src/main/assembly/binary.xml" target="_blank" rel="noopener noreferrer">shenyu-dist/shenyu-admin-dist/src/main/assembly/binary.xml</a></p><p>根据这个文件，插件会将其他模块下打包好的jar包、配置文件、启动脚本等“复制”过来，最终打成 <code>tar.gz</code> 格式的压缩包。</p></li><li><p>然后是docker</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">profile</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">docker</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">activation</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">activeByDefault</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">false</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">activeByDefault</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">activation</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">build</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">plugins</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">com.spotify</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">dockerfile-maven-plugin</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${dockerfile-maven-plugin.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">executions</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">tag-latest</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">build</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">tag</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">latest</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">tag</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">tag-version</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">id</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">build</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goal</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">goals</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">tag</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">tag</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">execution</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">executions</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">repository</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">apache/shenyu-admin</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">repository</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">buildArgs</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">APP_NAME</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">apache-shenyu-incubating-${project.version}-admin-bin</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">APP_NAME</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">buildArgs</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">                </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">configuration</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">plugin</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">plugins</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">build</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">profile</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>类比上面的release，这里是激活 <code>dockerfile-maven-plugin</code> 插件。当 <code>mvn install -Pdocker</code> 时，插件就会利用我们编写好的dockerfile构建docker镜像。</p></li></ul><p>需要注意的是，dockerfile-maven-plugin目前对aarch64架构的设备支持有限，在aarch64架构的机器上运行该插件时会出现如下错误。且在本人写这篇文章的时候已经很久没有维护，这意味着aarch64架构的设备使用这个插件的问题在短期内不会解决。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI shell"><pre tabindex="0" class="prism-code language-shell codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">ERROR</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> Failed to execute goal com.spotify:dockerfile-maven-plugin:1.4.6:build </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">tag-latest</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> on project shenyu-admin-dist: Could not build image: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: java.lang.UnsatisfiedLinkError: could not load FFI provider jnr.ffi.provider.jffi.Provider: ExceptionInInitializerError: Can&#x27;t overwrite cause with java.lang.UnsatisfiedLinkError: java.lang.UnsatisfiedLinkError: /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: dlopen</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">/private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib, </span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain">: no suitable image found.  Did find:</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">ERROR</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">         /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: no matching architecture </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> universal wrapper</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">ERROR</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain">         /private/var/folders/w2/j27f16yj7cvf_1cxbgqb89vh0000gn/T/jffi4972193792308935312.dylib: no matching architecture </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> universal wrapper</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">..</span><span class="token plain">.</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里有个临时的解决方案：</p><ol><li><p>打开一个新的shell，输入如下命令，利用 socat 将 unix socket 路由到 tcp 端口</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI shell"><pre tabindex="0" class="prism-code language-shell codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">socat TCP-LISTEN:2375,range</span><span class="token operator" style="color:#393A34">=</span><span class="token number" style="color:#36acaa">127.0</span><span class="token plain">.0.1/32,reuseaddr,fork UNIX-CLIENT:/var/run/docker.sock</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p>设置环境变量</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI shell"><pre tabindex="0" class="prism-code language-shell codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token builtin class-name">export</span><span class="token plain"> </span><span class="token assign-left variable" style="color:#36acaa">DOCKER_HOST</span><span class="token operator" style="color:#393A34">=</span><span class="token plain">tcp://127.0.0.1:2375</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li></ol><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="构建examples模块"></a>构建examples模块<a class="hash-link" href="#构建examples模块" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Build examples</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./mvnw </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">B clean install </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Pexample </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Dmaven.javadoc.skip=true </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Dmaven.test.skip=true </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">f ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">examples/pom.xml</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>因为考虑到release的需要，目前项目根目录下的pom文件中不饱含example子模块，所以上面这个步骤另外构建了examples模块。</p><p>与上面类似，这行命令也会利用maven的插件构建镜像，以供我们后续docker编排使用。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="构建定制化网关"></a>构建定制化网关<a class="hash-link" href="#构建定制化网关" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Build integrated tests</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./mvnw </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">B clean install </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Pit </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">DskipTests </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">f ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test/pom.xml</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>为了细分Apache ShenYu的不同功能的集成测试，我们在这一步将构建集成测试模块定制的网关。所谓的“定制”就是在pom文件中引入需要的最少依赖，然后代替默认的 <code>shenyu-bootstrap</code>。与上面两个步骤类似，这一步也会构建出docker镜像。</p><p>值得注意的是，这里的打包构建的方式与 <code>shenyu-dist</code> 模块的有一些不同，你可以通过对比pom文件发现。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="运行docker-compose"></a>运行docker compose<a class="hash-link" href="#运行docker-compose" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Start docker compose</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> docker</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">compose </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">f ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test/$</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> matrix.case </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">/docker</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">compose.yml up </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">d</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这一步将会根据集成测试模块下编写好的不同的 <code>docker-compose.yml</code> 文件，进行docker编排。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">version</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;3.9&quot;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">services</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu-zk</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">container_name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">zk</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> zookeeper</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">3.5</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu-redis</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> redis</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">6.0</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">alpine</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">container_name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">redis</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu-examples-http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">deploy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">resources</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">limits</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">memory</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 2048M</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">container_name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">examples</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">examples</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">latest</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu-admin</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apache/shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">admin</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">latest</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">container_name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">admin</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu-integrated-test-http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">container_name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">http</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">image</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> apache/shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">latest</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">depends_on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">shenyu-admin</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">condition</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> service_healthy</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">healthcheck</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">test</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;CMD&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;wget&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;http://shenyu-integrated-test-http:9195/actuator/health&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">timeout</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> 2s</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">retries</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">30</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">networks</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> shenyu</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>例如 <code>shenyu-integrated-test-http</code> 模块下的 <code>docker-compose.yml</code>，按顺序启动了zookeeper、redis、example、admin、网关等服务。其中，example、admin、网关的镜像是我们之前构建的。</p><p>其中，docker-compose利用 <code>depends_on</code> 确定了服务之间的拓扑关系，并且大部分服务都有相应的健康检查，待健康检查通过后才会启动下一个服务。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="运行健康检查等待docker-compose启动完毕"></a>运行健康检查，等待docker-compose启动完毕<a class="hash-link" href="#运行健康检查等待docker-compose启动完毕" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Wait for docker compose start up completely</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> bash ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test/$</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> matrix.case </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">/script/healthcheck.sh</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在这一步，宿主机会运行 <code>healthcheck.sh</code> 这个脚本，然后利用 curl 命令访问各个服务列表（在services.list文件中）的健康状态接口 <code>/actuator/health</code>，一直到服务状态都为正常才会继续。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="运行测试"></a>运行测试<a class="hash-link" href="#运行测试" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Run test</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">id</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> test</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./mvnw test </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Pit </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">f ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">integrated</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">test/$</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> matrix.case </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain">/pom.xml</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">continue-on-error</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这一步就是利用maven test命令，逐个执行 <code>/src/test/</code>  目录下的测试类。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="查看docker-compose日志"></a>查看Docker Compose日志<a class="hash-link" href="#查看docker-compose日志" title="Direct link to heading">#</a></h3><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Check test result</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> env.SKIP_CI </span><span class="token tag" style="color:#00009f">!=</span><span class="token plain"> &#x27;true&#x27;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">    docker-compose -f ./shenyu-integrated-test/${{ matrix.case }}/docker-compose.yml logs --tail=&quot;all&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">    if [[ ${{steps.test.outcome}} == &quot;failure&quot; ]]; then</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">      echo &quot;Test Failed&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">      exit 1</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">    else</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">      echo &quot;Test Successful&quot;</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">      exit 0</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">    fi</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当工作流出现错误时，docker compose的日志可以帮助我们更好的排查问题，所以在这一步我们将docker compose的日志打印出来。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/integration-test">Integration Test</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/E2eTest-Analysis">e2e测试详解</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><a href="https://github.com/HaiqiQin" target="_blank" rel="noopener noreferrer" class="avatar__photo-link avatar__photo"><img src="https://avatars.githubusercontent.com/u/80969210?v=4" alt="Haiqi Qin"></a><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/HaiqiQin" target="_blank" rel="noopener noreferrer">Haiqi Qin</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><p>这篇文章将会对Apache ShenYu的e2e模块进行深入剖析。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="什么是e2e"></a>什么是e2e<a class="hash-link" href="#什么是e2e" title="Direct link to heading">#</a></h3><p>e2e(end to end)，也叫端到端测试，是一种用于测试应用程序流是否从头到尾按设计执行的方法。 执行端到端测试的目的是识别系统依赖关系，并确保在各种系统组件和系统之间传递正确的信息。端到端测试的目的是测试 整个软件的依赖性、数据完整性以及与其他系统、接口和数据库的通信，以模拟完整的生产场景。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="e2e的优势"></a>e2e的优势<a class="hash-link" href="#e2e的优势" title="Direct link to heading">#</a></h3><p>e2e测试能够模拟真实用户场景下测试软件系统的完整性和准确性，能够验证整个系统是否按照预期工作，以及不同组件是否能够协同工作。 e2e测试有以下几个好处:</p><ol><li>帮助保证系统功能的正确性：e2e测试能够模拟真实用户场景下的交互和操作，验证整个系统是否能够按照预期工作，帮助发现系统中的潜在问题和缺陷。</li><li>提高测试覆盖率：e2e测试能够覆盖整个系统，包括前端、后端、数据库等不同层面和组件，从而提高测试覆盖率，保证测试的全面性和准确性。</li><li>保证系统的稳定性：E2E测试可以检查系统在各种情况下的稳定性和健壮性，包括系统的响应时间、错误处理能力、并发性等方面，帮助确保系统在面对高负载和异常情况时仍然能够保持稳定运行。</li><li>减少测试成本：e2e测试能够提高测试效率和准确性，减少测试成本和时间，从而帮助企业更快速地发布和交付高质量的软件产品。</li></ol><p>总之，e2e测试是一种全面的测试方式，能够验证整个系统是否按照预期工作，提高测试覆盖率和测试效率，从而保证系统的稳定性和正确性，减少测试成本和时间，是一种非常重要和有效的测试方法，所以我们需要完善 e2e相关代码。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="自动化e2e测试如何实现"></a>自动化e2e测试如何实现<a class="hash-link" href="#自动化e2e测试如何实现" title="Direct link to heading">#</a></h3><p>在Apache ShenYu中，e2e测试的主要步骤体现在GitHub Action工作流的脚本中，如下所示，该脚本位于 <a href="https://github.com/apache/incubator-shenyu/tree/master/.github/workflows" target="_blank" rel="noopener noreferrer">~/.github/workflows</a>目录下的e2e文件中。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> e2e</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">pull_request</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">push</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">branches</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> master</span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token key atrule" style="color:#00a4db">jobs</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">changes</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">build-docker-images</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">e2e-http</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">...</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token key atrule" style="color:#00a4db">e2e-case</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">runs-on</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ubuntu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">latest</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">needs</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> changes</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> build</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">docker</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">images</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">if</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> $</span><span class="token punctuation" style="color:#393A34">{</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> needs.changes.outputs.e2e == &#x27;true&#x27; </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">strategy</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">matrix</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">case</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;shenyu-e2e-case-spring-cloud&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;shenyu-e2e-case-apache-dubbo&quot;</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">&quot;shenyu-e2e-case-sofa&quot;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">steps</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">uses</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> actions/checkout@v3</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">with</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">submodules</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Load ShenYu Docker Images</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">          docker load --input /tmp/apache-shenyu-admin.tar</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">          docker load --input /tmp/apache-shenyu-bootstrap.tar</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">          docker image ls -a</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Build examples with Maven</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ./mvnw </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">B clean install </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Pexample </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Dmaven.javadoc.skip=true </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">Dmaven.test.skip=true </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">f ./shenyu</span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain">examples/pom.xml</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">-</span><span class="token plain"> </span><span class="token key atrule" style="color:#00a4db">name</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> Run ShenYu E2E Tests</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">env</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token key atrule" style="color:#00a4db">storage</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> mysql</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">run</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">|</span><span class="token scalar string" style="color:#e3116c"></span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">          bash ./shenyu-e2e/script/storage_init.sh</span></span><span class="token-line" style="color:#393A34"><span class="token scalar string" style="color:#e3116c">          ./mvnw -B -f ./shenyu-e2e/pom.xml -pl shenyu-e2e-case/${{ matrix.case }} -Dstorage=mysql test</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当工作流触发时，使用shenyu-dist模块下的dockerfile文件构建admin与bootstrap项目的镜像并上传，当e2e测试模块运行时可以加载admin与bootstrap镜像。紧接着构建examples中的模块，最后执行对应测试模块的测试方法。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="本地如何运行e2e测试"></a>本地如何运行e2e测试<a class="hash-link" href="#本地如何运行e2e测试" title="Direct link to heading">#</a></h3><p>如果需要编写e2e测试用例，首先需要在本地编码并调试。目前e2e支持两种启动方式，一个是docker启动，另一个是host启动。这两种模式可以通过在测试类中的@ShenYuTest注解中切换。host启动方式直接在本地将需要启动的服务直接启动即可运行测试代码。采用docker进行启动前，需要在先构建出相应镜像。因为ShenYu目前需要支持在github工作流进行e2e测试，建议采用docker启动方式。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="e2e启动流程剖析"></a>e2e启动流程剖析<a class="hash-link" href="#e2e启动流程剖析" title="Direct link to heading">#</a></h3><p>目前e2e模块主要分为四个部分，分别为：case、client、common以及engine。</p><p><img alt="e2e-modules" src="/zh/assets/images/e2e-modules-1ff1ff840f0fe5a53970e750624f61b6.png"></p><p>case模块存放插件的测试用例，client模块编写了admin与gateway的客户端，以便请求对应接口。common存放一些公共类，engine模块是框架的核心，依托testcontainer框架利用java代码启动docker容器并完成对admin以及gatewat的配置操作。</p><p>接下来我将依托源码对e2e启动流程进行剖析。</p><p>当我们执行case中的测试方法时，@ShenYuTest注解将会生效，对测试类进行扩展。通过@ShenYuTest，我们可以选择启动方法、对admin以及gateway配置相关参数，以及选择将要执行的docker-compose文件。对于admin以及gateway，可以配置登陆所需的用户名、密码、数据同步方式以及修改yaml的内容。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@ShenYuTest(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        mode = ShenYuEngineConfigure.Mode.DOCKER,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        services = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                @ShenYuTest.ServiceConfigure(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        serviceName = &quot;admin&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        port = 9095,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        baseUrl = &quot;http://{hostname:localhost}:9095&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        parameters = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                @ShenYuTest.Parameter(key = &quot;username&quot;, value = &quot;admin&quot;),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                @ShenYuTest.Parameter(key = &quot;password&quot;, value = &quot;123456&quot;),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                @ShenYuTest.Parameter(key = &quot;dataSyn&quot;, value = &quot;admin_websocket&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                ),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                @ShenYuTest.ServiceConfigure(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        serviceName = &quot;gateway&quot;,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        port = 9195,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        baseUrl = &quot;http://{hostname:localhost}:9195&quot;, </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        type = ShenYuEngineConfigure.ServiceType.SHENYU_GATEWAY,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        parameters = {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          @ShenYuTest.Parameter(key = &quot;application&quot;, value =  &quot;spring.cloud.discovery.enabled:true,eureka.client.enabled:true&quot;), </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                          @ShenYuTest.Parameter(key = &quot;dataSyn&quot;, value = &quot;gateway_websocket&quot;)})},           dockerComposeFile = &quot;classpath:./docker-compose.mysql.yml&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>@ShenYuTest通过ShenYuExtension类进行扩展，对admin与gateway的配置在ShenYuExtension中的beforeAll中生效。具体的生效逻辑在DockerServiceCompose类中实现。</p><p><img alt="e2e-shenyutest" src="/zh/assets/images/e2e-shenyutest-8ea26c9ea373d2c182be8d19c53cb021.png"></p><p><img alt="e2e-beforeall" src="/zh/assets/images/e2e-beforeall-51fdb9d49dbc3eae99f77268b0e1a5c9.png"></p><p>@ShenYuTest配置项在docker启动前生效，主要通过修改测试模块中resource目录下的yaml文件。目前e2e支持对不同数据同步方式进行测试，其原理就是通过DockerServiceCompose类中的chooseDataSyn方法。在DataSyncHandler中对各种数据同步方式需要修改的内容进行初始化，最后启动container。</p><p><img alt="e2e-docer-service-compose" src="/zh/assets/images/e2e-docer-service-compose-ac329d9290f48407e5c8310031913fb2.png"></p><p><img alt="e2e-datahandle-syn" src="/zh/assets/images/e2e-datahandle-syn-92a7b3dc57bc8b46972128042b8281cb.png"></p><p>当docker启动完后，开始对插件功能进行测试。在PluginsTest类中，有针对测试进行的前置以及后置操作。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @BeforeAll</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static void setup(final AdminClient adminClient, final GatewayClient gatewayClient) throws InterruptedException, JsonProcessingException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        adminClient.login();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Thread.sleep(10000);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorDTO&gt; selectorDTOList = adminClient.listAllSelectors();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;MetaDataDTO&gt; metaDataDTOList = adminClient.listAllMetaData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleDTO&gt; ruleDTOList = adminClient.listAllRules();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(2, selectorDTOList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(13, metaDataDTOList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(14, ruleDTOList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (SelectorDTO selectorDTO : selectorDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (selectorDTO.getHandle() != null &amp;&amp; !&quot;&quot;.equals(selectorDTO.getHandle())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SpringCloudPluginCases.verifierUri(selectorDTO.getHandle());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;MetaData&gt; metaDataCacheList = gatewayClient.getMetaDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorCacheData&gt; selectorCacheList = gatewayClient.getSelectorCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleCacheData&gt; ruleCacheList = gatewayClient.getRuleCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(2, selectorCacheList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(13, metaDataCacheList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(14, ruleCacheList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        MultiValueMap&lt;String, String&gt; formData = new LinkedMultiValueMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        formData.add(&quot;id&quot;, &quot;8&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        formData.add(&quot;name&quot;, &quot;springCloud&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        formData.add(&quot;enabled&quot;, &quot;true&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        formData.add(&quot;role&quot;, &quot;Proxy&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        formData.add(&quot;sort&quot;, &quot;200&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        adminClient.changePluginStatus(&quot;8&quot;, formData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String id = &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (SelectorDTO selectorDTO : selectorDTOList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!&quot;&quot;.equals(selectorDTO.getHandle())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                id = selectorDTO.getId();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        adminClient.deleteSelectors(id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDTOList = adminClient.listAllSelectors();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Assertions.assertEquals(1, selectorDTOList.size());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>以springcloud插件为例，首先需要测试注册中心以及数据同步能否正常工作，接着启动插件并删除已存在的选择器。测试数据是否成功注册进注册中心，可以调用admin客户端的接口进行测试，测试数据同步是否成功，可以获取gateway的缓存进行测试。</p><p>接着运行case文件中的测试用例，通过@ShenYuScenario获取用例。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @ShenYuScenario(provider = SpringCloudPluginCases.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void testSpringCloud(GatewayClient gateway, CaseSpec spec) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        spec.getVerifiers().forEach(verifier -&gt; verifier.verify(gateway.getHttpRequesterSupplier().get()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>针对不同的插件，我们可以构建Case类，存放要测试的规则。所有的测试规则存放进list中，按顺序进行测试。beforeEachSpec中进行构建选择器与规则，caseSpec存放测试实体，如果符合uri规则的应存在，否则不存在。我们需要模拟用户对选择器和规则进行新增，因为各个插件的选择器的handler规则不一定相同，所以我们需要根据插件需求去编写其handle类。并通过请求验证其符合规则。具体测试用例主要分为两大类，一类是对uri规则进行匹配，比如euqal、path_pattern、start_with、end_with，一类是请求类型，比如get、put、post、delete。</p><p>当八种匹配情况都测试通过后，可以判断该插件功能正常，我们在测试结束后需要恢复环境，将所有的选择器删除，将该插件设置为不可用，最后关闭所有容器。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public List&lt;ScenarioSpec&gt; get() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Lists.newArrayList(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithUriEquals(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithUriPathPattern(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithUriStartWith(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithEndWith(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithMethodGet(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithMethodPost(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithMethodPut(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                testWithMethodDelete()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        );</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private ShenYuScenarioSpec testWithUriEquals() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenYuScenarioSpec.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .name(&quot;single-spring-cloud uri =]&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .beforeEachSpec(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ShenYuBeforeEachSpec.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .addSelectorAndRule(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        newSelectorBuilder(&quot;selector&quot;, Plugin.SPRING_CLOUD)                                               .handle(SpringCloudSelectorHandle.builder().serviceId(&quot;springCloud-test&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                        .gray(true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                        .divideUpstreams(DIVIDE_UPSTREAMS)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                        .build())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .conditionList(newConditions(Condition.ParamType.URI, Condition.Operator.EQUAL, TEST))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .build(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                        newRuleBuilder(&quot;rule&quot;)                               .handle(SpringCloudRuleHandle.builder().loadBalance(&quot;hash&quot;).timeout(3000).build())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .conditionList(newConditions(Condition.ParamType.URI, Condition.Operator.EQUAL, TEST))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                                .build()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .checker(notExists(TEST))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .waiting(exists(TEST))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .build()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .caseSpec(</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        ShenYuCaseSpec.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .addExists(TEST)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .addNotExists(&quot;/springcloud/te&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .addNotExists(&quot;/put&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .addNotExists(&quot;/get&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                .build()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                )</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .afterEachSpec(ShenYuAfterEachSpec.DEFAULT)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .build();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/e-2-e-test">E2e Test</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-ZooKeeper-Data-Sync">ZooKeeper数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>ZooKeeper</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于zookeeper"></a>1. 关于ZooKeeper<a class="hash-link" href="#1-关于zookeeper" title="Direct link to heading">#</a></h3><p><a href="https://zh.wikipedia.org/wiki/Apache_ZooKeeper" target="_blank" rel="noopener noreferrer"><code>Apache ZooKeeper</code></a>是<code>Apache</code>软件基金会的一个软件项目，它为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。<code>ZooKeeper</code>节点将它们的数据存储于一个分层的名字空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90：</p><p><img src="/zh/assets/images/update-selector-zh-1f49b39fb8e5ce2c26a80018669619ea.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.createSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>updateSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PutMapping(&quot;/{id}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult updateSelector(@PathVariable(&quot;id&quot;) final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置当前选择器数据id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDTO.setId(id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建或更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer updateCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Serrvice</code>类完成数据的持久化操作，即保存数据到数据库，这个比较简单，就不深入追踪了。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会执行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">       private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者；</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>Zookeeper</code>的数据同步源码分析，所以这里以<code>ZookeeperDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过在源码工程中进行全局搜索，可以看到，它的实现是在<code>DataSyncConfiguration</code>类完成的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * zookeeper数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The type Zookeeper listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(prefix = &quot;shenyu.sync.zookeeper&quot;, name = &quot;url&quot;)  // 条件属性，满足才会被加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Import(ZookeeperConfiguration.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class ZookeeperListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Config event listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 创建Zookeeper数据变更监听器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param zkClient the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ZookeeperDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DataChangedListener zookeeperDataChangedListener(final ZkClient zkClient) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ZookeeperDataChangedListener(zkClient);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Zookeeper data init zookeeper data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *  创建 Zookeeper 数据初始化类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param zkClient        the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the zookeeper data init</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ZookeeperDataInit.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ZookeeperDataInit zookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ZookeeperDataInit(zkClient, syncDataService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>ZookeeperListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.zookeeper&quot;, name = &quot;url&quot;)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>zookeeper</code>进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     zookeeper:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          url: localhost:2181</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          sessionTimeout: 5000</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          connectionTimeout: 2000</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@Import(ZookeeperConfiguration.class)</code>：导入另一个类<code>ZookeeperConfiguration</code>；</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">  @EnableConfigurationProperties(ZookeeperProperties.class)  // 启用zk属性配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public class ZookeeperConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * register zkClient in spring ioc.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 向 Spring IOC 容器注册 zkClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param zookeeperProp the zookeeper configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return ZkClient {@linkplain ZkClient}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      @ConditionalOnMissingBean(ZkClient.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      public ZkClient zkClient(final ZookeeperProperties zookeeperProp) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new ZkClient(zookeeperProp.getUrl(), zookeeperProp.getSessionTimeout(), zookeeperProp.getConnectionTimeout()); // 读取zk配置信息，并创建zkClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;shenyu.sync.zookeeper&quot;) // zk属性配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperProperties {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Integer sessionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private Integer connectionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String serializer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当我们主动配置，采用<code>zookeeper</code>进行数据同步时，<code>zookeeperDataChangedListener</code>就会生成。所以在事件处理方法<code>onApplicationEvent()</code>中，就会到相应的<code>listener</code>中。在我们的案例中，是对一条选择器数据进行更新，数据同步采用的是<code>zookeeper</code>，所以，代码会进入到<code>ZookeeperDataChangedListener</code>进行选择器数据变更处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // 在我们的案例中，会进入到ZookeeperDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-zookeeper数据变更监听器"></a>2.4 Zookeeper数据变更监听器<a class="hash-link" href="#24-zookeeper数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>ZookeeperDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，判断操作类型，是刷新同步还是更新或创建同步。根据当前选择器数据信息判断节点是否在<code>zk</code>中。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 使用 zookeeper 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperDataChangedListener implements DataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器信息发生改变</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 刷新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (eventType == DataEventTypeEnum.REFRESH &amp;&amp; !changed.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            deleteZkPathRecursive(selectorParentPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发生变更的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (SelectorData data : changed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 构建选择器数据的真实路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (eventType == DataEventTypeEnum.DELETE) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 删除当前数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                deleteZkPath(selectorRealPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 父节点路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(data.getPluginName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 创建父节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            createZkNode(selectorParentPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入或更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            insertZkNode(selectorRealPath, data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建 zk 节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void createZkNode(final String path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 不存在才创建</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(path)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            zkClient.createPersistent(path, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插入zk节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void insertZkNode(final String path, final Object data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        createZkNode(path);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过 zkClient 写入数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.writeData(path, null == data ? &quot;&quot; : GsonUtils.getInstance().toJson(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>只要将变动的数据正确写入到<code>zk</code>的节点上，<code>admin</code>这边的操作就执行完成了。<code>ShenYu</code>在使用<code>zk</code>进行数据同步时，<code>zk</code>的节点是通过精心设计的。</p><p>在我们当前的案例中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90，就会对图中的特定节点更新。</p><p><img src="/zh/assets/images/zookeeper-node-c7628b680a1f1afa0eada97b66fcd5b1.png"></p><p>我们用时序图将上面的更新流程串联起来。</p><p><img src="/zh/assets/images/zk-sync-sequence-admin-zh-afad1ef642b7130231c2ceacce236b34.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行，使用的数据同步方式也是<code>zookeeper</code>。那么当在<code>admin</code>端更新选择器数据后，并且向<code>zk</code>发送了变更的数据，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-zkclient接收数据"></a>3.1 ZkClient接收数据<a class="hash-link" href="#31-zkclient接收数据" title="Direct link to heading">#</a></h4><ul><li>ZkClient.subscribeDataChanges()</li></ul><p>在网关端有一个<code>ZookeeperSyncDataService</code>类，它通过<code>ZkClient</code>订阅了数据节点，当数据发生变更时，可以感知到。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 使用 zookeeper 缓存数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void subscribeSelectorDataChanges(final String path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       // zkClient订阅数据节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeDataChanges(path, new IZkDataListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataChange(final String dataPath, final Object data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                cacheSelectorData(GsonUtils.getInstance().fromJson(data.toString(), SelectorData.class)); // 节点数据被更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataDeleted(final String dataPath) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                unCacheSelectorData(dataPath);  // 节点数据被删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ZooKeeper</code>的<code>Watch</code>机制，会给订阅的客户端发送节点变更通知。在我们的案例中，更新选择器信息，就会进入到<code>handleDataChange()</code>方法。通过<code>cacheSelectorData()</code>去处理数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-处理数据"></a>3.2 处理数据<a class="hash-link" href="#32-处理数据" title="Direct link to heading">#</a></h4><ul><li>ZookeeperSyncDataService.cacheSelectorData()</li></ul><p>经过判空逻辑之后，缓存选择器数据的操作又交给了<code>PluginDataSubscriber</code>处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private void cacheSelectorData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .ifPresent(data -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSelectorSubscribe(data)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>PluginDataSubscriber</code>是一个接口，它只有一个<code>CommonPluginDataSubscriber</code>实现类，负责处理插件、选择器和规则数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-通用插件数据订阅者"></a>3.3 通用插件数据订阅者<a class="hash-link" href="#33-通用插件数据订阅者" title="Direct link to heading">#</a></h4><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-数据缓存到内存"></a>3.4 数据缓存到内存<a class="hash-link" href="#34-数据缓存到内存" title="Direct link to heading">#</a></h4><p>那么更新一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增更新一条选择器数据，就将<code>zookeeper</code>数据同步的流程分析清楚了。</p><p>我们还是通过时序图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/zk-sync-sequence-gateway-zh-0494aedc4de3f64c781fe8bb6c4b69bc.png"></p><p>数据同步的流程已经分析完了，为了不让同步流程被打断，在分析过程中就忽略了其他逻辑。我们还需要分析<code>Admin</code>同步数据初始化和网关同步操作初始化的流程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-admin同步数据初始化"></a>4. Admin同步数据初始化<a class="hash-link" href="#4-admin同步数据初始化" title="Direct link to heading">#</a></h3><p>当<code>admin</code>启动后，会将当前的数据信息全量同步到<code>zk</code>中，实现逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Zookeeper 数据初始化</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperDataInit implements CommandLineRunner {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ZkClient zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final SyncDataService syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Zookeeper data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param zkClient        the zk client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ZookeeperDataInit(final ZkClient zkClient, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.zkClient = zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.syncDataService = syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run(final String... args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String pluginPath = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String authPath = DefaultPathConstants.APP_AUTH_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String metaDataPath = DefaultPathConstants.META_DATA;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断zk中是否存在数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(pluginPath) &amp;&amp; !zkClient.exists(authPath) &amp;&amp; !zkClient.exists(metaDataPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            syncDataService.syncAll(DataEventTypeEnum.REFRESH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>判断<code>zk</code>中是否存在数据，如果不存在，则进行同步。</p><p><code>ZookeeperDataInit</code>实现了<code>CommandLineRunner</code>接口。它是<code>springboot</code>提供的接口，会在所有 <code>Spring Beans</code>初始化之后执行<code>run()</code>方法，常用于项目中初始化的操作。</p><ul><li>SyncDataService.syncAll()</li></ul><p>从数据库查询数据，然后进行全量数据同步，所有的认证信息、插件信息、选择器信息、规则信息和元数据信息。主要是通过<code>eventPublisher</code>发布同步事件。这里就跟前面提到的同步逻辑就又联系起来了，<code>eventPublisher</code>通过<code>publishEvent()</code>发布完事件后，有<code>ApplicationListener</code>执行事件变更操作，在<code>ShenYu</code>中就是前面提到的<code>DataChangedEventDispatcher</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SyncDataServiceImpl implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 事件发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     /***</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean syncAll(final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        appAuthService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;PluginData&gt; pluginDataList = pluginService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorData&gt; selectorDataList = selectorService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleData&gt; ruleDataList = ruleService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步元数据信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        metaDataService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-网关同步操作初始化"></a>5. 网关同步操作初始化<a class="hash-link" href="#5-网关同步操作初始化" title="Direct link to heading">#</a></h3><p>网关这边的数据同步初始化操作主要是订阅<code>zk</code>中的节点，当有数据变更时，收到变更数据。这依赖于<code>ZooKeeper</code>的<code>Watch</code>机制。在<code>ShenYu</code>中，负责<code>zk</code>数据同步的是<code>ZookeeperSyncDataService</code>，也在前面提到过。</p><p><code>ZookeeperSyncDataService</code>的功能逻辑是在实例化的过程中完成的：对<code>zk</code>中的<code>shenyu</code>数据同步节点完成订阅。这里的订阅分两类，一类是已经存在的节点上面数据发生更新，这通过<code>zkClient.subscribeDataChanges()</code>方法实现；另一类是当前节点下有新增或删除节点，即子节点发生变化，这通过<code>zkClient.subscribeChildChanges()</code>方法实现。</p><p><code>ZookeeperSyncDataService</code>的代码有点多，这里我们以插件数据的读取和订阅进行追踪，其他类型的数据操作原理是一样的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> *  zookeeper 数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class ZookeeperSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 在实例化的时候，完成从zk中读取数据的操作，并订阅节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ZookeeperSyncDataService( /*省略构造参数参数*/ ) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.zkClient = zkClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.pluginDataSubscriber = pluginDataSubscriber;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.metaDataSubscribers = metaDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.authDataSubscribers = authDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watchAppAuth();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watchMetaData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherData() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插件节点路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 所有插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;String&gt; pluginZKs = zkClientGetChildren(pluginParent);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String pluginName : pluginZKs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 订阅当前所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            watcherAll(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅子节点（新增或删除一个插件）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeChildChanges(pluginParent, (parentPath, currentChildren) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (CollectionUtils.isNotEmpty(currentChildren)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                for (String pluginName : currentChildren) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 需要订阅子节点的所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    watcherAll(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherAll(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherPlugin(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherSelector(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherRule(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void watcherPlugin(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 当前插件路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 是否存在，不存在就创建</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!zkClient.exists(pluginPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            zkClient.createPersistent(pluginPath, true);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 读取zk上当前节点数据，并反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginData pluginData = null == zkClient.readData(pluginPath) ? null</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                : GsonUtils.getInstance().fromJson((String) zkClient.readData(pluginPath), PluginData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 缓存到网关内存中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribePluginDataChanges(pluginPath, pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   private void cachePluginData(final PluginData pluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">       // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 订阅数据变更：更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        zkClient.subscribeDataChanges(pluginPath, new IZkDataListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataChange(final String dataPath, final Object data) {  // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                 // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void handleDataDeleted(final String dataPath) {   // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                  // 省略实现逻辑，其实就是 CommonPluginDataSubscriber 中的操作，跟前面都能联系起来</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}    </span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面的源代码中都给出了注释，相信大家可以看明白。订阅插件数据的主要逻辑如下：</p><blockquote><ol><li>构造当前插件路径</li><li>路径是否存在，不存在就创建</li><li>读取zk上当前节点数据，并反序列化</li><li>插件数据缓存到网关内存中</li><li>订阅插件节点</li></ol></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="6-总结"></a>6. 总结<a class="hash-link" href="#6-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>zookeeper</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li>基于<code>zookeeper</code>的数据同步，主要是通过<code>watch</code>机制实现；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/zookeeper">zookeeper</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-WebSocket-Data-Sync">WebSocket数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/midnight2104" target="_blank" rel="noopener noreferrer">midnight2104</a></div><small class="avatar__subtitle">Apache ShenYu Committer</small></div></div></header><div class="markdown"><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>WebSocket</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于websocket通信"></a>1. 关于WebSocket通信<a class="hash-link" href="#1-关于websocket通信" title="Direct link to heading">#</a></h3><p><code>WebSocket</code>协议诞生于<code>2008</code>年，在<code>2011</code>年成为国际标准。它可以双向通信，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息。<code>WebSocket</code>协议建立在 <code>TCP</code> 协议之上，属于应用层，性能开销小，通信高效，协议标识符是<code>ws</code>。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，新增一条选择器数据：</p><p><img src="/zh/assets/images/add-selector-93ff1008c1b0b4627dd3329abc92a7bd.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.createSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>createSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PostMapping(&quot;&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult createSelector(@Valid @RequestBody final SelectorDTO selectorDTO) { // @Valid 数校验</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 添加或更新数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer createCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.CREATE_SUCCESS, createCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Service</code>类完成数据的持久化操作，即保存数据到数据库，这个大家应该很熟悉了，就不展开。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会进行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">       private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者。</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>websocket</code>的数据同步源码分析，所以这里以<code>WebsocketDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过在源码工程中进行全局搜索，可以看到，它的实现是在<code>DataSyncConfiguration</code>类完成的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain"> /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * websocket数据同步（默认策略）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The WebsocketListener(default strategy).</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(name = &quot;shenyu.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @EnableConfigurationProperties(WebsocketSyncProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class WebsocketListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Config event listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * 配置websocket数据变更监听器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(WebsocketDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DataChangedListener websocketDataChangedListener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new WebsocketDataChangedListener();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Websocket collector.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Websocket处理类：建立连接，发送消息，关闭连接等操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the websocket collector</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(WebsocketCollector.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public WebsocketCollector websocketCollector() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new WebsocketCollector();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Server endpoint exporter </span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the server endpoint exporter</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(ServerEndpointExporter.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public ServerEndpointExporter serverEndpointExporter() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new ServerEndpointExporter();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>WebsocketListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(name = &quot;shenyu.sync.websocket.enabled&quot;, havingValue = &quot;true&quot;, matchIfMissing = true)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>websocket</code>进行数据同步。不过，这里需要注意下<code>matchIfMissing = true</code>这个属性，它表示，如果你没有如下的配置，该配置类也会生效。基于<code>websocket</code>的数据同步时官方推荐的方式，也是默认采用的方式。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    websocket:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      enabled: true</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@EnableConfigurationProperties</code>：启用配置属性；</p></li></ul><p>当我们主动配置，采用<code>websocket</code>进行数据同步时，<code>WebsocketDataChangedListener</code>就会生成。所以在事件处理方法<code>onApplicationEvent()</code>中，就会到相应的<code>listener</code>中。在我们的案例中，是新增加了一条选择器数据，数据通过采用的是<code>websocket</code>，所以，代码会进入到<code>WebsocketDataChangedListener</code>进行选择器数据变更处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // WebsocketDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-websocket数据变更监听器"></a>2.4 Websocket数据变更监听器<a class="hash-link" href="#24-websocket数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>WebsocketDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，将数据进行了封装，转成<code>WebsocketData</code>，然后通过<code>WebsocketCollector.send()</code>发送数据。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器数据有更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; selectorDataList, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构造 WebsocketData 数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData&lt;SelectorData&gt; websocketData =</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                new WebsocketData&lt;&gt;(ConfigGroupEnum.SELECTOR.name(), eventType.name(), selectorDataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 通过websocket发送数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketCollector.send(GsonUtils.getInstance().toJson(websocketData), eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="25-websocket发送数据"></a>2.5 Websocket发送数据<a class="hash-link" href="#25-websocket发送数据" title="Direct link to heading">#</a></h4><ul><li>WebsocketCollector.send()</li></ul><p>在<code>send()</code>方法中，判断了一下同步的类型，根据不同的类型，进行处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ServerEndpoint(value = &quot;/websocket&quot;, configurator = WebsocketConfigurator.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketCollector {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Send.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param message the message</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type    the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static void send(final String message, final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotBlank(message)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 如果是MYSELF（第一次的全量同步）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (DataEventTypeEnum.MYSELF == type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 从threadlocal中获取session</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (session != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 向该session发送全量数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    sendMessageBySession(session, message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 后续的增量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 向所有的session中同步变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SESSION_SET.forEach(session -&gt; sendMessageBySession(session, message));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static void sendMessageBySession(final Session session, final String message) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 通过websocket的session把消息发送出去</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            session.getBasicRemote().sendText(message);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (IOException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.error(&quot;websocket send result is exception: &quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>我们给的案例是一个新增操作 ，是一个增量同步，所以会走</p><p><code>SESSION_SET.forEach(session -&gt; sendMessageBySession(session, message));</code></p><p>这个逻辑。</p><p>再通过</p><p><code>session.getBasicRemote().sendText(message);</code></p><p>将数据发送了出去。</p><p>至此，当<code>admin</code>端发生数据变更时，就将变更的数据以增量形式通过<code>WebSocket</code>发给了网关。</p><p>分析到这里，不知道大家有没有疑问呢？比如<code>session</code>是怎么来的？网关如何和<code>admin</code>建立连接的？</p><p>不要着急，我们接下来就进行网关端的同步分析。</p><p>不过，在继续源码分析前，我们用一张图将上面的分析过程串联起来。</p><p><img src="/zh/assets/images/websocket-data-sync-admin-56f75ad149ca3cd1ec07fd24c6194c5b.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行了，使用的数据同步方式也是<code>websocket</code>。那么当在<code>admin</code>端新增一条选择器数据后，并且通过<code>WebSocket</code>发送到网关，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-websocketclient接收数据"></a>3.1 WebsocketClient接收数据<a class="hash-link" href="#31-websocketclient接收数据" title="Direct link to heading">#</a></h4><ul><li>ShenyuWebsocketClient.onMessage()</li></ul><p>在网关端有一个<code>ShenyuWebsocketClient</code>类，它继承了<code>WebSocketClient</code>，可以和<code>WebSocket</code>建立连接并通信。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当在<code>admin</code>端通过<code>websocket</code>发送数据后，<code>ShenyuWebsocketClient</code>就可以通过<code>onMessage()</code>接收到数据，然后就可以自己进行处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 接受到消息后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onMessage(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理接收到的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleResult(result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void handleResult(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种数据类型，插件、选择器、规则...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种操作类型，更新、删除...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String eventType = websocketData.getEventType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = GsonUtils.getInstance().toJson(websocketData.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        websocketDataHandler.executor(groupEnum, json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>接收到数据后，首先进行了反序列化操作，读取数据类型和操作类型，紧接着，就交给<code>websocketDataHandler.executor()</code>进行处理。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-执行websocket事件处理器"></a>3.2 执行Websocket事件处理器<a class="hash-link" href="#32-执行websocket事件处理器" title="Direct link to heading">#</a></h4><ul><li>WebsocketDataHandler.executor()</li></ul><p>通过工厂模式创建了<code>Websocket</code>数据处理器，每种数据类型，都提供了一个处理器：</p><blockquote><p>插件 --&gt; 插件数据处理器;</p><p>选择器 --&gt; 选择器数据处理器；</p><p>规则 --&gt; 规则数据处理器；</p><p>认证信息 --&gt; 认证数据处理器；</p><p>元数据 --&gt; 元数据处理器。</p></blockquote><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过工厂模式创建 Websocket数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Websocket cache handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketDataHandler {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final EnumMap&lt;ConfigGroupEnum, DataHandler&gt; ENUM_MAP = new EnumMap&lt;&gt;(ConfigGroupEnum.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Websocket data handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 每种数据类型，提供一个处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers  the meta data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers  the auth data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketDataHandler(final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 插件 --&gt; 插件数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.PLUGIN, new PluginDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 选择器 --&gt; 选择器数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.SELECTOR, new SelectorDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 规则 --&gt; 规则数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.RULE, new RuleDataHandler(pluginDataSubscriber));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 认证信息 --&gt; 认证数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.APP_AUTH, new AuthDataHandler(authDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 元数据 --&gt; 元数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.put(ConfigGroupEnum.META_DATA, new MetaDataHandler(metaDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Executor.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type      the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param json      the json</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param eventType the event type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void executor(final ConfigGroupEnum type, final String json, final String eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 根据数据类型，找到对应的数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ENUM_MAP.get(type).handle(json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>不同的数据类型，有不同的数据处理方式，所以有不同的实现类。但是它们之间也有相同的处理逻辑，所以可以通过模板方法设计模式来实现。相同的逻辑放在抽象类中的<code>handle()</code>方法中，不同逻辑就交给各自的实现类。</p><p><img src="/zh/assets/images/data-handler-313ae788eadfdabf405cdc55c74dbb21.png"></p><p>我们的案例是新增了一条选择器数据，所以会交给<code>SelectorDataHandler</code>（ 选择器 --&gt; 选择器数据处理器）进行数据处理。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-判断事件类型"></a>3.3 判断事件类型<a class="hash-link" href="#33-判断事件类型" title="Direct link to heading">#</a></h4><ul><li>AbstractDataHandler.handle()</li></ul><p>实现数据变更的通用逻辑处理：根据不同的操作类型调用不同方法。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public abstract class AbstractDataHandler&lt;T&gt; implements DataHandler {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Convert list.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param json the json</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract List&lt;T&gt; convert(String json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do refresh.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doRefresh(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do update.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doUpdate(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Do delete.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 不同的逻辑由各自实现类去实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param dataList the data list</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected abstract void doDelete(List&lt;T&gt; dataList);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 通用逻辑，抽象类实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void handle(final String json, final String eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;T&gt; dataList = convert(json);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (CollectionUtils.isNotEmpty(dataList)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            DataEventTypeEnum eventTypeEnum = DataEventTypeEnum.acquireByName(eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (eventTypeEnum) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case REFRESH:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case MYSELF:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doRefresh(dataList);  //刷新数据，全量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case UPDATE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case CREATE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doUpdate(dataList); // 更新或创建数据，增量同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case DELETE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    doDelete(dataList);  // 删除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>新增一条选择器数据，是新增操作，通过<code>switch-case</code>进入到<code>doUpdate()</code>方法中。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-进入具体的数据处理器"></a>3.4 进入具体的数据处理器<a class="hash-link" href="#34-进入具体的数据处理器" title="Direct link to heading">#</a></h4><ul><li>SelectorDataHandler.doUpdate()</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 选择器数据处理器</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Selector data handler.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorDataHandler extends AbstractDataHandler&lt;SelectorData&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final PluginDataSubscriber pluginDataSubscriber;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    protected void doUpdate(final List&lt;SelectorData&gt; dataList) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        dataList.forEach(pluginDataSubscriber::onSelectorSubscribe);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>遍历数据，进入<code>onSelectorSubscribe()</code>方法。</p><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理 </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>那么新增一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增一条选择器数据，就将<code>websocket</code>数据同步的流程分析清楚了。</p><p>我们还是用下面的一张图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/websocket-data-sync-gateway-181e89c69dc9b9d2569e858eb82431bf.png"></p><p>数据同步的流程已经分析完了，但是还有一些问题没有分析到，就是网关是如何跟<code>admin</code>建立连接的？</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-网关和admin建立websocket连接"></a>4. 网关和admin建立websocket连接<a class="hash-link" href="#4-网关和admin建立websocket连接" title="Direct link to heading">#</a></h3><ul><li>websocket配置</li></ul><p>在网关的配置文件中有如下配置，并且引入了相关依赖，就会启动<code>websocket</code>相关服务。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI yaml"><pre tabindex="0" class="prism-code language-yaml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token key atrule" style="color:#00a4db">shenyu</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">file</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">cross</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">enabled</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> </span><span class="token boolean important" style="color:#36acaa">true</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">dubbo</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">parameter</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> multi</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token key atrule" style="color:#00a4db">sync</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token key atrule" style="color:#00a4db">websocket</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic"># 使用websocket进行数据同步</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">urls</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ws</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//localhost</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">9095/websocket   </span><span class="token comment" style="color:#999988;font-style:italic"># admin端的websocket地址</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token key atrule" style="color:#00a4db">allowOrigin</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"> ws</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain">//localhost</span><span class="token punctuation" style="color:#393A34">:</span><span class="token number" style="color:#36acaa">9195</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在网关中引入<code>websocket</code>的依赖。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI xml"><pre tabindex="0" class="prism-code language-xml codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic">&lt;!--shenyu data sync start use websocket--&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">org.apache.shenyu</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">groupId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">shenyu-spring-boot-starter-sync-data-websocket</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">artifactId</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token tag punctuation" style="color:#393A34">&lt;</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain">${project.version}</span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">version</span><span class="token tag punctuation" style="color:#393A34">&gt;</span><span class="token plain"></span></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token tag punctuation" style="color:#393A34">&lt;/</span><span class="token tag" style="color:#00009f">dependency</span><span class="token tag punctuation" style="color:#393A34">&gt;</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>Websocket数据同步配置</li></ul><p>通过<code>springboot</code>的条件装配，创建相关的<code>bean</code>。在网关启动的时候，如果我们配置了<code>shenyu.sync.websocket.urls</code>，那么<code>Websocket</code>数据同步配置就会被加载。这里通过<code>spring boot starter</code>完成依赖的加载。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket数据同步配置</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot实现条件注入</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket sync data configuration for spring boot.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnClass(WebsocketSyncDataService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(prefix = &quot;shenyu.sync.websocket&quot;, name = &quot;urls&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketSyncDataConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Websocket sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param websocketConfig   the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginSubscriber the plugin subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaSubscribers   the meta subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authSubscribers   the auth subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 创建websocketSyncDataService</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SyncDataService websocketSyncDataService(final ObjectProvider&lt;WebsocketConfig&gt; websocketConfig, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        log.info(&quot;you use websocket sync shenyu data.......&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new WebsocketSyncDataService(websocketConfig.getIfAvailable(WebsocketConfig::new), pluginSubscriber.getIfAvailable(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Config websocket config.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.sync.websocket&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketConfig websocketConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new WebsocketConfig();  // 创建WebsocketConfig</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在项目的<code>resources/META-INF</code>目录先新建<code>spring.factories</code>文件，在文件中指明配置类。</p><p><img src="/zh/assets/images/websocket-springboot-starter-2cfd149ba2fb69ab514241e061fc22c9.png"></p><ul><li>Websocket数据同步服务</li></ul><p>在<code>WebsocketSyncDataService</code>中做了如下几件事情：</p><ul><li>读取配置中的<code>urls</code>，这个表示<code>admin</code>端的同步地址，有多个的话，使用&quot;,&quot;分割；</li><li>创建调度线程池，一个<code>admin</code>分配一个，用于执行定时任务；</li><li>创建<code>ShenyuWebsocketClient</code>，一个<code>admin</code>分配一个，用于和<code>admin</code>建立<code>websocket</code>通信；</li><li>开始和<code>admin</code>端的<code>websocket</code> 建立连接；</li><li>执行定时任务，每隔10秒执行一次。主要作用是判断<code>websocket</code>连接是否已经断开，如果已经断开，则尝试重连。如果没有断开，就进行 <code>ping-pong</code> 检测。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Websocket sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class WebsocketSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final List&lt;WebSocketClient&gt; clients = new ArrayList&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ScheduledThreadPoolExecutor executor;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Websocket sync cache.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建Websocket数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param websocketConfig      the websocket config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers  the meta data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers  the auth data subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public WebsocketSyncDataService(final WebsocketConfig websocketConfig,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final List&lt;MetaDataSubscriber&gt; metaDataSubscribers,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                    final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // admin端的同步地址，有多个的话，使用&quot;,&quot;分割</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String[] urls = StringUtils.split(websocketConfig.getUrls(), &quot;,&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建调度线程池，一个admin分配一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        executor = new ScheduledThreadPoolExecutor(urls.length, ShenyuThreadFactory.create(&quot;websocket-connect&quot;, true));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (String url : urls) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                //创建WebsocketClient，一个admin分配一个</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                clients.add(new ShenyuWebsocketClient(new URI(url), Objects.requireNonNull(pluginDataSubscriber), metaDataSubscribers, authDataSubscribers));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } catch (URISyntaxException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                log.error(&quot;websocket url({}) is error&quot;, url, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            for (WebSocketClient client : clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 和websocket server建立连接</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                boolean success = client.connectBlocking(3000, TimeUnit.MILLISECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (success) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.info(&quot;websocket connection is successful.....&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    log.error(&quot;websocket connection is error.....&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 执行定时任务，每隔10秒执行一次</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 主要作用是判断websocket连接是否已经断开，如果已经断开，则尝试重连。</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 如果没有断开，就进行 ping-pong 检测</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                executor.scheduleAtFixedRate(() -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        if (client.isClosed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            boolean reconnectSuccess = client.reconnectBlocking();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            if (reconnectSuccess) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                log.info(&quot;websocket reconnect server[{}] is successful.....&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                log.error(&quot;websocket reconnection server[{}] is error.....&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            client.sendPing();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            log.debug(&quot;websocket send to [{}] ping message successful&quot;, client.getURI().toString());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        log.error(&quot;websocket connect is error :{}&quot;, e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }, 10, 10, TimeUnit.SECONDS);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            /* client.setProxy(new Proxy(Proxy.Type.HTTP, new InetSocketAddress(&quot;proxyaddress&quot;, 80)));*/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InterruptedException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            log.info(&quot;websocket connection...exception....&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void close() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭 websocket client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (WebSocketClient client : clients) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (!client.isClosed()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                client.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 关闭线程池</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.nonNull(executor)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            executor.shutdown();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>ShenyuWebsocketClient</li></ul><p>在<code>ShenYu</code>中创建的<code>WebSocket</code>客户端，用于和<code>admin</code>端通信。第一次成功建立连接后，同步全量数据，后续进行增量同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 在ShenYu中自定义的WebSocket客户端</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type shenyu websocket client.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public final class ShenyuWebsocketClient extends WebSocketClient {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private volatile boolean alreadySync = Boolean.FALSE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final WebsocketDataHandler websocketDataHandler;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new shenyu websocket client.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建ShenyuWebsocketClient</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param serverUri             the server uri  服务端uri</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginDataSubscriber the plugin data subscriber 插件数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaDataSubscribers   the meta data subscribers 元数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authDataSubscribers   the auth data subscribers 认证数据订阅器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuWebsocketClient(final URI serverUri, final PluginDataSubscriber pluginDataSubscriber,final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(serverUri);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.websocketDataHandler = new WebsocketDataHandler(pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 成功建立连接后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onOpen(final ServerHandshake serverHandshake) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 防止重新建立连接时，再次执行，所以用alreadySync进行判断</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (!alreadySync) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 同步所有数据，MYSELF 类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            send(DataEventTypeEnum.MYSELF.name());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            alreadySync = true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 接收到消息后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onMessage(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理接收到的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        handleResult(result);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 关闭后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onClose(final int i, final String s, final boolean b) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 失败后执行</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onError(final Exception e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.close();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;ALL&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void handleResult(final String result) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 数据反序列化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        WebsocketData websocketData = GsonUtils.getInstance().fromJson(result, WebsocketData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种数据类型，插件、选择器、规则...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ConfigGroupEnum groupEnum = ConfigGroupEnum.acquireByName(websocketData.getGroupType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 哪种操作类型，更新、删除...</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String eventType = websocketData.getEventType();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String json = GsonUtils.getInstance().toJson(websocketData.getData());</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 处理数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        websocketDataHandler.executor(groupEnum, json, eventType);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-总结"></a>5. 总结<a class="hash-link" href="#5-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>websocket</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li><code>websocket</code>支持双向通信，性能好，推荐使用；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用工厂模式创建 <code>WebsocketDataHandler</code>，实现不同数据类型的处理；</li><li>使用模板方法设计模式实现<code>AbstractDataHandler</code>，处理通用的操作类型；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/websocket">websocket</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-Nacos-Data-Sync">Nacos数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.668Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/4zd" target="_blank" rel="noopener noreferrer">4zd</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>Nacos</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于nacos"></a>1. 关于Nacos<a class="hash-link" href="#1-关于nacos" title="Direct link to heading">#</a></h3><p><a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener noreferrer"><code>Nacos</code></a> 平台用于动态服务发现，以及配置和服务管理。 <code>Shenyu</code>网关可选择使用<code>Nacos</code>进行数据同步。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90：</p><p><img src="/zh/assets/images/update-selector-zh-1f49b39fb8e5ce2c26a80018669619ea.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.updateSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>updateSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PutMapping(&quot;/{id}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult updateSelector(@PathVariable(&quot;id&quot;) final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置当前选择器数据id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDTO.setId(id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建或更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer updateCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Service</code>类完成数据的持久化操作，即保存数据到数据库，这个比较简单，就不深入追踪了。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会执行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">     private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者；</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>Nacos</code>的数据同步源码分析，所以这里以<code>NacosDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过查看对<code>NacosDataChangedListener</code>类的调用，可以发现，它是在<code>DataSyncConfiguration</code>类进行配置的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The type Nacos listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnProperty(prefix = &quot;shenyu.sync.nacos&quot;, name = &quot;url&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Import(NacosConfiguration.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static class NacosListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Data changed listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param configService the config service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(NacosDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public DataChangedListener nacosDataChangedListener(final ConfigService configService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NacosDataChangedListener(configService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Nacos data init zookeeper data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param configService the config service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the nacos data init</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @ConditionalOnMissingBean(NacosDataInit.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public NacosDataInit nacosDataInit(final ConfigService configService, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return new NacosDataInit(configService, syncDataService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>NacosListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.nacos&quot;, name = &quot;url&quot;)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>nacos</code>进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     nacos:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          url: localhost:8848</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@Import(NacosConfiguration.class)</code>：导入另一个配置类<code>NacosConfiguration</code>，<code>NacosConfiguration</code>提供了一个方法<code>ConfigService nacosConfigService(final NacosProperties nacosProp)</code>，将Nacos属性转换为<code>ConfigService</code>类型的bean，而Nacos属性是通过<code>@EnableConfigurationProperties(NacosProperties.class)</code> 导入的。我们先看ConfigService类型的bean定义。再分析属性配置类和对应的属性配置文件。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Nacos configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@EnableConfigurationProperties(NacosProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * register configService in spring ioc.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param nacosProp the nacos configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return ConfigService {@linkplain ConfigService}</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception the exception</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean(ConfigService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConfigService nacosConfigService(final NacosProperties nacosProp) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties properties = new Properties();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nacosProp.getAcm() != null &amp;&amp; nacosProp.getAcm().isEnabled()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Use aliyun ACM service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.ENDPOINT, nacosProp.getAcm().getEndpoint());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getAcm().getNamespace());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // Use subaccount ACM administrative authority</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.ACCESS_KEY, nacosProp.getAcm().getAccessKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.SECRET_KEY, nacosProp.getAcm().getSecretKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.SERVER_ADDR, nacosProp.getUrl());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isNotBlank(nacosProp.getNamespace())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.NAMESPACE, nacosProp.getNamespace());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isNotBlank(nacosProp.getUsername())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.USERNAME, nacosProp.getUsername());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isNotBlank(nacosProp.getPassword())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.PASSWORD, nacosProp.getPassword());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return NacosFactory.createConfigService(properties);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个方法主要分成两步，第一步根据是否使用了aliyun的ACM服务，从NacosProperties中获取不同的nacos路径和鉴权信息，第二步根据获取到的这些属性，使用Nacos官方的工厂方法，使用反射的方式，创建configService。</p><p>接下来，让我们分析一下Nacos的属性配置和对应的配置文件。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Nacos config.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;shenyu.sync.nacos&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosProperties {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String username;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String password;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private NacosACMProperties acm;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets the value of url.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value of url</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getUrl() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sets the url.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param url url</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setUrl(final String url) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.url = url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets the value of namespace.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value of namespace</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getNamespace() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sets the namespace.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param namespace namespace</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setNamespace(final String namespace) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.namespace = namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets the value of username.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value of username</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getUsername() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return username;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sets the username.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param username username</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setUsername(final String username) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.username = username;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets the value of password.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value of password</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getPassword() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return password;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sets the password.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param password password</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setPassword(final String password) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.password = password;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets the value of acm.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the value of acm</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NacosACMProperties getAcm() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return acm;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Sets the acm.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param acm acm</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void setAcm(final NacosACMProperties acm) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.acm = acm;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class NacosACMProperties {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private boolean enabled;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String endpoint;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String accessKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String secretKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Gets the value of enabled.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the value of enabled</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public boolean isEnabled() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return enabled;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sets the enabled.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param enabled enabled</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setEnabled(final boolean enabled) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.enabled = enabled;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Gets the value of endpoint.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the value of endpoint</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getEndpoint() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return endpoint;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sets the endpoint.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param endpoint endpoint</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setEndpoint(final String endpoint) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.endpoint = endpoint;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Gets the value of namespace.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the value of namespace</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getNamespace() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sets the namespace.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param namespace namespace</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setNamespace(final String namespace) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.namespace = namespace;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Gets the value of accessKey.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the value of accessKey</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getAccessKey() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return accessKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sets the accessKey.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param accessKey accessKey</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setAccessKey(final String accessKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.accessKey = accessKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Gets the value of secretKey.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @return the value of secretKey</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public String getSecretKey() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return secretKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * Sets the secretKey.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         * @param secretKey secretKey</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        public void setSecretKey(final String secretKey) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.secretKey = secretKey;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当我们在配置文件中配置了<code>shenyu.sync.nacos.url</code>属性时，将采用<code>nacos</code>进行数据同步，此时配置类<code>NacosListener</code>会生效，并生成<code>NacosDataChangedListener</code>和<code>NacosDataInit</code>类型的bean。</p><ul><li>生成<code>NacosDataChangedListener</code>类型的bean，<code>nacosDataChangedListener</code>，这个bean将<code>ConfigService</code>类型的bean作为成员变量，<code>ConfigService</code>是nacos官方提供的api，当<code>nacosDataChangedListener</code>监听到事件时，进行回调操作，可以通过该api直接与nacos服务器交互，修改配置。</li><li>生成<code>NacosDataInit</code>类型的bean，<code>nacosDataInit</code>，这个bean将bean<code>configService</code>和bean<code>syncDataService</code>作为成员变量，调用<code>Nacos</code>的api <code>configService</code>判断配置是否未初始化，未初始化则调用<code>syncDataService</code>进行刷新操作，将在下文详述。
根据上文所述，在事件处理方法<code>onApplicationEvent()</code>中，会触发相应的<code>listener</code>的操作。在我们的案例中，是对一条选择器数据进行更新，数据同步采用的是<code>nacos</code>，所以，代码会进入到<code>NacosDataChangedListener</code>进行选择器数据变更处理。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    //DataChangedEventDispatcher.java</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // 在我们的案例中，会进入到NacosDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-nacos数据变更监听器"></a>2.4 Nacos数据变更监听器<a class="hash-link" href="#24-nacos数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>NacosDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，判断操作类型，是刷新同步还是更新或创建同步。根据当前选择器数据信息判断节点是否在<code>nacos</code>中。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Use nacos to push data changes.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosDataChangedListener implements DataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器信息发生改变</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateSelectorMap(getConfig(NacosPathConstants.SELECTOR_DATA_ID));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        switch (eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case DELETE:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                changed.forEach(selector -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;SelectorData&gt; ls = SELECTOR_MAP</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .getOrDefault(selector.getPluginName(), new ArrayList&lt;&gt;())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .stream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .filter(s -&gt; !s.getId().equals(selector.getId()))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .sorted(SELECTOR_DATA_COMPARATOR)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SELECTOR_MAP.put(selector.getPluginName(), ls);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case REFRESH:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            case MYSELF:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SELECTOR_MAP.keySet().removeAll(SELECTOR_MAP.keySet());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                changed.forEach(selector -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;SelectorData&gt; ls = SELECTOR_MAP</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .getOrDefault(selector.getPluginName(), new ArrayList&lt;&gt;())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .stream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .sorted(SELECTOR_DATA_COMPARATOR)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ls.add(selector);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SELECTOR_MAP.put(selector.getPluginName(), ls);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            default:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                changed.forEach(selector -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    List&lt;SelectorData&gt; ls = SELECTOR_MAP</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .getOrDefault(selector.getPluginName(), new ArrayList&lt;&gt;())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .stream()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .filter(s -&gt; !s.getId().equals(selector.getId()))</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .sorted(SELECTOR_DATA_COMPARATOR)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                            .collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    ls.add(selector);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    SELECTOR_MAP.put(selector.getPluginName(), ls);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishConfig(NacosPathConstants.SELECTOR_DATA_ID, SELECTOR_MAP);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这部分是核心。<code>changed</code>表示需更新的<code>SelectorData</code>列表，<code>eventType</code>表示事件类型。<code>SELECTOR_MAP</code>的类型是<code>ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt;</code>，该map的key为selector所属的plugin的名称，value为该plugin下的selector列表。<code>NacosPathConstants.SELECTOR_DATA_ID</code>的值为<code>shenyu.selector.json</code>。操作步骤如下，第一步，使用<code>getConfig</code>方法调用<code>Nacos</code>的api，从<code>Nacos</code>获取<code>group</code>为<code>shenyu.selector.json</code>的配置信息，<code>updateSelectorMap</code>方法使用这些配置信息更新<code>SELECTOR_MAP</code>，这样就同步到了<code>Nacos</code>上最新的selector信息。第二步，再根据事件类型来更新<code>SELECTOR_MAP</code>，最后使用<code>publishConfig</code>方法，调用<code>Nacos</code>的api，将<code>Nacos</code>上，<code>group</code>为<code>shenyu.selector.json</code>的配置进行全量替换。</p><p>只要将变动的数据正确写入到<code>Nacos</code>上，<code>admin</code>这边的操作就执行完成了。</p><p>在我们当前的案例中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90，就会对图中的特定节点更新。</p><p><img src="/zh/assets/images/zookeeper-node-c7628b680a1f1afa0eada97b66fcd5b1.png"></p><p>我们用时序图将上面的更新流程串联起来。</p><p><img src="/zh/assets/images/nacos-sync-sequence-admin-zh-73003e7cb52938c5528bbfcc58adfc17.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行，使用的数据同步方式也是<code>nacos</code>。那么当在<code>admin</code>端更新选择器数据后，并且向<code>nacos</code>发送了变更的数据，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-nacossyncdataservice接收数据"></a>3.1 <code>NacosSyncDataService</code>接收数据<a class="hash-link" href="#31-nacossyncdataservice接收数据" title="Direct link to heading">#</a></h4><p>网关是通过<code>NacosSyncDataService</code>对<code>nacos</code>进行监听并获取数据更新的，但是在这部分内容之前，我们先看一下<code>NacosSyncDataService</code>类型的bean是如何生成的。答案是在Spring配置类<code>NacosSyncDataConfiguration</code>中定义的。我们看到<code>NacosSyncDataConfiguration</code>类上的注解，<code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.nacos&quot;, name = &quot;url&quot;)</code>，这个注解我们在上文对<code>ShenYu</code>的Admin端中的<code>NacosListener</code>类进行分析时看到过，是一个属性条件判断，满足条件，该配置类才会生效。也就是说，当我们在<code>Shenyu</code>网关端有如下配置时，就表示<code>Shenyu</code>网关端采用<code>nacos</code>进行数据同步，<code>NacosSyncDataConfiguration</code>这个配置类生效。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     nacos:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          url: localhost:8848</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Nacos sync data configuration for spring boot.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnClass(NacosSyncDataService.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConditionalOnProperty(prefix = &quot;shenyu.sync.nacos&quot;, name = &quot;url&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosSyncDataConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger LOGGER = LoggerFactory.getLogger(NacosSyncDataConfiguration.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Nacos sync data service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param configService     the config service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param pluginSubscriber the plugin subscriber</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param metaSubscribers   the meta subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param authSubscribers   the auth subscribers</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public SyncDataService nacosSyncDataService(final ObjectProvider&lt;ConfigService&gt; configService, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOGGER.info(&quot;you use nacos sync shenyu data.......&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new NacosSyncDataService(configService.getIfAvailable(), pluginSubscriber.getIfAvailable(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Nacos config service config service.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param nacosConfig the nacos config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the config service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @throws Exception the exception</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ConfigService nacosConfigService(final NacosConfig nacosConfig) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties properties = new Properties();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (nacosConfig.getAcm() != null &amp;&amp; nacosConfig.getAcm().isEnabled()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.ENDPOINT, nacosConfig.getAcm().getEndpoint());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.NAMESPACE, nacosConfig.getAcm().getNamespace());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.ACCESS_KEY, nacosConfig.getAcm().getAccessKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.SECRET_KEY, nacosConfig.getAcm().getSecretKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            properties.put(PropertyKeyConst.SERVER_ADDR, nacosConfig.getUrl());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isNotBlank(nacosConfig.getNamespace())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.NAMESPACE, nacosConfig.getNamespace());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nacosConfig.getUsername() != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.USERNAME, nacosConfig.getUsername());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (nacosConfig.getPassword() != null) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                properties.put(PropertyKeyConst.PASSWORD, nacosConfig.getPassword());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return NacosFactory.createConfigService(properties);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Http config http config.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the http config</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConfigurationProperties(prefix = &quot;shenyu.sync.nacos&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NacosConfig nacosConfig() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new NacosConfig();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>我们重点关注一下上面代码中<code>nacosSyncDataService</code>这个bean的生成：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public SyncDataService nacosSyncDataService(final ObjectProvider&lt;ConfigService&gt; configService, final ObjectProvider&lt;PluginDataSubscriber&gt; pluginSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                           final ObjectProvider&lt;List&lt;MetaDataSubscriber&gt;&gt; metaSubscribers, final ObjectProvider&lt;List&lt;AuthDataSubscriber&gt;&gt; authSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOGGER.info(&quot;you use nacos sync shenyu data.......&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return new NacosSyncDataService(configService.getIfAvailable(), pluginSubscriber.getIfAvailable(),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>是直接调用<code>NacosSyncDataService</code>的构造方法new了一个该类型的对象。我们继续看构造方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public NacosSyncDataService(final ConfigService configService, final PluginDataSubscriber pluginDataSubscriber,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                                final List&lt;MetaDataSubscriber&gt; metaDataSubscribers, final List&lt;AuthDataSubscriber&gt; authDataSubscribers) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        super(configService, pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        start();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    public void start() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData(NacosPathConstants.PLUGIN_DATA_ID, this::updatePluginMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData(NacosPathConstants.SELECTOR_DATA_ID, this::updateSelectorMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData(NacosPathConstants.RULE_DATA_ID, this::updateRuleMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData(NacosPathConstants.META_DATA_ID, this::updateMetaDataMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherData(NacosPathConstants.AUTH_DATA_ID, this::updateAuthMap);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    protected void watcherData(final String dataId, final OnChange oc) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Listener listener = new Listener() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public void receiveConfigInfo(final String configInfo) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                oc.change(configInfo);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            public Executor getExecutor() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                return null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        oc.change(getConfigAndSignListener(dataId, listener));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LISTENERS.computeIfAbsent(dataId, key -&gt; new ArrayList&lt;&gt;()).add(listener);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>可以看到，在构造方法中调用了<code>start</code>方法，并且通过<code>watcherData</code>方法创建了监听器，并且关联了回调函数oc，由于我们正在分析selector类型组件的变化，对应的回调函数是<code>updateSelectorMap</code>。这个回调函数用于处理数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-处理数据"></a>3.2 处理数据<a class="hash-link" href="#32-处理数据" title="Direct link to heading">#</a></h4><ul><li>NacosCacheHandler.updateSelectorMap()</li></ul><p>经过判空逻辑之后，缓存选择器数据的操作又交给了<code>PluginDataSubscriber</code>处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    protected void updateSelectorMap(final String configInfo) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; selectorDataList = GsonUtils.getInstance().toObjectMapList(configInfo, SelectorData.class).values().stream().flatMap(Collection::stream).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorDataList.forEach(selectorData -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(subscriber -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                subscriber.unSelectorSubscribe(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                subscriber.onSelectorSubscribe(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (JsonParseException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOG.error(&quot;sync selector data have error:&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>PluginDataSubscriber</code>是一个接口，它只有一个<code>CommonPluginDataSubscriber</code>实现类，负责处理插件、选择器和规则数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-通用插件数据订阅者"></a>3.3 通用插件数据订阅者<a class="hash-link" href="#33-通用插件数据订阅者" title="Direct link to heading">#</a></h4><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-数据缓存到内存"></a>3.4 数据缓存到内存<a class="hash-link" href="#34-数据缓存到内存" title="Direct link to heading">#</a></h4><p>那么更新一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增更新一条选择器数据，就将<code>nacos</code>数据同步的流程分析清楚了。</p><p>我们还是通过时序图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/nacos-sync-sequence-gateway-zh-bdc1404f8b15c4ebb82baaa4485660ac.png"></p><p>数据同步的流程已经分析完了，为了不让同步流程被打断，在分析过程中就忽略了其他逻辑。网关同步操作初始化的流程在<code>NacosSyncDataService</code>的<code>start</code>方法中，我们在上文分析<code>网关数据同步</code>时分析过了，下面分析<code>Admin</code>的同步数据初始化。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-admin同步数据初始化"></a>4. Admin同步数据初始化<a class="hash-link" href="#4-admin同步数据初始化" title="Direct link to heading">#</a></h3><p><code>admin</code>端，<code>NacosDataInit</code>类型的bean，在<code>NacosListener</code>中进行定义和生成，如果<code>admin</code>的配置中指定了使用<code>nacos</code>进行数据同步，当<code>admin</code>启动后，会将当前的数据信息全量同步到<code>nacos</code>中，实现逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Nacos data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class NacosDataInit implements CommandLineRunner {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger LOG = LoggerFactory.getLogger(NacosDataInit.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ConfigService configService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final SyncDataService syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Instantiates a new Nacos data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param configService the nacos config service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public NacosDataInit(final ConfigService configService, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.configService = configService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.syncDataService = syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void run(final String... args) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String pluginDataId = NacosPathConstants.PLUGIN_DATA_ID;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String authDataId = NacosPathConstants.AUTH_DATA_ID;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String metaDataId = NacosPathConstants.META_DATA_ID;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (dataIdNotExist(pluginDataId) &amp;&amp; dataIdNotExist(authDataId) &amp;&amp; dataIdNotExist(metaDataId)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            syncDataService.syncAll(DataEventTypeEnum.REFRESH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private boolean dataIdNotExist(final String pluginDataId) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String group = NacosPathConstants.GROUP;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            long timeout = NacosPathConstants.DEFAULT_TIME_OUT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return configService.getConfig(pluginDataId, group, timeout) == null;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (NacosException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            LOG.error(&quot;Get data from nacos error.&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new ShenyuException(e.getMessage());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>判断<code>nacos</code>中是否存在数据，如果不存在，则进行同步。</p><p><code>NacosDataInit</code>实现了<code>CommandLineRunner</code>接口。它是<code>springboot</code>提供的接口，会在所有 <code>Spring Beans</code>初始化之后执行<code>run()</code>方法，常用于项目中初始化的操作。</p><ul><li>SyncDataService.syncAll()</li></ul><p>从数据库查询数据，然后进行全量数据同步，所有的认证信息、插件信息、选择器信息、规则信息和元数据信息。主要是通过<code>eventPublisher</code>发布同步事件。这里就跟前面提到的同步逻辑就又联系起来了，<code>eventPublisher</code>通过<code>publishEvent()</code>发布完事件后，有<code>ApplicationListener</code>执行事件变更操作，在<code>ShenYu</code>中就是前面提到的<code>DataChangedEventDispatcher</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SyncDataServiceImpl implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 事件发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     /***</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean syncAll(final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        appAuthService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;PluginData&gt; pluginDataList = pluginService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorData&gt; selectorDataList = selectorService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleData&gt; ruleDataList = ruleService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步元数据信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        metaDataService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-总结"></a>5. 总结<a class="hash-link" href="#5-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>nacos</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li>基于<code>nacos</code>的数据同步，主要是通过<code>watch</code>机制实现；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/nacos">nacos</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/DataSync-SourceCode-Analysis-Etcd-Data-Sync">Etcd数据同步源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2023-10-10T01:57:14.664Z">2023年10月10日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/4zd" target="_blank" rel="noopener noreferrer">4zd</a></div><small class="avatar__subtitle">Apache ShenYu Contributor</small></div></div></header><div class="markdown"><blockquote><p><a href="https://shenyu.apache.org/zh/docs/index" target="_blank" rel="noopener noreferrer">Apache ShenYu</a> 是一个异步的，高性能的，跨语言的，响应式的 <code>API</code> 网关。</p></blockquote><p>在<code>ShenYu</code>网关中，数据同步是指，当在后台管理系统中，数据发送了更新后，如何将更新的数据同步到网关中。<code>Apache ShenYu</code> 网关当前支持<code>ZooKeeper</code>、<code>WebSocket</code>、<code>Http长轮询</code>、<code>Nacos</code> 、<code>Etcd</code> 和 <code>Consul</code> 进行数据同步。本文的主要内容是基于<code>Etcd</code>的数据同步源码分析。</p><blockquote><p>本文基于<code>shenyu-2.4.0</code>版本进行源码分析，官网的介绍请参考 <a href="https://shenyu.apache.org/zh/docs/design/data-sync" target="_blank" rel="noopener noreferrer">数据同步原理</a> 。</p></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="1-关于etcd"></a>1. 关于Etcd<a class="hash-link" href="#1-关于etcd" title="Direct link to heading">#</a></h3><p><a href="https://github.com/etcd-io/etcd" target="_blank" rel="noopener noreferrer"><code>Etcd</code></a>是一个分布式的键值对存储系统，它为大型分布式计算提供分布式配置服务、同步服务和命名注册。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="2-admin数据同步"></a>2. Admin数据同步<a class="hash-link" href="#2-admin数据同步" title="Direct link to heading">#</a></h3><p>我们从一个实际案例进行源码追踪，比如在后台管理系统中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90：</p><p><img src="/zh/assets/images/update-selector-zh-1f49b39fb8e5ce2c26a80018669619ea.png"></p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="21-接收数据"></a>2.1 接收数据<a class="hash-link" href="#21-接收数据" title="Direct link to heading">#</a></h4><ul><li>SelectorController.createSelector()</li></ul><p>进入<code>SelectorController</code>类中的<code>updateSelector()</code>方法，它负责数据的校验，添加或更新数据，返回结果信息。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Validated</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RestController</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@RequestMapping(&quot;/selector&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorController {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @PutMapping(&quot;/{id}&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public ShenyuAdminResult updateSelector(@PathVariable(&quot;id&quot;) final String id, @Valid @RequestBody final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 设置当前选择器数据id</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        selectorDTO.setId(id);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建或更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Integer updateCount = selectorService.createOrUpdate(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 返回结果信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return ShenyuAdminResult.success(ShenyuResultMessage.UPDATE_SUCCESS, updateCount);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="22-处理数据"></a>2.2 处理数据<a class="hash-link" href="#22-处理数据" title="Direct link to heading">#</a></h4><ul><li>SelectorServiceImpl.createOrUpdate()</li></ul><p>在<code>SelectorServiceImpl</code>类中通过<code>createOrUpdate()</code>方法完成数据的转换，保存到数据库，发布事件，更新<code>upstream</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@RequiredArgsConstructor</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SelectorServiceImpl implements SelectorService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 负责事件发布的eventPublisher</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Transactional(rollbackFor = Exception.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public int createOrUpdate(final SelectorDTO selectorDTO) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        int selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建数据 DTO --&gt; DO</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        SelectorDO selectorDO = SelectorDO.buildSelectorDO(selectorDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorConditionDTO&gt; selectorConditionDTOs = selectorDTO.getSelectorConditions();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 判断是添加还是更新</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isEmpty(selectorDTO.getId())) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.insertSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插入选择器中的条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // check selector add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 权限检查</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (dataPermissionMapper.listByUserId(JwtUtils.getUserInfo().getUserId()).size() &gt; 0) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                DataPermissionDTO dataPermissionDTO = new DataPermissionDTO();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setUserId(JwtUtils.getUserInfo().getUserId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionDTO.setDataType(AdminConstants.SELECTOR_DATA_TYPE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                dataPermissionMapper.insertSelective(DataPermissionDO.buildPermissionDO(dataPermissionDTO));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 更新数据，先删除再新增</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorCount = selectorMapper.updateSelective(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            //delete rule condition then add</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionMapper.deleteByQuery(new SelectorConditionQuery(selectorDO.getId()));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            selectorConditionDTOs.forEach(selectorConditionDTO -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionDTO.setSelectorId(selectorDO.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorConditionDO selectorConditionDO = SelectorConditionDO.buildSelectorConditionDO(selectorConditionDTO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                selectorConditionMapper.insertSelective(selectorConditionDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布事件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        publishEvent(selectorDO, selectorConditionDTOs);</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 更新upstream</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateDivideUpstream(selectorDO);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return selectorCount;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>在<code>Service</code>类完成数据的持久化操作，即保存数据到数据库，这个比较简单，就不深入追踪了。关于更新<code>upstream</code>操作，放到后面对应的章节中进行分析，重点关注发布事件的操作，它会执行数据同步。</p><p><code>publishEvent()</code>方法的逻辑是：找到选择器对应的插件，构建条件数据，发布变更数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">     private void publishEvent(final SelectorDO selectorDO, final List&lt;SelectorConditionDTO&gt; selectorConditionDTOs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 找到选择器对应的插件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        PluginDO pluginDO = pluginMapper.selectById(selectorDO.getPluginId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建条件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;ConditionData&gt; conditionDataList =                selectorConditionDTOs.stream().map(ConditionTransfer.INSTANCE::mapToSelectorDTO).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 发布变更数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, DataEventTypeEnum.UPDATE,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Collections.singletonList(SelectorDO.transFrom(selectorDO, pluginDO.getName(), conditionDataList))));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>发布变更数据通过<code>eventPublisher.publishEvent()</code>完成，这个<code>eventPublisher</code>对象是一个<code>ApplicationEventPublisher</code>类，这个类的全限定名是<code>org.springframework.context.ApplicationEventPublisher</code>。看到这儿，我们知道了发布数据是通过<code>Spring</code>相关的功能来完成的。</p><blockquote><p>关于<code>ApplicationEventPublisher</code>：</p><p>当有状态发生变化时，发布者调用 <code>ApplicationEventPublisher</code> 的 <code>publishEvent</code> 方法发布一个事件，<code>Spring</code>容器广播事件给所有观察者，调用观察者的 <code>onApplicationEvent</code> 方法把事件对象传递给观察者。调用 <code>publishEvent</code>方法有两种途径，一种是实现接口由容器注入 <code>ApplicationEventPublisher</code> 对象然后调用其方法，另一种是直接调用容器的方法，两种方法发布事件没有太大区别。</p><ul><li><code>ApplicationEventPublisher</code>：发布事件；</li><li><code>ApplicationEvent</code>：<code>Spring</code> 事件，记录事件源、时间和数据；</li><li><code>ApplicationListener</code>：事件监听者，观察者；</li></ul></blockquote><p>在<code>Spring</code>的事件发布机制中，有三个对象，</p><p>一个是发布事件的<code>ApplicationEventPublisher</code>，在<code>ShenYu</code>中通过构造器注入了一个<code>eventPublisher</code>。</p><p>另一个对象是<code>ApplicationEvent</code>，在<code>ShenYu</code>中通过<code>DataChangedEvent</code>继承了它，表示事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEvent extends ApplicationEvent {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">//......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>最后一个是 <code>ApplicationListener</code>，在<code>ShenYu</code>中通过<code>DataChangedEventDispatcher</code>类实现了该接口，作为事件的监听者，负责处理事件对象。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="23-分发数据"></a>2.3 分发数据<a class="hash-link" href="#23-分发数据" title="Direct link to heading">#</a></h4><ul><li>DataChangedEventDispatcher.onApplicationEvent()</li></ul><p>当事件发布完成后，会自动进入到<code>DataChangedEventDispatcher</code>类中的<code>onApplicationEvent()</code>方法，进行事件处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Component</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataChangedEventDispatcher implements ApplicationListener&lt;DataChangedEvent&gt;, InitializingBean {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 有数据变更时，调用此方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param event</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case APP_AUTH: // 认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onAppAuthChanged((List&lt;AppAuthData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case PLUGIN:  // 插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onPluginChanged((List&lt;PluginData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case RULE:    // 规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onRuleChanged((List&lt;RuleData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case META_DATA:  // 元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onMetaDataChanged((List&lt;MetaData&gt;) event.getSource(), event.getEventType());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                default:  // 其他类型，抛出异常</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;Unexpected value: &quot; + event.getGroupKey());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当有数据变更时，调用<code>onApplicationEvent</code>方法，然后遍历所有数据变更监听器，判断是哪种数据类型，交给相应的数据监听器进行处理。</p><p><code>ShenYu</code>将所有数据进行了分组，一共是五种：认证信息、插件信息、规则信息、选择器信息和元数据。</p><p>这里的数据变更监听器（<code>DataChangedListener</code>），就是数据同步策略的抽象，它的具体实现有：</p><p><img src="/zh/assets/images/data-changed-listener-b01d7410746ca4afd526d8c9df865e9b.png"></p><p>这几个实现类就是当前<code>ShenYu</code>支持的同步策略：</p><ul><li><code>WebsocketDataChangedListener</code>：基于<code>websocket</code>的数据同步；</li><li><code>ZookeeperDataChangedListener</code>：基于<code>zookeeper</code>的数据同步；</li><li><code>ConsulDataChangedListener</code>：基于<code>consul</code>的数据同步；</li><li><code>EtcdDataDataChangedListener</code>：基于<code>etcd</code>的数据同步；</li><li><code>HttpLongPollingDataChangedListener</code>：基于<code>http长轮询</code>的数据同步；</li><li><code>NacosDataChangedListener</code>：基于<code>nacos</code>的数据同步；</li></ul><p>既然有这么多种实现策略，那么如何确定使用哪一种呢？</p><p>因为本文是基于<code>Etcd</code>的数据同步源码分析，所以这里以<code>EtcdDataDataChangedListener</code>为例，分析它是如何被加载并实现的。</p><p>通过查看对<code>EtcdDataDataChangedListener</code>类的调用，可以发现，它是在<code>DataSyncConfiguration</code>类进行配置的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 数据同步配置类</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通过springboot条件装配实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Data sync configuration.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class DataSyncConfiguration {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   * The type Etcd listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">   */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Configuration</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @ConditionalOnProperty(prefix = &quot;shenyu.sync.etcd&quot;, name = &quot;url&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @EnableConfigurationProperties(EtcdProperties.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  static class EtcdListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EtcdClient etcdClient(final EtcdProperties etcdProperties) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      Client client = Client.builder()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              .endpoints(etcdProperties.getUrl())</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              .build();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new EtcdClient(client);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Config event listener data changed listener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建Etcd数据变更监听器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param etcdClient the etcd client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the data changed listener</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean(EtcdDataDataChangedListener.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public DataChangedListener etcdDataChangedListener(final EtcdClient etcdClient) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new EtcdDataDataChangedListener(etcdClient);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * data init.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 创建Etcd数据初始化类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param etcdClient        the etcd client</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param syncDataService the sync data service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the etcd data init</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Bean</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @ConditionalOnMissingBean(EtcdDataInit.class)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EtcdDataInit etcdDataInit(final EtcdClient etcdClient, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      return new EtcdDataInit(etcdClient, syncDataService);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略了其他代码......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这个配置类是通过<code>SpringBoot</code>条件装配类实现的。在<code>EtcdListener</code>类上面有几个注解：</p><ul><li><p><code>@Configuration</code>：配置文件，应用上下文；</p></li><li><p><code>@ConditionalOnProperty(prefix = &quot;shenyu.sync.etcd&quot;, name = &quot;url&quot;)</code>：属性条件判断，满足条件，该配置类才会生效。也就是说，当我们有如下配置时，就会采用<code>etcd</code>进行数据同步。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">shenyu:  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  sync:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     etcd:</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          url: localhost:2181</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div></li><li><p><code>@EnableConfigurationProperties(EtcdProperties.class)</code>：导入另一个属性类<code>EtcdProperties</code>，<code>EtcdProperties</code>中各属性对应配置文件中以<code>shenyu.sync.etcd</code>作为前缀的各属性。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@ConfigurationProperties(prefix = &quot;shenyu.sync.etcd&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EtcdProperties {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private String url;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Integer sessionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private Integer connectionTimeout;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private String serializer;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>当我们在配置文件中配置了<code>shenyu.sync.etcd.url</code>属性时，<code>Admin</code>将采用<code>etcd</code>进行数据同步，此时配置类<code>EtcdListener</code>会生效，并生成<code>EtcdClient</code>, <code>EtcdDataDataChangedListener</code>和<code>EtcdDataInit</code>类型的bean。</p><ul><li>生成<code>EtcdClient</code>类型的bean，<code>etcdClient</code>，这个bean根据配置文件，配置了与etcd服务器的连接信息，可以直接操作etcd节点。</li><li>生成<code>EtcdDataDataChangedListener</code>类型的bean，<code>etcdDataDataChangedListener</code>，这个bean将bean<code>etcdClient</code>作为成员变量，当监听到事件时，进行回调操作，可以直接使用该bean操作etcd节点。</li><li>生成<code>EtcdDataInit</code>类型的bean，<code>etcdDataInit</code>，这个bean将bean<code>etcdClient</code>和bean<code>syncDataService</code>作为成员变量，使用<code>etcdClient</code>根据etcd路径，判断数据是否未初始化，当未初始化时，将调用syncDataService进行刷新操作，将在下文详述。
根据上文所述，在事件处理方法<code>onApplicationEvent()</code>中，就会到相应的<code>listener</code>中。在我们的案例中，是对一条选择器数据进行更新，数据同步采用的是<code>etcd</code>，所以，代码会进入到<code>EtcdDataDataChangedListener</code>进行选择器数据变更处理。</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    //DataChangedEventDispatcher.java</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @SuppressWarnings(&quot;unchecked&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onApplicationEvent(final DataChangedEvent event) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历数据变更监听器(一般使用一种数据同步的方式就好了)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        for (DataChangedListener listener : listeners) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 哪种数据发生变更</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            switch (event.getGroupKey()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 省略了其他逻辑</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">                case SELECTOR:   // 选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    listener.onSelectorChanged((List&lt;SelectorData&gt;) event.getSource(), event.getEventType());   // 在我们的案例中，会进入到EtcdDataDataChangedListener进行选择器数据变更处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    break;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">         }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="24-etcd数据变更监听器"></a>2.4 Etcd数据变更监听器<a class="hash-link" href="#24-etcd数据变更监听器" title="Direct link to heading">#</a></h4><ul><li><p>EtcdDataDataChangedListener.onSelectorChanged()</p><p>在<code>onSelectorChanged()</code>方法中，判断操作类型，是刷新同步还是更新或创建同步。根据当前选择器数据信息判断节点是否在<code>etcd</code>中。</p></li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * EtcdDataDataChangedListener.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EtcdDataDataChangedListener implements DataChangedListener {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final EtcdClient etcdClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public EtcdDataDataChangedListener(final EtcdClient client) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        this.etcdClient = client;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 选择器信息发生改变</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorChanged(final List&lt;SelectorData&gt; changed, final DataEventTypeEnum eventType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 刷新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (eventType == DataEventTypeEnum.REFRESH &amp;&amp; !changed.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String selectorParentPath = DefaultPathConstants.buildSelectorParentPath(changed.get(0).getPluginName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        etcdClient.deleteEtcdPathRecursive(selectorParentPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 发生变更的数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      for (SelectorData data : changed) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 构建选择器数据的真实路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String selectorRealPath = DefaultPathConstants.buildSelectorRealPath(data.getPluginName(), data.getId());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (eventType == DataEventTypeEnum.DELETE) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          etcdClient.delete(selectorRealPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">          continue;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        //create or update，创建或更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        updateNode(selectorRealPath, data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这部分是核心。<code>changed</code>表示需更新的<code>SelectorData</code>列表，<code>eventType</code>表示事件类型。当事件类型为刷新<code>REFRESH</code>，并且<code>SelectorData</code>有改动时，会先将etcd中该plugin下的selector节点都先删除。注意这里的条件<code>SelectorData</code>有改动是必须的，否则会出现没有改动时进行刷新，将所有selector节点都删除的bug。
获取到selector对应路径后，会对节点进行删除、创建或更新。</p><p>只要将变动的数据正确写入到<code>etcd</code>的节点上，<code>admin</code>这边的操作就执行完成了。</p><p>在我们当前的案例中，对<code>Divide</code>插件中的一条选择器数据进行更新，将权重更新为90，就会对图中的特定节点更新。</p><p><img src="/zh/assets/images/zookeeper-node-c7628b680a1f1afa0eada97b66fcd5b1.png"></p><p>我们用时序图将上面的更新流程串联起来。</p><p><img src="/zh/assets/images/etcd-sync-sequence-admin-zh-d9ccd2c6bd5f9b3f135c5420b60fd403.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="3-网关数据同步"></a>3. 网关数据同步<a class="hash-link" href="#3-网关数据同步" title="Direct link to heading">#</a></h3><p>假设<code>ShenYu</code>网关已经在正常运行，使用的数据同步方式也是<code>etcd</code>。那么当在<code>admin</code>端更新选择器数据后，并且向<code>etcd</code>发送了变更的数据，那网关是如何接收并处理数据的呢？接下来我们就继续进行源码分析，一探究竟。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="31-etcdclient接收数据"></a>3.1 EtcdClient接收数据<a class="hash-link" href="#31-etcdclient接收数据" title="Direct link to heading">#</a></h4><ul><li>EtcdClient.watchDataChange()</li></ul><p>在网关端有一个<code>EtcdSyncDataService</code>类，它通过<code>etcdClient</code>订阅了数据节点，当数据发生变更时，可以感知到。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * Data synchronize of etcd.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EtcdSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //省略其它代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void subscribeSelectorDataChanges(final String path) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      etcdClient.watchDataChange(path, (updateNode, updateValue) -&gt; cacheSelectorData(updateValue),</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              this::unCacheSelectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  //省略其它代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>Etcd</code>的<code>Watch</code>机制，会给订阅的客户端发送节点变更通知。在我们的案例中，更新选择器信息，就会进入到<code>watchDataChange()</code>方法。通过<code>cacheSelectorData()</code>去处理数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="32-处理数据"></a>3.2 处理数据<a class="hash-link" href="#32-处理数据" title="Direct link to heading">#</a></h4><ul><li>EtcdSyncDataService.cacheSelectorData()</li></ul><p>经过判空逻辑之后，缓存选择器数据的操作又交给了<code>PluginDataSubscriber</code>处理。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">    private void cacheSelectorData(final String dataString) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        final SelectorData selectorData = GsonUtils.getInstance().fromJson(dataString, SelectorData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            .ifPresent(data -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSelectorSubscribe(data)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>PluginDataSubscriber</code>是一个接口，它只有一个<code>CommonPluginDataSubscriber</code>实现类，负责处理插件、选择器和规则数据。</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="33-通用插件数据订阅者"></a>3.3 通用插件数据订阅者<a class="hash-link" href="#33-通用插件数据订阅者" title="Direct link to heading">#</a></h4><ul><li>PluginDataSubscriber.onSelectorSubscribe()</li></ul><p>它没有其他逻辑，直接调用<code>subscribeDataHandler()</code>方法。在方法中，更具数据类型（插件、选择器或规则），操作类型（更新或删除），去执行不同逻辑。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * 通用插件数据订阅者，负责处理所有插件、选择器和规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * The type Common plugin data subscriber.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class CommonPluginDataSubscriber implements PluginDataSubscriber {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    //......</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     // 处理选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void onSelectorSubscribe(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        subscribeDataHandler(selectorData, DataEventTypeEnum.UPDATE);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据处理器，处理数据的更新或删除</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private &lt;T&gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(classData).ifPresent(data -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (data instanceof PluginData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                PluginData pluginData = (PluginData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cachePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.handlerPlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removePluginData(pluginData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&gt; handler.removePlugin(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof SelectorData) {  // 选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                SelectorData selectorData = (SelectorData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) {  // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.removeSelector(selectorData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            } else if (data instanceof RuleData) {  // 规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                RuleData ruleData = (RuleData) data;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                if (dataType == DataEventTypeEnum.UPDATE) { // 更新操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().cacheRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.handlerRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } else if (dataType == DataEventTypeEnum.DELETE) { // 删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 从网关内存移除数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    BaseDataCache.getInstance().removeRuleData(ruleData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 如果每个插件还有自己的处理逻辑，那么就去处理</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&gt; handler.removeRule(ruleData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="34-数据缓存到内存"></a>3.4 数据缓存到内存<a class="hash-link" href="#34-数据缓存到内存" title="Direct link to heading">#</a></h4><p>那么更新一条选择器数据，会进入下面的逻辑：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 将数据保存到网关内存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">BaseDataCache.getInstance().cacheSelectData(selectorData);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 如果每个插件还有自己的处理逻辑，那么就去处理                    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&gt; handler.handlerSelector(selectorData));</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>一是将数据保存到网关的内存中。<code>BaseDataCache</code>是最终缓存数据的类，通过单例模式实现。选择器数据就存到了<code>SELECTOR_MAP</code>这个<code>Map</code>中。在后续使用的时候，也是从这里拿数据。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class BaseDataCache {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final BaseDataCache INSTANCE = new BaseDataCache();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 私有构造器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private BaseDataCache() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets instance.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *  公开方法</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the instance</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static BaseDataCache getInstance() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return INSTANCE;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    *  缓存选择器数据的Map</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * pluginName -&gt; SelectorData.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final ConcurrentMap&lt;String, List&lt;SelectorData&gt;&gt; SELECTOR_MAP = Maps.newConcurrentMap();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void cacheSelectData(final SelectorData selectorData) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Optional.ofNullable(selectorData).ifPresent(this::selectorAccept);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">   /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * cache selector data.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 缓存选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param data the selector data</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private void selectorAccept(final SelectorData data) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String key = data.getPluginName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (SELECTOR_MAP.containsKey(key)) { // 更新操作，先删除再插入</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            List&lt;SelectorData&gt; existList = SELECTOR_MAP.get(key);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; resultList = existList.stream().filter(r -&gt; !r.getId().equals(data.getId())).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            resultList.add(data);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            final List&lt;SelectorData&gt; collect = resultList.stream().sorted(Comparator.comparing(SelectorData::getSort)).collect(Collectors.toList());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, collect);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {  // 新增操作，直接放到Map中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            SELECTOR_MAP.put(key, Lists.newArrayList(data));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>二是如果每个插件还有自己的处理逻辑，那么就去处理。  通过<code>idea</code>编辑器可以看到，当新增一条选择器后，有如下的插件还有处理。这里我们就不再展开了。</p><p><img src="/zh/assets/images/handler-selector-bf05b8fdf80a428aa53606178a42bae6.png"></p><p>经过以上的源码追踪，并通过一个实际的案例，在<code>admin</code>端新增更新一条选择器数据，就将<code>etcd</code>数据同步的流程分析清楚了。</p><p>我们还是通过时序图将网关端的数据同步流程串联一下：</p><p><img src="/zh/assets/images/etcd-sync-sequence-gateway-zh-708de62d8fafbb80c133b20247674db6.png"></p><p>数据同步的流程已经分析完了，为了不让同步流程被打断，在分析过程中就忽略了其他逻辑。我们还需要分析<code>Admin</code>同步数据初始化和网关同步操作初始化的流程。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="4-admin同步数据初始化"></a>4. Admin同步数据初始化<a class="hash-link" href="#4-admin同步数据初始化" title="Direct link to heading">#</a></h3><p>当<code>admin</code>启动后，会将当前的数据信息全量同步到<code>etcd</code>中，实现逻辑如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * EtcdDataInit.</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EtcdDataInit implements CommandLineRunner {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final EtcdClient etcdClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private final SyncDataService syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public EtcdDataInit(final EtcdClient client, final SyncDataService syncDataService) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.etcdClient = client;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.syncDataService = syncDataService;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public void run(final String... args) throws Exception {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final String pluginPath = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final String authPath = DefaultPathConstants.APP_AUTH_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final String metaDataPath = DefaultPathConstants.META_DATA;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!etcdClient.exists(pluginPath) &amp;&amp; !etcdClient.exists(authPath) &amp;&amp; !etcdClient.exists(metaDataPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      log.info(&quot;Init all data from database&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      syncDataService.syncAll(DataEventTypeEnum.REFRESH);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>判断<code>etcd</code>中是否存在数据，如果不存在，则进行同步。</p><p><code>EtcdDataInit</code>实现了<code>CommandLineRunner</code>接口。它是<code>springboot</code>提供的接口，会在所有 <code>Spring Beans</code>初始化之后执行<code>run()</code>方法，常用于项目中初始化的操作。</p><ul><li>SyncDataService.syncAll()</li></ul><p>从数据库查询数据，然后进行全量数据同步，所有的认证信息、插件信息、选择器信息、规则信息和元数据信息。主要是通过<code>eventPublisher</code>发布同步事件。这里就跟前面提到的同步逻辑就又联系起来了，<code>eventPublisher</code>通过<code>publishEvent()</code>发布完事件后，有<code>ApplicationListener</code>执行事件变更操作，在<code>ShenYu</code>中就是前面提到的<code>DataChangedEventDispatcher</code>。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Service</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SyncDataServiceImpl implements SyncDataService {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 事件发布</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ApplicationEventPublisher eventPublisher;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">     /***</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * 全量数据同步</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param type the type</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public boolean syncAll(final DataEventTypeEnum type) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步认证信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        appAuthService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步插件信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;PluginData&gt; pluginDataList = pluginService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步选择器信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;SelectorData&gt; selectorDataList = selectorService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步规则信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        List&lt;RuleData&gt; ruleDataList = ruleService.listAll();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 同步元数据信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        metaDataService.syncData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="5-网关同步操作初始化"></a>5. 网关同步操作初始化<a class="hash-link" href="#5-网关同步操作初始化" title="Direct link to heading">#</a></h3><p>网关这边的数据同步初始化操作主要是订阅<code>etcd</code>中的节点，当有数据变更时，收到变更数据。这依赖于<code>Etcd</code>的<code>Watch</code>机制。在<code>ShenYu</code>中，负责<code>etcd</code>数据同步的是<code>EtcdSyncDataService</code>，也在前面提到过。</p><p><code>EtcdSyncDataService</code>的功能逻辑是在实例化的过程中完成的：对<code>etcd</code>中的<code>shenyu</code>数据同步节点完成订阅。这里的订阅分两类，一类是已经存在的节点上面数据发生更新，这通过<code>etcdClient.watchDataChange()</code>方法实现；另一类是当前节点下有新增或删除节点，即子节点发生变化，这通过<code>etcdClient.watchChildChange()</code>方法实现。</p><p><code>EtcdSyncDataService</code>的代码有点多，这里我们以插件数据的读取和订阅进行追踪，其他类型的数据操作原理是一样的。</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * etcd 数据同步服务</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Slf4j</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class EtcdSyncDataService implements SyncDataService, AutoCloseable {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 在实例化的时候，完成从etcd中读取数据的操作，并订阅节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  public EtcdSyncDataService(/*省略构造参数*/) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.etcdClient = etcdClient;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.pluginDataSubscriber = pluginDataSubscriber;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.metaDataSubscribers = metaDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.authDataSubscribers = authDataSubscribers;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watcherData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅认证数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watchAppAuth();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅元数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watchMetaData();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void watcherData() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 插件节点路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final String pluginParent = DefaultPathConstants.PLUGIN_PARENT;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 所有插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    List&lt;String&gt; pluginZKs = etcdClientGetChildren(pluginParent);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    for (String pluginName : pluginZKs) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      // 订阅当前所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      watcherAll(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅子节点（新增或删除一个插件）</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    etcdClient.watchChildChange(pluginParent, (updateNode, updateValue) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      if (!updateNode.isEmpty()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 需要订阅子节点的所有插件、选择器和规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        watcherAll(updateNode);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void watcherAll(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅插件数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watcherPlugin(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅选择器数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watcherSelector(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅规则数据</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    watcherRule(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void watcherPlugin(final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前插件路径</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String pluginPath = DefaultPathConstants.buildPluginPath(pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存到网关内存中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    cachePluginData(etcdClient.get(pluginPath));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅插件节点</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    subscribePluginDataChanges(pluginPath, pluginName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void cachePluginData(final String dataString) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    final PluginData pluginData = GsonUtils.getInstance().fromJson(dataString, PluginData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Optional.ofNullable(pluginData)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      .flatMap(data -&gt; Optional.ofNullable(pluginDataSubscriber)).ifPresent(e -&gt; e.onSubscribe(pluginData));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }  </span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  private void subscribePluginDataChanges(final String pluginPath, final String pluginName) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 订阅数据变更：更新或删除，两个lambda表达式分别为更新和删除操作</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    etcdClient.watchDataChange(pluginPath, (updatePath, updateValue) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      final String dataPath = buildRealPath(pluginPath, updatePath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      final String dataStr = etcdClient.get(dataPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      final PluginData data = GsonUtils.getInstance().fromJson(dataStr, PluginData.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">      Optional.ofNullable(data)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">              .ifPresent(d -&gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(e -&gt; e.onSubscribe(d)));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }, deleteNode -&gt; deletePlugin(pluginName));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>上面的源代码中都给出了注释，相信大家可以看明白。订阅插件数据的主要逻辑如下：</p><blockquote><ol><li>构造当前插件路径</li><li>读取etcd上当前节点数据，并反序列化</li><li>插件数据缓存到网关内存中</li><li>订阅插件节点</li></ol></blockquote><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="6-总结"></a>6. 总结<a class="hash-link" href="#6-总结" title="Direct link to heading">#</a></h3><p>本文通过一个实际案例，对<code>etcd</code>的数据同步原理进行了源码分析。涉及到的主要知识点如下：</p><ul><li>基于<code>etcd</code>的数据同步，主要是通过<code>watch</code>机制实现；</li><li>通过<code>Spring</code>完成事件发布和监听；</li><li>通过抽象<code>DataChangedListener</code>接口，支持多种同步策略，面向接口编程；</li><li>使用单例设计模式实现缓存数据类<code>BaseDataCache</code>；</li><li>通过<code>SpringBoot</code>的条件装配和<code>starter</code>加载机制实现配置类的加载。</li></ul></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/etcd">etcd</a><a class="margin-horiz--sm" href="/zh/blog/tags/data-sync">data sync</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><article class="margin-bottom--xl"><header><h2 class="blogPostTitle_d4p0"><a href="/zh/blog/SPI-SourceCode-Analysis-SPI">SPI设计实现源码分析</a></h2><div class="blogPostData_-Im+ margin-vert--md"><time datetime="2022-09-12T00:00:00.000Z">2022年9月12日</time> · One min read</div><div class="avatar margin-vert--md"><div class="avatar__intro"><div class="avatar__name"><a href="https://github.com/zjcscut/" target="_blank" rel="noopener noreferrer">Throwable</a></div><small class="avatar__subtitle"></small></div></div></header><div class="markdown"><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="背景"></a>背景<a class="hash-link" href="#背景" title="Direct link to heading">#</a></h2><p>最近研读<code>Apache</code>开源项目<code>Shenyu</code>网关的源码，网关的多个核心组件加载都用到了<code>SPI</code>模块。本文就<code>Shenyu</code>中的<code>SPI</code>设计和源码实现进行分析。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="什么是spi"></a>什么是SPI<a class="hash-link" href="#什么是spi" title="Direct link to heading">#</a></h2><p><code>SPI</code>就是<code>Service Provider Interface</code>，直译&quot;服务提供方接口&quot;，是一种动态的服务发现机制，可以基于接口运行时动态加载接口的实现类（也就是接口编程 + 策略模式 + 配置文件的一种开发模式）。最常见的就是<code>JDK</code>内置的数据库驱动接口<code>java.sql.Driver</code>，不同的厂商可以对该接口完成不同的实现，例如<code>MySQL</code>（<code>MySQL</code>驱动包中的<code>com.mysql.jdbc.Driver</code>）、<code>PostgreSQL</code>（<code>PostgreSQL</code>驱动包中的<code>org.postgresql.Driver</code>）等等。</p><p><img alt="spi-jdk-api-diagram" src="/zh/assets/images/spi-jdk-api-diagram-667a15fab78f5b565111dd15c2abb352.png"></p><p><code>JDK</code>内置的<code>SPI</code>使用方式如下：</p><ul><li>在类路径的<code>META-INF/services</code>目录创建一个以接口全限定名称命名的文件（本质是一个<code>properties</code>）文件，例如命名为<code>java.sql.Driver</code></li><li>该文件中可以指定具体的实现类，也就是每个实现类的全类型限定名为单独一行，例如<code>META-INF/services/java.sql.Driver</code>中：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain"># META-INF/services/java.sql.Driver文件内容</span></span><span class="token-line" style="color:#393A34"><span class="token plain">com.mysql.jdbc.Driver</span></span><span class="token-line" style="color:#393A34"><span class="token plain">org.postgresql.Driver</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li>最后通过<code>java.util.ServiceLoader</code>对该文件进行加载，实例化接口的对应实现类（这里隐含了一个约定，<strong>所有实现类必须提供无参构造函数</strong>）</li></ul><p>底层的实现涉及到类加载、双亲委托模型等内容，这里就不展开。基于这种设计思路，很多主流框架了自实现了一套<code>SPI</code>扩展，例如<code>Dubbo</code>的<code>SPI</code>扩展模块，就是读取类路径下<code>META-INF/services/dubbo</code>目录的文件内容进行类加载。<code>Shenyu-SPI</code>模块也是沿用类似的设计思路。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="shenyu-spi源码分析"></a>shenyu-spi源码分析<a class="hash-link" href="#shenyu-spi源码分析" title="Direct link to heading">#</a></h2><p><code>shenyu-spi</code>模块十分精炼，代码结构如下：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI properties"><pre tabindex="0" class="prism-code language-properties codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">- shenyu-spi[module]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">  - org.apache.shenyu.spi[package]</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- ExtensionFactory</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- ExtensionLoader</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    -- SpiExtensionFactory</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这些类功能如下：</p><ul><li><code>ExtensionFactory</code>：<code>SPI</code>加载器工厂，本身也是一个<code>SPI</code>，用于基于<code>SPI</code>机制加载<code>ExtensionLoader</code>实例同时基于<code>ExtensionLoader</code>实例获取默认的<code>SPI</code>标识接口实现</li><li><code>SpiExtensionFactory</code>：其实就是<code>ExtensionFactory</code>的一个实现类</li><li><code>SPI</code>：标识注解，用于标识<code>SPI</code>，用于接口上</li><li><code>Join</code>：标识注解，用于实现类上，用于标识该类加入<code>SPI</code>系统</li><li><code>ExtensionLoader</code>：<code>SPI</code>加载器，类比<code>java.util.ServiceLoader</code>，用于加载<code>SPI</code>中接口的实现类</li></ul><p>接下来细看每个类的源码实现。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="spi"></a>@SPI<a class="hash-link" href="#spi" title="Direct link to heading">#</a></h3><p><code>org.apache.shenyu.spi.SPI</code>作为一个标识注解，主要用于<strong>接口</strong>上，也就是只有使用了<code>@SPI</code>的接口才能被<code>shenyu-spi</code>加载。这个类的注释中描述到：所有<code>SPI</code>系统相关参考<code>Apache Dubbo</code>的实现（这一点比较合情理，其实<code>SPI</code>扩展已经是一种成熟的方案，实现上大同小异）。该注解只有一个方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface SPI {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Value string.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the string</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String value() default &quot;&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>唯一的<code>value()</code>方法用于指定默认的<code>SPI</code>实现（可选的），后文在展开<code>ExtensionLoader</code>时候会说明。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="join"></a>@Join<a class="hash-link" href="#join" title="Direct link to heading">#</a></h3><p><code>org.apache.shenyu.spi.Join</code>也是一个标识注解，主要用在使用了<code>@SPI</code>注解的接口的<strong>实现类</strong>上，用于标识该类加入<code>SPI</code>系统中而后可以被<code>ExtensionLoader</code>加载。该注解也只有一个方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Join {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * It will be sorted according to the current serial number..</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return int.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int order() default 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>唯一的<code>order()</code>方法用于指定具体的顺序号，单个使用了<code>@SPI</code>的接口存在多个使用了<code>@Join</code>的实现类的时候，这个顺序号就确定了这些实现类实例的排序（顺序号小的排在前面）。</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="extensionloader"></a>ExtensionLoader<a class="hash-link" href="#extensionloader" title="Direct link to heading">#</a></h3><p><code>ExtensionLoader</code>就是&quot;类型扩展加载器&quot;，就是整个<code>SPI</code>模块的核心。先看其成员属性：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public final class ExtensionLoader&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // SLF4J日志句柄</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Logger LOG = LoggerFactory.getLogger(ExtensionLoader.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // SPI配置文件基于类路径下的相对目录</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final String SHENYU_DIRECTORY = &quot;META-INF/shenyu/&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // @SPI标识接口类型 -&gt; ExtensionLoader实例的缓存 =&gt; 注意这个是一个全局的静态变量</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private static final Map&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; LOADERS = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前@SPI标识接口类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Class&lt;T&gt; clazz;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类加载器实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final ClassLoader classLoader;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前ExtensionLoader缓存的已加载的实现类信息，使用值持有器包装，是一个HashMap，映射关系：实现类别名 -&gt; 实现类信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Holder&lt;Map&lt;String, ClassEntity&gt;&gt; cachedClasses = new Holder&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前ExtensionLoader缓存的已加载的实现类实例的值包装器，使用值持有器包装，映射关系：实现类别名 -&gt; 值持有器包装的实现类实体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 当前ExtensionLoader缓存的已加载的实现类实例，使用值持有器包装，映射关系：实现类类型 -&gt; 实现类实体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Map&lt;Class&lt;?&gt;, Object&gt; joinInstances = new ConcurrentHashMap&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存默认名称，来源于@SPI注解的value()方法非空白返回值，用于加载默认的接口实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private String cachedDefaultName;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // Holder比较器，按照Holder的order降序，也就是顺序号小的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Comparator&lt;Holder&lt;Object&gt;&gt; holderComparator = (o1, o2) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (o1.getOrder() &gt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (o1.getOrder() &lt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // ClassEntity比较器，按照ClassEntity的order降序，也就是顺序号小的排在前面</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    private final Comparator&lt;ClassEntity&gt; classEntityComparator = (o1, o2) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (o1.getOrder() &gt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else if (o1.getOrder() &lt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    };</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 暂时省略其他代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 值持有器，简单VO，用来存储泛型值和值加载顺序</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public static class Holder&lt;T&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里的值引用是volatile修饰，便于某线程更变另一线程马上读到最新的值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private volatile T value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Integer order;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 省略setter和getter代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类实体，主要存放加载的实现类的信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    static final class ClassEntity {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 名称，这里是指SPI实现类的别名，不是类名</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private String name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 加载顺序号</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Integer order;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // SPI实现类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private Class&lt;?&gt; clazz;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        private ClassEntity(final String name, final Integer order, final Class&lt;?&gt; clazz) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.name = name;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.order = order;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            this.clazz = clazz;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 省略setter和getter代码</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>分析完成员属性，不难发现下面几点：</p><ul><li><code>ExtensionLoader</code>会存在一个全局的静态缓存<code>LOADERS</code>，缓存已经创建的<code>ExtensionLoader</code>实例以防止重复创建的性能开销</li><li>每个<code>@SPI</code>标记的接口如果使用<code>ExtensionLoader</code>进行加载，都会生成一个全新的<code>ExtensionLoader</code>实例</li><li><code>@SPI</code>标记的接口如果有多个实现，那么最终获取到这些实现实例的时候是有序的</li></ul><p>接着看其构造函数和静态工厂方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 私有构造函数，需要入参为@SPI标识的接口类型和类加载器实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private ExtensionLoader(final Class&lt;T&gt; clazz, final ClassLoader cl) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 成员变量clazz赋值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.clazz = clazz;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 成员变量classLoader赋值</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    this.classLoader = cl;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里对于非ExtensionFactory接口类型会懒加载一个用于加载ExtensionFactory的ExtensionLoader</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!Objects.equals(clazz, ExtensionFactory.class)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getExtensionClassesEntity();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实例化getExtensionLoader，静态工厂方法，需要入参为@SPI标识的接口类型和类加载器实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(final Class&lt;T&gt; clazz, final ClassLoader cl) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 前缀校验，接口类型必须非空并且必须存在@SPI注解，否则抛出异常中断</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Objects.requireNonNull(clazz, &quot;extension clazz is null&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!clazz.isInterface()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;extension clazz (&quot; + clazz + &quot;) is not interface!&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!clazz.isAnnotationPresent(SPI.class)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;extension clazz (&quot; + clazz + &quot;) without @&quot; + SPI.class + &quot; Annotation&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 从缓存LOADERS中加载ExtensionLoader实例，不存在则创建，典型的懒加载模式</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ExtensionLoader&lt;T&gt; extensionLoader = (ExtensionLoader&lt;T&gt;) LOADERS.get(clazz);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.nonNull(extensionLoader)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return extensionLoader;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    LOADERS.putIfAbsent(clazz, new ExtensionLoader&lt;&gt;(clazz, cl));</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (ExtensionLoader&lt;T&gt;) LOADERS.get(clazz);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 实例化getExtensionLoader，静态工厂方法，需要入参为@SPI标识的接口类型，使用ExtensionLoader类的类加载器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public static &lt;T&gt; ExtensionLoader&lt;T&gt; getExtensionLoader(final Class&lt;T&gt; clazz) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return getExtensionLoader(clazz, ExtensionLoader.class.getClassLoader());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p><code>ExtensionLoader</code>使用了私有构造器，使用了静态工厂方法和懒加载模式。初始化<code>ExtensionLoader</code>完成后并不会触发类加载工作，真正的扫描和加载行为延迟到调用<code>getJoin</code>系列方法执行，这里扫码和加载所有实现类信息的方法调用链：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 加载所有扩展类信息，这里采用了DCL（双重锁校验）防止并发加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private Map&lt;String, ClassEntity&gt; getExtensionClassesEntity() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 缓存不存在</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, ClassEntity&gt; classes = cachedClasses.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(classes)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 加锁后再检查一次缓存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (cachedClasses) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            classes = cachedClasses.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Objects.isNull(classes)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 最终确认缓存不存在，则进行加载，并且标记顺序号为0</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                classes = loadExtensionClass();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                cachedClasses.setValue(classes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                cachedClasses.setOrder(0);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return classes;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加载当前ExtensionLoader中clazz的所有SPI系统内的实现类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private Map&lt;String, ClassEntity&gt; loadExtensionClass() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    SPI annotation = clazz.getAnnotation(SPI.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.nonNull(annotation)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里就是前面提到，如果@SPI注解的value()方法非空白返回值会作为默认实现的别名</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 也就是如果只使用了@SPI，那么就无法获取默认实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 如果使用了@SPI(&quot;foo&quot;)，可以通过别名foo去映射和获取默认实现</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        String value = annotation.value();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (StringUtils.isNotBlank(value)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            cachedDefaultName = value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 初始化一个Hashmap容器用于存储加载的实现类信息，这个变量会透传到下一个方法链</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Map&lt;String, ClassEntity&gt; classes = new HashMap&lt;&gt;(16);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加载目录中的属性文件</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    loadDirectory(classes);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return classes;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加载目录中的属性文件，并且加载文件中的实现类，目标目录：META-INF/shenyu/</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void loadDirectory(final Map&lt;String, ClassEntity&gt; classes) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 文件名 =&gt; META-INF/shenyu/$className</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String fileName = SHENYU_DIRECTORY + clazz.getName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 这里使用类加载器加载文件资源，如果传入的类加载器为空会使用系统类加载器</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Enumeration&lt;URL&gt; urls = Objects.nonNull(this.classLoader) ? classLoader.getResources(fileName)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                : ClassLoader.getSystemResources(fileName);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 遍历解析的文件URL集合</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        if (Objects.nonNull(urls)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            while (urls.hasMoreElements()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                URL url = urls.nextElement();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 通过文件URL加载资源</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                loadResources(classes, url);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException t) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        LOG.error(&quot;load extension class error {}&quot;, fileName, t);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 加载文件资源，解析文件并且加载实现类存储到classes中</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void loadResources(final Map&lt;String, ClassEntity&gt; classes, final URL url) throws IOException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 读取URL文件资源，加载到Properties中，每行格式为name=classPath</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    try (InputStream inputStream = url.openStream()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Properties properties = new Properties();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        properties.load(inputStream);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        properties.forEach((k, v) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String name = (String) k;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            String classPath = (String) v;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (StringUtils.isNotBlank(name) &amp;&amp; StringUtils.isNotBlank(classPath)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    // 基于name和classPath进行类加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    loadClass(classes, name, classPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                } catch (ClassNotFoundException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    throw new IllegalStateException(&quot;load extension resources error&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        });</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } catch (IOException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException(&quot;load extension resources error&quot;, e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 基于name（别名）和classPath（类全限定名称）进行类加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private void loadClass(final Map&lt;String, ClassEntity&gt; classes,</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                        final String name, final String classPath) throws ClassNotFoundException {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 类初始化，并且确定实现类必须是当前@SPI注解标识接口的子类</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; subClass = Objects.nonNull(this.classLoader) ? Class.forName(classPath, true, this.classLoader) : Class.forName(classPath);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!clazz.isAssignableFrom(subClass)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException(&quot;load extension resources error,&quot; + subClass + &quot; subtype is not of &quot; + clazz);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 实现类必须存在注解@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (!subClass.isAnnotationPresent(Join.class)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException(&quot;load extension resources error,&quot; + subClass + &quot; without @&quot; + Join.class + &quot; annotation&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果缓存中不存在同样别名的实现类才进行缓存，已经存在则校验旧的类型和当前实现类型是否一致</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ClassEntity oldClassEntity = classes.get(name);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(oldClassEntity)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // 创建类信息实体保存别名、顺序号和实现类并且缓存，映射关系：别名 -&gt; 类信息实体</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        Join joinAnnotation = subClass.getAnnotation(Join.class);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        ClassEntity classEntity = new ClassEntity(name, joinAnnotation.order(), subClass);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        classes.put(name, classEntity);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (!Objects.equals(oldClassEntity.getClazz(), subClass)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalStateException(&quot;load extension resources error,Duplicate class &quot; + clazz.getName() + &quot; name &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                + name + &quot; on &quot; + oldClassEntity.getClazz().getName() + &quot; or &quot; + subClass.getName());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>通过方法链<code>getExtensionClassesEntity -&gt; loadExtensionClass -&gt; loadDirectory -&gt; loadResources -&gt; loadClass</code>最终得到一个别名<code>-&gt;</code>实现类信息的映射，用于后续的实例化，见<code>getJoin()</code>方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">// 基于别名获取实现类实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public T getJoin(final String name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 别名必须为非空白字符串</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (StringUtils.isBlank(name)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new NullPointerException(&quot;get join name is null&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 这里也使用DCL去cachedInstances缓存中取别名对应的值持有器，值持有器为空则创建</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Holder&lt;Object&gt; objectHolder = cachedInstances.get(name);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(objectHolder)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        cachedInstances.putIfAbsent(name, new Holder&lt;&gt;());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        objectHolder = cachedInstances.get(name);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object value = objectHolder.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(value)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        synchronized (cachedInstances) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 加锁后再次判断值持有器中的值是否存在，不存在的时候则进行实现类实例化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            value = objectHolder.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            if (Objects.isNull(value)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                Holder&lt;T&gt; pair = createExtension(name);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                value = pair.getValue();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                int order = pair.getOrder();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                // 实例化完成后更新值持有器缓存</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                objectHolder.setValue(value);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                objectHolder.setOrder(order);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return (T) value;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 基于别名搜索已经加载的实现类信息，并且实例化对应的实现类进行值包装</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private Holder&lt;T&gt; createExtension(final String name) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 加载该@SPI标识接口的所有实现类信息并且获取对应别名的实现类信息</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    ClassEntity classEntity = getExtensionClassesEntity().get(name);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(classEntity)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        throw new IllegalArgumentException(&quot;name is error&quot;);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Class&lt;?&gt; aClass = classEntity.getClazz();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    // 如果实现类实例缓存中已经存在，则直接封装为值包装器返回，否则进行实例化</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Object o = joinInstances.get(aClass);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (Objects.isNull(o)) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        try {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            // 反射实例化并且缓存该实现类实例</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            joinInstances.putIfAbsent(aClass, aClass.newInstance());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            o = joinInstances.get(aClass);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        } catch (InstantiationException | IllegalAccessException e) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            throw new IllegalStateException(&quot;Extension instance(name: &quot; + name + &quot;, class: &quot;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                    + aClass + &quot;)  could not be instantiated: &quot; + e.getMessage(), e);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    Holder&lt;T&gt; objectHolder = new Holder&lt;&gt;();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    objectHolder.setOrder(classEntity.getOrder());</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    objectHolder.setValue((T) o);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    return objectHolder;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>从<code>createExtension()</code>方法中可以看到最终是使用反射方式实例化实现类，反射方法<code>newInstance()</code>要求该类必须提供无参构造函数，因为这里有一点隐含的约定：<code>SPI</code>实现类<strong>必须提供无参构造函数</strong>，否则会实例化失败。剩余的<code>getDefaultJoin()</code>和<code>getJoins()</code>是基于<code>getJoin()</code>方法进行扩展，功能并不复杂，这里就不展开分析了。另外，在<code>getJoin()</code>方法用到了多级缓存：</p><ul><li><code>cachedInstances</code>：通过别名就可以搜索到对应的实现类实例</li><li><code>joinInstances</code>：别名查找失败，则加载所有实现类信息，然后通过别名定位实现类类型，再通过实现类类型查找或者创建并缓存实现类实例后更新<code>cachedInstances</code>缓存</li></ul><p>到此，<code>ExtensionLoader</code>的源码分析完毕。这里再通过一个<code>ExtensionLoader</code>实例成员属性内存布局图可以加深理解：</p><p><img alt="spi-attr-memory-debug" src="/zh/assets/images/spi-attr-memory-debug-fbcf742eb342ba1aa47e9395bf8ffc0c.png"></p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="extensionfactory"></a>ExtensionFactory<a class="hash-link" href="#extensionfactory" title="Direct link to heading">#</a></h3><p><code>ExtensionFactory</code>是工厂模式里面的工厂接口，该接口定义了一个获取<code>SPI</code>实现（<strong>默认实现，唯一</strong>）实例的方法：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@SPI(&quot;spi&quot;)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface ExtensionFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * Gets Extension.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     *</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param &lt;T&gt;   the type parameter</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param key   此参数暂时没有使用，猜测是预留用于映射@SPI的value()</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @param clazz @SPI标识的接口类型</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return the extension</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    &lt;T&gt; T getExtension(String key, Class&lt;T&gt; clazz);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>接着看其实现类<code>SpiExtensionFactory</code>的代码：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class SpiExtensionFactory implements ExtensionFactory {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public &lt;T&gt; T getExtension(final String key, final Class&lt;T&gt; clazz) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return Optional.ofNullable(clazz)   // 入参clazz非空</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .filter(Class::isInterface)  // 入参clazz必须是接口</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .filter(cls -&gt; cls.isAnnotationPresent(SPI.class))  // 入参clazz必须被@SPI标识</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .map(ExtensionLoader::getExtensionLoader)  // 基于clazz这个接口类型实例化ExtensionLoader</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .map(ExtensionLoader::getDefaultJoin)  // 获取该@SPI标识接口的默认实现，不存在则返回NULL</span></span><span class="token-line" style="color:#393A34"><span class="token plain">                .orElse(null);</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>这里值得注意的是：<code>ExtensionFactory</code>本身也是<code>SPI</code>系统的一部分。因此使用<code>ExtensionFactory</code>的时候可以直接实例化：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">ExtensionFactory extensionFactory = new SpiExtensionFactory();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>也可以基于<code>ExtensionLoader</code>进行加载：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain"># 在类路径META-INF/services/shenyu目录下添加一个属性文件org.apache.shenyu.spi.ExtensionFactory，内容是</span></span><span class="token-line" style="color:#393A34"><span class="token plain">spi=org.apache.shenyu.spi.SpiExtensionFactory</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain"># 然后基于ExtensionLoader进行加载</span></span><span class="token-line" style="color:#393A34"><span class="token plain">ExtensionFactory extensionFactory = ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getDefaultJoin();</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>得到<code>ExtensionFactory</code>实例后就可以基于<code>@SPI</code>接口加载其默认实现类的实例。</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="扩展和建议"></a>扩展和建议<a class="hash-link" href="#扩展和建议" title="Direct link to heading">#</a></h2><p>下面是个人的一些见解。目前来看，<code>Shenyu</code>中的<code>SPI</code>模块功能是完备的，建议考虑引入两个常用的功能：</p><ul><li>可以在<code>Join</code>注解中添加属性标记<code>SPI</code>接口实现类生成的实例是单例还是全新实例，类似于<code>Spring</code>中的<code>Scope</code>声明（<code>singleton</code>或者<code>prototype</code>）那样，例如：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">@Documented</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Retention(RetentionPolicy.RUNTIME)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Target(ElementType.TYPE)</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public @interface Join {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * It will be sorted according to the current serial number..</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return int.</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    int order() default 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    /**</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * The join class instance should be singleton or not</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     * @return true or false</span></span><span class="token-line" style="color:#393A34"><span class="token plain">     */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    boolean isSingleton() default true;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><ul><li><strong>可选地</strong>让<code>SPI</code>的实现类实现一个初始化器接口，在该实现类实例化后回调初始化器接口方法，例如：</li></ul><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">public interface ExtensionInitializer {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    void init();  </span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">/**</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> * demo</span></span><span class="token-line" style="color:#393A34"><span class="token plain"> */</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@SPI</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public interface JdbcSPI {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    String getClassName();</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">@Join</span></span><span class="token-line" style="color:#393A34"><span class="token plain">public class MysqlSPI implements JdbcSPI, ExtensionInitializer {</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public void init() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        // callback when MysqlSPI instance init</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span></span><span class="token-line" style="color:#393A34"><span class="token plain">    @Override</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    public String getClassName() {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return &quot;mysql&quot;;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><p>如果添加了这两点，能够满足很多现实场景的需求。另外，<code>ExtensionLoader</code>中的两处比较器成员变量可以进行代码精简，例如对<code>classEntityComparator</code>而言：</p><div class="codeBlockContainer_J+bg"><div class="codeBlockContent_csEI java"><pre tabindex="0" class="prism-code language-java codeBlock_rtdJ thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_1zSZ"><span class="token-line" style="color:#393A34"><span class="token plain">private final Comparator&lt;ClassEntity&gt; classEntityComparator = (o1, o2) -&gt; {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    if (o1.getOrder() &gt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else if (o1.getOrder() &lt; o2.getOrder()) {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return -1;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    } else {</span></span><span class="token-line" style="color:#393A34"><span class="token plain">        return 0;</span></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span></span><span class="token-line" style="color:#393A34"><span class="token plain">};</span></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block">
</span></span><span class="token-line" style="color:#393A34"><span class="token plain">// 可以精简为Comparator提供的静态工厂方法和方法引用</span></span><span class="token-line" style="color:#393A34"><span class="token plain">private final Comparator&lt;ClassEntity&gt; classEntityComparator = Comparator.comparing(ClassEntity::getOrder);</span></span></code></pre><button type="button" aria-label="Copy code to clipboard" class="copyButton_M3SB clean-btn">Copy</button></div></div><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_WiXH" id="小结"></a>小结<a class="hash-link" href="#小结" title="Direct link to heading">#</a></h2><p>基于<code>Java</code>原生<code>SPI</code>设计思路上设计出来的<code>SPI</code>框架具备了松耦合、高易用性和高扩展性的特点，并且添加了加载实例缓存、并发安全等特性，填补了原生<code>JDK</code>中<code>SPI</code>的一些缺陷，<code>Shenyu</code>的<code>SPI</code>模块也是如此。正是由于此强大的<code>SPI</code>模块的存在，<code>Shenyu</code>中的其他模块如<code>Plugin</code>模块可以实现快速插拔式配置，让加载一个全新开发的插件实例变得更加容易。</p></div><footer class="row docusaurus-mt-lg"><div class="col"><b>Tags:</b><a class="margin-horiz--sm" href="/zh/blog/tags/spi">SPI</a><a class="margin-horiz--sm" href="/zh/blog/tags/apache-shen-yu">Apache ShenYu</a></div></footer></article><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/zh/blog"><div class="pagination-nav__label">« Newer Entries</div></a></div><div class="pagination-nav__item pagination-nav__item--next"></div></nav></main></div></div></div></div>
<script src="/zh/assets/js/runtime~main.45f1436c.js"></script>
<script src="/zh/assets/js/main.61e23882.js"></script>
</body>
</html>